%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{amrex Documentation}
\date{Sep 09, 2021}
\release{21.10\sphinxhyphen{}dev}
\author{AMReX Team}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
AMReX is a software framework containing all the functionality to write
massively parallel, block\sphinxhyphen{}structured adaptive mesh refinement (AMR)
applications. AMReX is freely available \sphinxhref{https://github.com/AMReX-Codes/amrex}{on Github}.

\sphinxAtStartPar
AMReX is developed at LBNL, NREL, and ANL as part of the Block\sphinxhyphen{}Structured AMR
Co\sphinxhyphen{}Design Center in DOE’s Exascale Computing Project.

\sphinxAtStartPar
All of AMReX’s development is done in the github repository under the
development branch; anyone can see the latest updates. A monthly release is tagged at the beginning
of each month.

\sphinxAtStartPar
We are always happy to have users contribute to the AMReX source code. To
contribute, issue a pull request against the development branch (details \sphinxhref{https://help.github.com/articles/creating-a-pull-request/}{here}).  Any level of
changes are welcomed: documentation, bug fixes, new test problems, new solvers,
etc.  To obtain help, simply post a
\sphinxhref{https://github.com/AMReX-Codes/amrex/discussions}{discussion}
or an \sphinxhref{https://github.com/AMReX-Codes/amrex/issues}{issue}
on the AMReX GitHub webpage.

\sphinxAtStartPar
There are small stand\sphinxhyphen{}alone example codes that demonstrate how to use different parts of the AMReX functionality;
there is extensive documentation for these tutorial codes at \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/index.html\#amrex-tut-indx}{AMReX Tutorials}

\sphinxAtStartPar
Besides this documentation, there is API documentation generated by \sphinxhref{https://amrex-codes.github.io/amrex/doxygen}{Doxygen}.

\sphinxAtStartPar
Documentation on migration from BoxLib is available in the AMReX repository at Docs/Migration.


\chapter{AMReX Introduction}
\label{\detokenize{Introduction:amrex-introduction}}\label{\detokenize{Introduction::doc}}
\sphinxAtStartPar
AMReX is a publicly available software framework designed for building
massively parallel block\sphinxhyphen{}structured adaptive mesh refinement (AMR)
applications.

\sphinxAtStartPar
Key features of AMReX include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
C++ and Fortran interfaces

\item {} 
\sphinxAtStartPar
1\sphinxhyphen{}, 2\sphinxhyphen{} and 3\sphinxhyphen{}D support

\item {} 
\sphinxAtStartPar
Support for cell\sphinxhyphen{}centered, face\sphinxhyphen{}centered, edge\sphinxhyphen{}centered, and nodal data

\item {} 
\sphinxAtStartPar
Support for hyperbolic, parabolic, and elliptic solves on hierarchical
adaptive grid structure

\item {} 
\sphinxAtStartPar
Optional subcycling in time for time\sphinxhyphen{}dependent PDEs

\item {} 
\sphinxAtStartPar
Support for particles

\item {} 
\sphinxAtStartPar
Support for embedded boundary (cut cell) representations of complex geometries

\item {} 
\sphinxAtStartPar
Parallelization via flat MPI, OpenMP, hybrid MPI/OpenMP, hybrid
MPI/(CUDA or HIP or DPC++), or MPI/MPI

\item {} 
\sphinxAtStartPar
Parallel I/O

\item {} 
\sphinxAtStartPar
Plotfile format supported by AmrVis, VisIt, ParaView, and yt.

\end{itemize}

\sphinxAtStartPar
AMReX is developed at LBNL, NREL, and ANL as part of the Block\sphinxhyphen{}Structured AMR
Co\sphinxhyphen{}Design Center in DOE’s Exascale Computing Project.


\chapter{Getting Started}
\label{\detokenize{GettingStarted_Chapter:getting-started}}\label{\detokenize{GettingStarted_Chapter:chap-gettingstarted}}\label{\detokenize{GettingStarted_Chapter::doc}}
\sphinxAtStartPar
In this chapter, we will walk you through two simple examples. It is assumed
here that your machine has GNU Make, Python, GCC (including gfortran), and MPI,
although AMReX can be built with CMake and other compilers.


\section{Downloading the Code}
\label{\detokenize{GettingStarted:downloading-the-code}}\label{\detokenize{GettingStarted::doc}}
\sphinxAtStartPar
The source code is available at \sphinxurl{https://github.com/AMReX-Codes/amrex}. The
GitHub repo is our central repo for development. The development branch
includes the latest state of the code, and it is tagged as a release
on a monthly basis with version number YY.MM (e.g., 17.04). The MM part of the
version is incremented every month, and the YY part every year.  Bug fix
releases are tagged with YY.MM.patch (e.g., 17.04.1).

\sphinxAtStartPar
AMReX can also be obtained using spack (\sphinxurl{https://spack.io/}).  Assuming
you have spack installed, simply type “spack install amrex”.


\section{Example: Hello World}
\label{\detokenize{GettingStarted:example-hello-world}}
\sphinxAtStartPar
The source code of this example is at \sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HelloWorld\_C/}}
and is also shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}Print.H\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Initialize}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello world from AMReX version }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Version}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The main body of this short example contains three statements.  Usually the
first and last statements for the \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{main}\DUrole{punctuation}{(…)}}} function of every
program should be calling \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Initialize}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Finalize}}},
respectively. The second statement calls \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Print}}} to print out a
string that includes the AMReX version returned by the \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Version}}}
function. The example code includes two AMReX header files. Note that the name
of all AMReX header files starts with \sphinxcode{\sphinxupquote{AMReX\_}} (or just AMReX in the case of
AMReX.H). All AMReX C++ functions are in the \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}}} namespace.


\subsection{Building the Code}
\label{\detokenize{GettingStarted:building-the-code}}
\sphinxAtStartPar
You build the code in the \sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HelloWorld\_C/}} directory.
Typing \sphinxcode{\sphinxupquote{make}} will start the compilation process and result in an executable
named \sphinxcode{\sphinxupquote{main3d.gnu.DEBUG.ex}}. The name shows that the GNU compiler with debug
options set by AMReX is used.  It also shows that the executable is built for
3D. Although this simple example code is dimension independent, dimensionality
does matter for all non\sphinxhyphen{}trivial examples. The build process can be adjusted by
modifying the \sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HelloWorld\_C/GNUmakefile}} file.  More
details on how to build AMReX can be found in {\hyperref[\detokenize{BuildingAMReX_Chapter:chap-buildingamrex}]{\sphinxcrossref{\DUrole{std,std-ref}{Building AMReX}}}}.


\subsection{Running the Code}
\label{\detokenize{GettingStarted:running-the-code}}
\sphinxAtStartPar
The example code can be run as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{./main3d.gnu.DEBUG.ex}
\end{sphinxVerbatim}

\sphinxAtStartPar
The result may look like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) initialized}
\PYG{g+go}{Hello world from AMReX version 17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) finalized}
\end{sphinxVerbatim}

\sphinxAtStartPar
The version string means the current commit 5775aed933c4 (note that the first
letter g in g577.. is not part of the hash) is based on 17.05 with 30
additional commits and the AMReX work tree is dirty (i.e. there are uncommitted
changes).

\sphinxAtStartPar
In the GNUmakefile there are compilation options for DEBUG mode (less optimized
code with more error checking), dimensionality, compiler type, and flags to
enable MPI and/or OpenMP parallelism.  If there are multiple instances of a
parameter, the last instance takes precedence.


\subsection{Parallelization}
\label{\detokenize{GettingStarted:parallelization}}
\sphinxAtStartPar
Now let’s build with MPI by typing \sphinxcode{\sphinxupquote{make USE\_MPI=TRUE}} (alternatively you can
set \sphinxcode{\sphinxupquote{USE\_MPI=TRUE}} in the GNUmakefile). This should make an executable named
\sphinxcode{\sphinxupquote{main3d.gnu.DEBUG.MPI.ex}}. Note MPI in the file name. You can then run,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{mpiexec \PYGZhy{}n 4 ./main3d.gnu.DEBUG.MPI.ex amrex.v=1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The result may look like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{MPI initialized with 4 MPI processes}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) initialized}
\PYG{g+go}{Hello world from AMReX version 17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) finalized}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the compilation fails, you are referred to {\hyperref[\detokenize{BuildingAMReX_Chapter:chap-buildingamrex}]{\sphinxcrossref{\DUrole{std,std-ref}{Building AMReX}}}} for
more details on how to configure the build system.  The \sphinxstyleemphasis{optional} command line
argument \sphinxcode{\sphinxupquote{amrex.v=1}} sets the AMReX verbosity level
to 1 to print the number of MPI processes used.  The default verbosity
level is 1, and you can pass \sphinxcode{\sphinxupquote{amrex.v=0}} to turn it off.
More details on how runtime parameters are handled can be found in
section {\hyperref[\detokenize{Basics:sec-basics-parmparse}]{\sphinxcrossref{\DUrole{std,std-ref}{ParmParse}}}}.

\sphinxAtStartPar
If you want to build with OpenMP, type make \sphinxcode{\sphinxupquote{USE\_OMP=TRUE}}.  This should make
an executable named \sphinxcode{\sphinxupquote{main3d.gnu.DEBUG.OMP.ex}}. Note OMP in the file name.
Make sure the \sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS}} environment variable is set on your system.
You can then run,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{OMP\PYGZus{}NUM\PYGZus{}THREADS=4 ./main3d.gnu.DEBUG.OMP.ex}
\end{sphinxVerbatim}

\sphinxAtStartPar
The result may look like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{OMP initialized with 4 OMP threads}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) initialized}
\PYG{g+go}{Hello world from AMReX version 17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) finalized}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that you can build with both \sphinxcode{\sphinxupquote{USE\_MPI=TRUE}} and \sphinxcode{\sphinxupquote{USE\_OMP=TRUE}}.  You
can then run,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{OMP\PYGZus{}NUM\PYGZus{}THREADS=4 mpiexec \PYGZhy{}n 2 ./main3d.gnu.DEBUG.MPI.OMP.ex}
\end{sphinxVerbatim}

\sphinxAtStartPar
The result may look like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{MPI initialized with 2 MPI processes}
\PYG{g+go}{OMP initialized with 4 OMP threads}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) initialized}
\PYG{g+go}{Hello world from AMReX version 17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty}
\PYG{g+go}{AMReX (17.05\PYGZhy{}30\PYGZhy{}g5775aed933c4\PYGZhy{}dirty) finalized}
\end{sphinxVerbatim}


\section{Example: Heat Equation Solver}
\label{\detokenize{GettingStarted:example-heat-equation-solver}}\label{\detokenize{GettingStarted:sec-heat-equation}}
\sphinxAtStartPar
We now look at a more complicated example at
\sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HeatEquation\_EX1\_C}} and show how simulation results
can be visualized. This example solves the heat equation,
\begin{equation*}
\begin{split}\frac{\partial\phi}{\partial t} = \nabla^2\phi\end{split}
\end{equation*}
\sphinxAtStartPar
using forward Euler temporal integration on a periodic domain.  We could use a
5\sphinxhyphen{}point (in 2D) or 7\sphinxhyphen{}point (in 3D) stencil, but for demonstration purposes we
spatially discretize the PDE by first constructing (negative) fluxes on cell faces, e.g.,
\begin{equation*}
\begin{split}F_{i+^1\!/_2,\,j} = \frac{\phi_{i+1,j}-\phi_{i,j}}{\Delta x},\end{split}
\end{equation*}
\sphinxAtStartPar
and then taking the divergence to update the cells,
\begin{equation*}
\begin{split}\phi_{i,\,j}^{n+1} = \phi_{i,\,j}^n
+ \frac{\Delta t}{\Delta x}\left(F_{i+^1\!/_2,\,j}-F_{i-^1\!/_2,\,j}\right)
+ \frac{\Delta t}{\Delta y}\left(F_{i,\,j+^1\!/_2}-F_{i,\,j-^1\!/_2}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
The implementation details of the code are discussed in section
{\hyperref[\detokenize{Basics:sec-basics-heat1}]{\sphinxcrossref{\DUrole{std,std-ref}{Example: HeatEquation\_EX1\_C}}}}.  For now let’s just build and run the code, and
visualize the results.


\subsection{Building and Running the Code}
\label{\detokenize{GettingStarted:building-and-running-the-code}}
\sphinxAtStartPar
To build a 2D executable, go to
\sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HeatEquation\_EX1\_C/Exec}} and type \sphinxcode{\sphinxupquote{make DIM=2}}. This
will generate an executable named \sphinxcode{\sphinxupquote{main2d.gnu.ex}}. To run it, type,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{./main2d.gnu.ex inputs\PYGZus{}2d}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the command takes a file \sphinxcode{\sphinxupquote{inputs\_2d.}} The calculation solves the
heat equation in 2D on a domain with \(256 \times 256\) cells.  It runs
\(10,000\) steps and makes a plotfile every \(1,000\) steps.  When the
run finishes, you will have a number of plotfiles, \sphinxcode{\sphinxupquote{plt00000, plt01000,}} etc,
in the directory where you are running.  You can control runtime parameters
such as how many time steps to run and how often to write plotfiles by setting
them in \sphinxcode{\sphinxupquote{inputs\_2d.}}


\section{Visualization}
\label{\detokenize{GettingStarted:visualization}}
\sphinxAtStartPar
There are several visualization tools that can be used for AMReX plotfiles.
One standard tool used within the AMReX\sphinxhyphen{}community is Amrvis, a package
developed and supported by CCSE that is designed specifically for highly
efficient visualization of block\sphinxhyphen{}structured hierarchical AMR data.  (Amrvis can
also be used to visualize performance data; see the {\hyperref[\detokenize{AMReX_Profiling_Tools_Chapter:chap-amrex-based-profiling-tools}]{\sphinxcrossref{\DUrole{std,std-ref}{AMReX\sphinxhyphen{}based Profiling Tools}}}} chapter for further details.) Plotfiles can also be viewed
using the VisIt, ParaView, and yt packages.  Particle data can be viewed using
ParaView.  Refer to Chapter on {\hyperref[\detokenize{Visualization_Chapter:chap-visualization}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualization}}}} for how to use each of
these tools.


\chapter{Building AMReX}
\label{\detokenize{BuildingAMReX_Chapter:building-amrex}}\label{\detokenize{BuildingAMReX_Chapter:chap-buildingamrex}}\label{\detokenize{BuildingAMReX_Chapter::doc}}
\sphinxAtStartPar
In this chapter, we discuss AMReX’s build systems.  Additionally, it
is also possible to install AMReX using spack (\sphinxurl{https://spack.io/}).

\sphinxAtStartPar
There are three ways to use AMReX’s build systems. Most AMReX
developers use GNU Make. With this approach, there is no installation
step; application codes adopt AMReX’s build system and compile AMReX
while compiling their own codes. This will be discussed in more detail
in the section on {\hyperref[\detokenize{BuildingAMReX:sec-build-make}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with GNU Make}}}}.

\sphinxAtStartPar
The second approach is to build and install AMReX as a library using GNU make ({\hyperref[\detokenize{BuildingAMReX:sec-build-lib}]{\sphinxcrossref{\DUrole{std,std-ref}{Building libamrex}}}});
an application code then uses its own build system and links to AMReX as an external library.

\sphinxAtStartPar
Finally, AMReX can also be built with CMake, as detailed in the section on {\hyperref[\detokenize{BuildingAMReX:sec-build-cmake}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with CMake}}}}.

\sphinxAtStartPar
AMReX requires a C++ compiler that supports the C++14 standard, a
Fortran compiler that supports the Fortran 2003 standard, and a C
compiler that supports the C99 standard.  Prerequisites for building
with GNU Make include Python (\textgreater{}= 2.7, including 3) and standard tools
available in any Unix\sphinxhyphen{}like environments (e.g., Perl and sed).  For
building with CMake, the minimal requirement is version 3.14.

\sphinxAtStartPar
Please note that we fully support AMReX for Linux systems in general and on the
DOE supercomputers (e.g. Cori, Summit) in particular.  Many of our users do build
and use AMReX on Macs but we do not have the resources to fully support Mac users.


\section{Building with GNU Make}
\label{\detokenize{BuildingAMReX:building-with-gnu-make}}\label{\detokenize{BuildingAMReX:sec-build-make}}\label{\detokenize{BuildingAMReX::doc}}
\sphinxAtStartPar
In this build approach, you write your own make files defining a number of
variables and rules. Then you invoke  \sphinxcode{\sphinxupquote{make}} to start the building process.
This will result in an executable upon successful completion. The temporary
files generated in the building process are stored in a temporary directory
named  \sphinxcode{\sphinxupquote{tmp\_build\_dir}}.


\subsection{Dissecting a Simple Make File}
\label{\detokenize{BuildingAMReX:dissecting-a-simple-make-file}}
\sphinxAtStartPar
An example of building with GNU Make can be found in
\sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HelloWorld\_C}}.  \hyperref[\detokenize{BuildingAMReX:tab-makevars}]{Table \ref{\detokenize{BuildingAMReX:tab-makevars}}} below shows a
list of important variables.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Important make variables}\label{\detokenize{BuildingAMReX:id1}}\label{\detokenize{BuildingAMReX:tab-makevars}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
AMREX\_HOME
&
\sphinxAtStartPar
Path to amrex
&
\sphinxAtStartPar
environment
\\
\hline
\sphinxAtStartPar
COMP
&
\sphinxAtStartPar
gnu, cray, ibm, intel, llvm, or pgi
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
CXXSTD
&
\sphinxAtStartPar
C++ standard (\sphinxcode{\sphinxupquote{c++14}}, \sphinxcode{\sphinxupquote{c++17}},
\sphinxcode{\sphinxupquote{c++20}})
&
\sphinxAtStartPar
compiler default,
at least \sphinxcode{\sphinxupquote{c++14}}
\\
\hline
\sphinxAtStartPar
DEBUG
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
DIM
&
\sphinxAtStartPar
1 or 2 or 3
&
\sphinxAtStartPar
3
\\
\hline
\sphinxAtStartPar
PRECISION
&
\sphinxAtStartPar
DOUBLE or FLOAT
&
\sphinxAtStartPar
DOUBLE
\\
\hline
\sphinxAtStartPar
TEST
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_ASSERTION
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_MPI
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_OMP
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_CUDA
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_HIP
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_DPCPP
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
USE\_RPATH
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
FALSE
\\
\hline
\sphinxAtStartPar
WARN\_ALL
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
TRUE for DEBUG
FALSE otherwise
\\
\hline\begin{description}
\item[{AMREX\_CUDA\_ARCH}] \leavevmode
\sphinxAtStartPar
or CUDA\_ARCH

\end{description}
&
\sphinxAtStartPar
CUDA arch such as 70
&
\sphinxAtStartPar
70 if not set
or detected
\\
\hline\begin{description}
\item[{AMREX\_AMD\_ARCH}] \leavevmode
\sphinxAtStartPar
or AMD\_ARCH

\end{description}
&
\sphinxAtStartPar
AMD GPU arch such as gfx908
&
\sphinxAtStartPar
none if the
machine is unknown
\\
\hline
\sphinxAtStartPar
USE\_GPU\_RDC
&
\sphinxAtStartPar
TRUE or FALSE
&
\sphinxAtStartPar
TRUE
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
At the beginning of \sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HelloWorld\_C/GNUmakefile}},
\sphinxcode{\sphinxupquote{AMREX\_HOME}} is set to the path to the top directory of AMReX.  Note that in
the example \sphinxcode{\sphinxupquote{\DUrole{operator}{?=}}} is a conditional variable assignment operator that only
has an effect if \sphinxcode{\sphinxupquote{AMREX\_HOME}} has not been defined (including in the
environment). One can also set \sphinxcode{\sphinxupquote{AMREX\_HOME}} as an environment variable. For
example in bash, one can set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{AMREX\PYGZus{}HOME}\PYG{o}{=}/path/to/amrex
\end{sphinxVerbatim}

\sphinxAtStartPar
alternatively, in tcsh one can set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
setenv AMREX\PYGZus{}HOME /path/to/amrex
\end{sphinxVerbatim}

\sphinxAtStartPar
Note: when setting \sphinxcode{\sphinxupquote{AMREX\_HOME}} in the \sphinxcode{\sphinxupquote{GNUmakefile}}, be aware that \sphinxcode{\sphinxupquote{\textasciitilde{}}} does
not expand, so \sphinxcode{\sphinxupquote{AMREX\_HOME=\textasciitilde{}/amrex/}} will yield an error.

\sphinxAtStartPar
One must set the \sphinxcode{\sphinxupquote{COMP}} variable to choose a compiler. Currently the list of
supported compilers includes gnu, cray, ibm, intel, llvm, and pgi.

\sphinxAtStartPar
One could set the \sphinxcode{\sphinxupquote{DIM}} variable to either 1, 2, or 3, depending on
the dimensionality of the problem.  The default dimensionality is 3.
AMReX uses double precision by default.  One can change to single
precision by setting \sphinxcode{\sphinxupquote{PRECISION=FLOAT}}.
(Particles have an equivalent flag \sphinxcode{\sphinxupquote{USE\_SINGLE\_PRECISION\_PARTICLES=TRUE/FALSE}}.)

\sphinxAtStartPar
Variables \sphinxcode{\sphinxupquote{DEBUG}}, \sphinxcode{\sphinxupquote{TEST}}, \sphinxcode{\sphinxupquote{USE\_MPI}} and \sphinxcode{\sphinxupquote{USE\_OMP}} are optional with
default set to FALSE.  The meaning of these variables should
be obvious.  When \sphinxcode{\sphinxupquote{DEBUG=TRUE}}, aggressive compiler optimization flags are
turned off and assertions in source code are turned on. For production runs,
\sphinxcode{\sphinxupquote{DEBUG}} should be set to FALSE. \sphinxcode{\sphinxupquote{TEST}} and \sphinxcode{\sphinxupquote{USE\_ASSERTION}} are set by
default in CI and add slight debugging, e.g., initializing default values in FABs.
An advanced variable, \sphinxcode{\sphinxupquote{MPI\_THREAD\_MULTIPLE}}, can be set to TRUE to initialize
MPI with support for concurrent MPI calls from multiple threads.

\sphinxAtStartPar
Variables \sphinxcode{\sphinxupquote{USE\_CUDA}}, \sphinxcode{\sphinxupquote{USE\_HIP}} and \sphinxcode{\sphinxupquote{USE\_DPCPP}} are used for
targeting Nvidia, AMD and Intel GPUs, respectively.  At most one of
the three can be TRUE.
For HIP and DPC++/SYCL builds, we do only test against C++17 builds at the moment.

\sphinxAtStartPar
The variable \sphinxcode{\sphinxupquote{USE\_RPATH}} controls the link mechanism to dependent libraries.
If enabled, the library path at link time will be saved as a
\sphinxhref{https://en.wikipedia.org/wiki/Rpath}{rpath hint} in created binaries.
When disabled, dynamic library paths could be provided via \sphinxcode{\sphinxupquote{export LD\_LIBRARY\_PATH}}
hints at runtime.

\sphinxAtStartPar
For GCC and Clang, the variable \sphinxcode{\sphinxupquote{WARN\_ALL}} controls the compiler’s warning options.  There is
also a make variable \sphinxcode{\sphinxupquote{WARN\_ERROR}} (with default of \sphinxcode{\sphinxupquote{FALSE}}) to turn warnings into errors.

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{USE\_CUDA}} is \sphinxcode{\sphinxupquote{TRUE}}, the make system will try to detect what CUDA
arch should be used by running
\sphinxcode{\sphinxupquote{\$(CUDA\_HOME)/extras/demo\_suite/deviceQuery}} if your computer is unknown.
If it fails to detect the CUDA arch, the default value of 70 will be used.
The user could override it by \sphinxcode{\sphinxupquote{make USE\_CUDA=TRUE CUDA\_ARCH=80}} or \sphinxcode{\sphinxupquote{make
USE\_CUDA=TRUE AMREX\_CUDA\_ARCH=80}}.

\sphinxAtStartPar
After defining these make variables, a number of files, \sphinxcode{\sphinxupquote{Make.defs,
Make.package}} and \sphinxcode{\sphinxupquote{Make.rules}}, are included in the GNUmakefile. AMReX\sphinxhyphen{}based
applications do not need to include all directories in AMReX; an application
which does not use particles, for example, does not need to include files from
the Particle directory in its build.  In this simple example, we only need to
include \sphinxcode{\sphinxupquote{\$(AMREX\_HOME)/Src/Base/Make.package}}. An application code also has
its own Make.package file (e.g., \sphinxcode{\sphinxupquote{./Make.package}} in this example) to append
source files to the build system using operator \sphinxcode{\sphinxupquote{+=}}. Variables for various
source files are shown below.
\begin{quote}
\begin{description}
\item[{CEXE\_sources}] \leavevmode
\sphinxAtStartPar
C++ source files. Note that C++ source files are assumed to have a .cpp
extension.

\item[{CEXE\_headers}] \leavevmode
\sphinxAtStartPar
C++ headers with .h, .hpp, or .H extension.

\item[{cEXE\_sources}] \leavevmode
\sphinxAtStartPar
C source files with .c extension.

\item[{cEXE\_headers}] \leavevmode
\sphinxAtStartPar
C headers with .h extension.

\item[{f90EXE\_sources}] \leavevmode
\sphinxAtStartPar
Free format Fortran source with .f90 extension.

\item[{F90EXE\_sources}] \leavevmode
\sphinxAtStartPar
Free format Fortran source with .F90 extension.  Note that these
Fortran files will go through preprocessing.

\end{description}
\end{quote}

\sphinxAtStartPar
In this simple example, the extra source file, \sphinxcode{\sphinxupquote{main.cpp}} is in the current
directory that is already in the build system’s search path. If this example
has files in a subdirectory (e.g., \sphinxcode{\sphinxupquote{mysrcdir}}), you will then need to add the
following to \sphinxcode{\sphinxupquote{Make.package}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{VPATH\PYGZus{}LOCATIONS} \PYG{o}{+=} mysrcdir
\PYG{n+nv}{INCLUDE\PYGZus{}LOCATIONS} \PYG{o}{+=} mysrcdir
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{VPATH\_LOCATIONS}} and \sphinxcode{\sphinxupquote{INCLUDE\_LOCATIONS}} are the search path for
source and header files, respectively.


\subsection{Tweaking the Make System}
\label{\detokenize{BuildingAMReX:tweaking-the-make-system}}
\sphinxAtStartPar
The GNU Make build system is located at \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake}}.  You can read
\sphinxcode{\sphinxupquote{README.md}} and the make files there for more information. Here we will give
a brief overview.

\sphinxAtStartPar
Besides building executable, other common make commands include:
\begin{quote}
\begin{description}
\item[{\sphinxcode{\sphinxupquote{make cleanconfig}}}] \leavevmode
\sphinxAtStartPar
This removes the executable, .o files, and the temporarily generated
files for the given build. Note that one can add
additional targets to this rule using the double colon (::)

\item[{\sphinxcode{\sphinxupquote{make clean}} and \sphinxcode{\sphinxupquote{make realclean}}}] \leavevmode
\sphinxAtStartPar
These remove all files generated by make for all builds.

\item[{\sphinxcode{\sphinxupquote{make help}}}] \leavevmode
\sphinxAtStartPar
This shows the rules for compilation.

\item[{\sphinxcode{\sphinxupquote{make print\sphinxhyphen{}xxx}}}] \leavevmode
\sphinxAtStartPar
This shows the value of variable xxx. This is very useful for debugging
and tweaking the make system.

\end{description}
\end{quote}

\sphinxAtStartPar
Compiler flags are set in \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/comps/}}. Note that variables
like \sphinxcode{\sphinxupquote{CXX}} and \sphinxcode{\sphinxupquote{CXXFLAGS}} are reset in that directory and their values in
environment variables are disregarded.  However, one could override them
with make command line arguments (e.g., \sphinxcode{\sphinxupquote{make CXX=/path/to/my/mpicxx}}).
Site\sphinxhyphen{}specific setups (e.g., the MPI
installation) are in \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/sites/}}, which includes a generic
setup in \sphinxcode{\sphinxupquote{Make.unknown}}. You can override the setup by having your own
\sphinxcode{\sphinxupquote{sites/Make.\$(host\_name)}} file, where variable \sphinxcode{\sphinxupquote{host\_name}} is your host
name in the make system and can be found via \sphinxcode{\sphinxupquote{make print\sphinxhyphen{}host\_name}}.  You can
also have an \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/Make.local}} file to override various
variables. See \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/Make.local.template}} for more examples of
how to customize the build process.

\sphinxAtStartPar
If you need to pass macro definitions to the preprocessor, you can add
them to your make file as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{DEFINES} \PYG{o}{+=} \PYGZhy{}Dmyname1 \PYGZhy{}Dmyname2\PYG{o}{=}mydefinition
\end{sphinxVerbatim}

\sphinxAtStartPar
To link to an additional library say \sphinxcode{\sphinxupquote{foo}} with headers located at
\sphinxcode{\sphinxupquote{foopath/include}} and library at \sphinxcode{\sphinxupquote{foopath/lib}}, you can add the
following to your make file before the line that includes AMReX’s
\sphinxcode{\sphinxupquote{Make.defs}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{INCLUDE\PYGZus{}LOCATIONS} \PYG{o}{+=} foopath/include
\PYG{n+nv}{LIBRARY\PYGZus{}LOCATIONS} \PYG{o}{+=} foopath/lib
\PYG{n+nv}{LIBRARIES} \PYG{o}{+=} \PYGZhy{}lfoo
\end{sphinxVerbatim}


\subsection{Specifying your own compiler}
\label{\detokenize{BuildingAMReX:specifying-your-own-compiler}}\label{\detokenize{BuildingAMReX:sec-build-local}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/Make.local}} file can also specify your own compile
commands by setting the variables \sphinxcode{\sphinxupquote{CXX}}, \sphinxcode{\sphinxupquote{CC}}, \sphinxcode{\sphinxupquote{FC}}, and \sphinxcode{\sphinxupquote{F90}}. This
might be necessary if your systems contains non\sphinxhyphen{}standard names for compiler
commands.

\sphinxAtStartPar
For example, the following \sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/Make.local}} builds AMReX
using a specific compiler (in this case \sphinxcode{\sphinxupquote{gcc\sphinxhyphen{}8}}) without MPI. Whenever
\sphinxcode{\sphinxupquote{USE\_MPI}}  is true, this configuration defaults to the appropriate
\sphinxcode{\sphinxupquote{mpixxx}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ifeq \PYG{o}{(}\PYG{k}{\PYGZdl{}(}USE\PYGZus{}MPI\PYG{k}{)},TRUE\PYG{o}{)}
  \PYG{n+nv}{CXX} \PYG{o}{=} mpicxx
  \PYG{n+nv}{CC}  \PYG{o}{=} mpicc
  \PYG{n+nv}{FC}  \PYG{o}{=} mpif90
  \PYG{n+nv}{F90} \PYG{o}{=} mpif90
\PYG{k}{else}
  \PYG{n+nv}{CXX} \PYG{o}{=} g++\PYGZhy{}8
  \PYG{n+nv}{CC}  \PYG{o}{=} gcc\PYGZhy{}8
  \PYG{n+nv}{FC}  \PYG{o}{=} gfortran\PYGZhy{}8
  \PYG{n+nv}{F90} \PYG{o}{=} gfortran\PYGZhy{}8
endif
\end{sphinxVerbatim}

\sphinxAtStartPar
For building with MPI, we assume \sphinxcode{\sphinxupquote{mpicxx}}, \sphinxcode{\sphinxupquote{mpif90}}, etc. provide access to
the correct underlying compilers.


\subsection{GCC on macOS}
\label{\detokenize{BuildingAMReX:gcc-on-macos}}\label{\detokenize{BuildingAMReX:sec-build-macos}}
\sphinxAtStartPar
The example configuration above should also run on the latest macOS. On macOS
the default cxx compiler is clang, whereas the default Fortran compiler is
gfortran. Sometimes it is good to avoid mixing compilers, in that case we can
use the \sphinxcode{\sphinxupquote{Make.local}} to force using GCC. However, macOS’ Xcode ships with its
own (woefully outdated) version of GCC (4.2.1). It is therefore recommended to
install GCC using the \sphinxhref{https://brew.sh}{homebrew} package manager. Running
\sphinxcode{\sphinxupquote{brew install gcc}} installs gcc with names reflecting the version number. If
GCC 8.2 is installed, homebrew installs it as \sphinxcode{\sphinxupquote{gcc\sphinxhyphen{}8}}. AMReX can be built
using \sphinxcode{\sphinxupquote{gcc\sphinxhyphen{}8}} (with and without MPI) by using the following
\sphinxcode{\sphinxupquote{amrex/Tools/GNUMake/Make.local}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{CXX} \PYG{o}{=} g++\PYGZhy{}8
\PYG{n+nv}{CC}  \PYG{o}{=} gcc\PYGZhy{}8
\PYG{n+nv}{FC}  \PYG{o}{=} gfortran\PYGZhy{}8
\PYG{n+nv}{F90} \PYG{o}{=} gfortran\PYGZhy{}8

\PYG{n+nv}{INCLUDE\PYGZus{}LOCATIONS} \PYG{o}{+=} /usr/local/include
\end{sphinxVerbatim}

\sphinxAtStartPar
The additional \sphinxcode{\sphinxupquote{INCLUDE\_LOCATIONS}} are installed using homebrew also. Note
that if you are building AMReX using homebrew’s gcc, it is recommended that you
use homebrew’s mpich. Normally it is fine to simply install its binaries:
\sphinxcode{\sphinxupquote{brew install mpich}}. But if you are experiencing problems, we suggest
building mpich using homebrew’s gcc: \sphinxcode{\sphinxupquote{brew install mpich \sphinxhyphen{}\sphinxhyphen{}cc=gcc\sphinxhyphen{}8}}.


\subsection{Fortran}
\label{\detokenize{BuildingAMReX:fortran}}
\sphinxAtStartPar
If your code does not use Fortran, you can add \sphinxcode{\sphinxupquote{BL\_NO\_FORT=TRUE}} to
your makefile to disable Fortran.


\subsection{ccache}
\label{\detokenize{BuildingAMReX:ccache}}
\sphinxAtStartPar
If you use ccache, you can add \sphinxcode{\sphinxupquote{USE\_CCACHE=TRUE}} to your makefile.


\section{Building libamrex}
\label{\detokenize{BuildingAMReX:building-libamrex}}\label{\detokenize{BuildingAMReX:sec-build-lib}}
\sphinxAtStartPar
If an application code already has its own elaborated build system and wants to
use AMReX, an external AMReX library can be created instead. In this approach, one
runs \sphinxcode{\sphinxupquote{./configure}}, followed by \sphinxcode{\sphinxupquote{make}} and \sphinxcode{\sphinxupquote{make install}}.
Other make options include \sphinxcode{\sphinxupquote{make distclean}} and \sphinxcode{\sphinxupquote{make uninstall}}.  In the top
AMReX directory, one can run \sphinxcode{\sphinxupquote{./configure \sphinxhyphen{}h}} to show the various options for
the configure script. In particular, one can specify the installation path for the AMReX library using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
./configure \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}\PYG{o}{[}AMReX library path\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This approach is built on the AMReX GNU Make system. Thus
the section on {\hyperref[\detokenize{BuildingAMReX:sec-build-make}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with GNU Make}}}} is recommended if any fine tuning is
needed.  The result of \sphinxcode{\sphinxupquote{./configure}} is \sphinxcode{\sphinxupquote{GNUmakefile}} in the AMReX
top directory.  One can modify the make file for fine tuning.

\sphinxAtStartPar
To compile an application code against the external AMReX library, it
is necessary to set appropriate compiler flags and set the library
paths for linking. To assist with this, when the AMReX library is
built, a configuration file is created in \sphinxcode{\sphinxupquote{{[}AMReX library path{]}/lib/pkgconfig/amrex.pc}}.
This file contains the Fortran and
C++ flags used to compile the AMReX library as well as the appropriate
library and include entries.

\sphinxAtStartPar
The following sample GNU Makefile will compile a \sphinxcode{\sphinxupquote{main.cpp}} source
file against an external AMReX library, using the C++ flags and
library paths used to build AMReX:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
AMREX\PYGZus{}LIBRARY\PYGZus{}HOME ?\PYG{o}{=} \PYG{o}{[}AMReX library path\PYG{o}{]}

LIBDIR :\PYG{o}{=} \PYG{k}{\PYGZdl{}(}AMREX\PYGZus{}LIBRARY\PYGZus{}HOME\PYG{k}{)}/lib
INCDIR :\PYG{o}{=} \PYG{k}{\PYGZdl{}(}AMREX\PYGZus{}LIBRARY\PYGZus{}HOME\PYG{k}{)}/include

COMPILE\PYGZus{}CPP\PYGZus{}FLAGS ?\PYG{o}{=} \PYG{k}{\PYGZdl{}(}shell awk \PYG{l+s+s1}{\PYGZsq{}/Cflags:/ \PYGZob{}\PYGZdl{}\PYGZdl{}1=\PYGZdl{}\PYGZdl{}2=\PYGZdq{}\PYGZdq{}; print \PYGZdl{}\PYGZdl{}0\PYGZcb{}\PYGZsq{}} \PYG{k}{\PYGZdl{}(}LIBDIR\PYG{k}{)}/pkgconfig/amrex.pc\PYG{k}{)}
COMPILE\PYGZus{}LIB\PYGZus{}FLAGS ?\PYG{o}{=} \PYG{k}{\PYGZdl{}(}shell awk \PYG{l+s+s1}{\PYGZsq{}/Libs:/ \PYGZob{}\PYGZdl{}\PYGZdl{}1=\PYGZdl{}\PYGZdl{}2=\PYGZdq{}\PYGZdq{}; print \PYGZdl{}\PYGZdl{}0\PYGZcb{}\PYGZsq{}} \PYG{k}{\PYGZdl{}(}LIBDIR\PYG{k}{)}/pkgconfig/amrex.pc\PYG{k}{)}

CFLAGS :\PYG{o}{=} \PYGZhy{}I\PYG{k}{\PYGZdl{}(}INCDIR\PYG{k}{)} \PYG{k}{\PYGZdl{}(}COMPILE\PYGZus{}CPP\PYGZus{}FLAGS\PYG{k}{)}
LFLAGS :\PYG{o}{=} \PYGZhy{}L\PYG{k}{\PYGZdl{}(}LIBDIR\PYG{k}{)} \PYG{k}{\PYGZdl{}(}COMPILE\PYGZus{}LIB\PYGZus{}FLAGS\PYG{k}{)}

all:
        g++ \PYGZhy{}o main.exe main.cpp \PYG{k}{\PYGZdl{}(}CFLAGS\PYG{k}{)} \PYG{k}{\PYGZdl{}(}LFLAGS\PYG{k}{)}
\end{sphinxVerbatim}


\section{Building with CMake}
\label{\detokenize{BuildingAMReX:building-with-cmake}}\label{\detokenize{BuildingAMReX:sec-build-cmake}}
\sphinxAtStartPar
An alternative to the approach described in the section on {\hyperref[\detokenize{BuildingAMReX:sec-build-lib}]{\sphinxcrossref{\DUrole{std,std-ref}{Building libamrex}}}}
is to install AMReX as an external library by using the CMake build system.  A
CMake build is a two\sphinxhyphen{}step process. First \sphinxcode{\sphinxupquote{cmake}} is invoked to create
configuration files and makefiles in a chosen directory (\sphinxcode{\sphinxupquote{builddir}}).  This
is roughly equivalent to running \sphinxcode{\sphinxupquote{./configure}} (see the section on
{\hyperref[\detokenize{BuildingAMReX:sec-build-lib}]{\sphinxcrossref{\DUrole{std,std-ref}{Building libamrex}}}}). Next, the actual build and installation are performed by
invoking \sphinxcode{\sphinxupquote{make install}} from within \sphinxcode{\sphinxupquote{builddir}}. This installs the library files
in a chosen installation directory (\sphinxcode{\sphinxupquote{installdir}}).  If no installation path
is provided by the user, AMReX will be installed in \sphinxcode{\sphinxupquote{/path/to/amrex/installdir}}.
The CMake build process is summarized as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{mkdir /path/to/builddir}
\PYG{g+go}{cd    /path/to/builddir}
\PYG{g+go}{cmake [options] \PYGZhy{}DCMAKE\PYGZus{}BUILD\PYGZus{}TYPE=[Debug|Release|RelWithDebInfo|MinSizeRel] \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX=/path/to/installdir  /path/to/amrex}
\PYG{g+go}{make  install}
\PYG{g+go}{make  test\PYGZus{}install  \PYGZsh{} optional step to test if the installation is working}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above snippet, \sphinxcode{\sphinxupquote{{[}options{]}}} indicates one or more options for the
customization of the build, as described in the subsection on
{\hyperref[\detokenize{BuildingAMReX:sec-build-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Customization options}}}}. If the option \sphinxcode{\sphinxupquote{CMAKE\_BUILD\_TYPE}} is omitted,
\sphinxcode{\sphinxupquote{CMAKE\_BUILD\_TYPE=Release}} is assumed. Although the AMReX source could be used as
build directory, we advise against doing so.  After the installation is
complete, \sphinxcode{\sphinxupquote{builddir}} can be removed.


\subsection{Customization options}
\label{\detokenize{BuildingAMReX:customization-options}}\label{\detokenize{BuildingAMReX:sec-build-cmake-options}}
\sphinxAtStartPar
AMReX build can be customized  by setting the value of suitable configuration variables
on the command line via the \sphinxcode{\sphinxupquote{\sphinxhyphen{}D \textless{}var\textgreater{}=\textless{}value\textgreater{}}} syntax, where \sphinxcode{\sphinxupquote{\textless{}var\textgreater{}}} is the
variable to set and \sphinxcode{\sphinxupquote{\textless{}value\textgreater{}}} its desired value.
For example, one can enable OpenMP support as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cmake \PYGZhy{}DAMReX\PYGZus{}OMP=YES \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX=/path/to/installdir  /path/to/amrex}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example above \sphinxcode{\sphinxupquote{\textless{}var\textgreater{}=AMReX\_OMP}} and \sphinxcode{\sphinxupquote{\textless{}value\textgreater{}=YES}}.
Configuration variables requiring a boolean value are evaluated to true if they
are assigned a value of \sphinxcode{\sphinxupquote{1}}, \sphinxcode{\sphinxupquote{ON}}, \sphinxcode{\sphinxupquote{YES}}, \sphinxcode{\sphinxupquote{TRUE}}, \sphinxcode{\sphinxupquote{Y}}. Conversely they are evaluated to false
if they are assigned a value of \sphinxcode{\sphinxupquote{0}}, \sphinxcode{\sphinxupquote{OFF}}, \sphinxcode{\sphinxupquote{NO}}, \sphinxcode{\sphinxupquote{FALSE}}, \sphinxcode{\sphinxupquote{N}}.
Boolean configuration variables are case\sphinxhyphen{}insensitive.
The list of available options is reported in the {\hyperref[\detokenize{BuildingAMReX:tab-cmakevar}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} below.

\begin{center}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|l|l|l|l|}
\sphinxthelongtablecaptionisattop
\caption{AMReX build options (refer to section Building GPU Support for GPU\sphinxhyphen{}related options).\strut}\label{\detokenize{BuildingAMReX:id2}}\label{\detokenize{BuildingAMReX:tab-cmakevar}}\\*[\sphinxlongtablecapskipadjust]
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Possible values
\\
\hline
\endfirsthead

\multicolumn{4}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Possible values
\\
\hline
\endhead

\hline
\multicolumn{4}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
CMAKE\_Fortran\_COMPILER
&
\sphinxAtStartPar
User\sphinxhyphen{}defined Fortran compiler
&&
\sphinxAtStartPar
user\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
CMAKE\_CXX\_COMPILER
&
\sphinxAtStartPar
User\sphinxhyphen{}defined C++ compiler
&&
\sphinxAtStartPar
user\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
CMAKE\_Fortran\_FLAGS
&
\sphinxAtStartPar
User\sphinxhyphen{}defined Fortran flags
&&
\sphinxAtStartPar
user\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
CMAKE\_CXX\_FLAGS
&
\sphinxAtStartPar
User\sphinxhyphen{}defined C++ flags
&&
\sphinxAtStartPar
user\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
CMAKE\_CXX\_STANDARD
&
\sphinxAtStartPar
C++ standard
&
\sphinxAtStartPar
compiler/14
&
\sphinxAtStartPar
14, 17, 20
\\
\hline
\sphinxAtStartPar
AMReX\_SPACEDIM
&
\sphinxAtStartPar
Dimension of AMReX build
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
1, 2, 3
\\
\hline
\sphinxAtStartPar
USE\_XSDK\_DEFAULTS
&
\sphinxAtStartPar
Use XSDK defaults settings
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_FORTRAN
&
\sphinxAtStartPar
Enable Fortran language
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PRECISION
&
\sphinxAtStartPar
Set the precision of reals
&
\sphinxAtStartPar
DOUBLE
&
\sphinxAtStartPar
DOUBLE, SINGLE
\\
\hline
\sphinxAtStartPar
AMReX\_PIC
&
\sphinxAtStartPar
Build Position Independent Code
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_IPO
&
\sphinxAtStartPar
Interprocedural optimization (IPO/LTO)
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_MPI
&
\sphinxAtStartPar
Build with MPI support
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_OMP
&
\sphinxAtStartPar
Build with OpenMP support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_GPU\_BACKEND
&
\sphinxAtStartPar
Build with on\sphinxhyphen{}node, accelerated GPU backend
&
\sphinxAtStartPar
NONE
&
\sphinxAtStartPar
NONE, SYCL, HIP, CUDA
\\
\hline
\sphinxAtStartPar
AMReX\_GPU\_RDC
&
\sphinxAtStartPar
Build with Relocatable Device Code support
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_FORTRAN\_INTERFACES
&
\sphinxAtStartPar
Build Fortran API
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_LINEAR\_SOLVERS
&
\sphinxAtStartPar
Build AMReX linear solvers
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_AMRDATA
&
\sphinxAtStartPar
Build data services
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_AMRLEVEL
&
\sphinxAtStartPar
Build AmrLevel class
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_EB
&
\sphinxAtStartPar
Build Embedded Boundary support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PARTICLES
&
\sphinxAtStartPar
Build particle classes
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PARTICLES\_PRECISION
&
\sphinxAtStartPar
Set reals precision in particle classes
&
\sphinxAtStartPar
Same as AMReX\_PRECISION
&
\sphinxAtStartPar
DOUBLE, SINGLE
\\
\hline
\sphinxAtStartPar
AMReX\_BASE\_PROFILE
&
\sphinxAtStartPar
Build with basic profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_TINY\_PROFILE
&
\sphinxAtStartPar
Build with tiny profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_TRACE\_PROFILE
&
\sphinxAtStartPar
Build with trace\sphinxhyphen{}profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_COMM\_PROFILE
&
\sphinxAtStartPar
Build with comm\sphinxhyphen{}profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_MEM\_PROFILE
&
\sphinxAtStartPar
Build with memory\sphinxhyphen{}profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_TESTING
&
\sphinxAtStartPar
Build for testing (CI)
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_MPI\_THREAD\_MULTIPLE
&
\sphinxAtStartPar
Concurrent MPI calls from multiple threads
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PROFPARSER
&
\sphinxAtStartPar
Build with profile parser support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_ROCTX
&
\sphinxAtStartPar
Build with roctx markup profiling support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_FPE
&
\sphinxAtStartPar
Build with Floating Point Exceptions checks
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_ASSERTIONS
&
\sphinxAtStartPar
Build with assertions turned on
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_BOUND\_CHECK
&
\sphinxAtStartPar
Enable bound checking in Array4 class
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_SENSEI
&
\sphinxAtStartPar
Enable the SENSEI in situ infrastucture
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_NO\_SENSEI\_AMR\_INST
&
\sphinxAtStartPar
Disables the instrumentation in amrex::Amr
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CONDUIT
&
\sphinxAtStartPar
Enable Conduit support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_ASCENT
&
\sphinxAtStartPar
Enable Ascent support
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_HYPRE
&
\sphinxAtStartPar
Enable HYPRE interfaces
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PETSC
&
\sphinxAtStartPar
Enable PETSc interfaces
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_SUNDIALS
&
\sphinxAtStartPar
Enable SUNDIALS interfaces
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_HDF5
&
\sphinxAtStartPar
Enable HDF5\sphinxhyphen{}based I/O
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PLOTFILE\_TOOLS
&
\sphinxAtStartPar
Build and install plotfile postprocessing tools
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_ENABLE\_TESTS
&
\sphinxAtStartPar
Enable CTest suite
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_DIFFERENT\_COMPILER
&
\sphinxAtStartPar
Allow an app to use a different compiler
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_INSTALL
&
\sphinxAtStartPar
Generate Install Targets
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_PROBINIT
&
\sphinxAtStartPar
Enable support for probin file
&
\sphinxAtStartPar
Platform dependent
&
\sphinxAtStartPar
YES, NO
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{center}

\sphinxAtStartPar
The option \sphinxcode{\sphinxupquote{CMAKE\_BUILD\_TYPE=Debug}} implies \sphinxcode{\sphinxupquote{AMReX\_ASSERTIONS=YES}}. In order to turn off
assertions in debug mode, \sphinxcode{\sphinxupquote{AMReX\_ASSERTIONS=NO}} must be set explicitly while
invoking CMake.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{CMAKE\_C\_COMPILER}}, \sphinxcode{\sphinxupquote{CMAKE\_CXX\_COMPILER}}, and  \sphinxcode{\sphinxupquote{CMAKE\_Fortran\_COMPILER}} options
are used to tell CMake which compiler to use for the compilation of C, C++, and Fortran sources
respectively. If those options are not set by the user, CMake will use the system default compilers.

\sphinxAtStartPar
The options \sphinxcode{\sphinxupquote{CMAKE\_Fortran\_FLAGS}} and \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}} allow the user to
set his own compilation flags for Fortran and C++ source files respectively.
If \sphinxcode{\sphinxupquote{CMAKE\_Fortran\_FLAGS}}/ \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}} are not set by the user,
they will be initialized with the value of the environmental variables \sphinxcode{\sphinxupquote{FFLAGS}}/
\sphinxcode{\sphinxupquote{CXXFLAGS}}. If neither \sphinxcode{\sphinxupquote{FFLAGS}}/ \sphinxcode{\sphinxupquote{CXXFLAGS}} nor \sphinxcode{\sphinxupquote{CMAKE\_Fortran\_FLAGS}}/ \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}}
are defined, AMReX default flags are used.

\sphinxAtStartPar
For a detailed explanation of GPU support in AMReX CMake, refer to section {\hyperref[\detokenize{GPU:sec-gpu-build}]{\sphinxcrossref{\DUrole{std,std-ref}{Building GPU Support}}}}.


\subsection{CMake and macOS}
\label{\detokenize{BuildingAMReX:cmake-and-macos}}
\sphinxAtStartPar
While not strictly necessary when using homebrew on macOS, it is highly
recommended that the user specifies \sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_C\_COMPILER=\$(which gcc\sphinxhyphen{}X) \sphinxhyphen{}DCMAKE\_CXX\_COMPILER=\$(which
g++\sphinxhyphen{}X)}} (where X is the GCC version installed by homebrew) when using
gfortran. This is because homebrew’s CMake defaults to the Clang C/C++
compiler. Normally Clang plays well with gfortran, but if there are some issues,
we recommend telling CMake to use gcc for C/C++ also.


\subsection{Importing AMReX into your CMake project}
\label{\detokenize{BuildingAMReX:importing-amrex-into-your-cmake-project}}\label{\detokenize{BuildingAMReX:sec-build-cmake-config}}
\sphinxAtStartPar
In order to import AMReX into your CMake project, you need
to include the following line in the appropriate CMakeLists.txt file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{AMReX}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Calls to \sphinxcode{\sphinxupquote{find\_package(AMReX)}} will find a valid installation of AMReX, if present,
and import its settings and targets into your CMake project.
Imported AMReX targets can be linked to any of your targets, after they have been made available
following a successful call to \sphinxcode{\sphinxupquote{find\_package(AMReX)}}, by including
the following line in the appropriate CMakeLists.txt file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(} \PYG{l+s}{\PYGZlt{}your\PYGZhy{}target\PYGZhy{}name\PYGZgt{}}  \PYG{l+s}{AMReX::\PYGZlt{}amrex\PYGZhy{}target\PYGZhy{}name\PYGZgt{}} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above snippet, \sphinxcode{\sphinxupquote{\textless{}amrex\sphinxhyphen{}target\sphinxhyphen{}name\textgreater{}}} is any of the targets listed in the table below.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AMReX targets available for import.}\label{\detokenize{BuildingAMReX:id3}}\label{\detokenize{BuildingAMReX:tab-cmaketargets}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Target name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
amrex
&
\sphinxAtStartPar
AMReX library
\\
\hline
\sphinxAtStartPar
Flags\_CXX
&
\sphinxAtStartPar
C++ flags preset (interface)
\\
\hline
\sphinxAtStartPar
Flags\_Fortran
&
\sphinxAtStartPar
Fortran flags preset (interface)
\\
\hline
\sphinxAtStartPar
Flags\_FPE
&
\sphinxAtStartPar
Floating Point Exception flags (interface)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
The options used to configure the AMReX build may result in certain parts, or \sphinxcode{\sphinxupquote{components}}, of the AMReX source code
to be excluded from compilation. For example, setting \sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_LINEAR\_SOLVERS=no}} at configure time
prevents the compilation of AMReX linear solvers code.
Your CMake project can check which component is included in the AMReX library via \sphinxtitleref{find\_package}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{AMReX} \PYG{l+s}{REQUIRED} \PYG{l+s}{\PYGZlt{}components\PYGZhy{}list\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{REQUIRED}} in the snippet above will cause a fatal error if AMReX is not found, or
if it is found but the components listed in \sphinxcode{\sphinxupquote{\textless{}components\sphinxhyphen{}list\textgreater{}}} are not include in the installation.
A list of AMReX component names and related configure options are shown in the table below.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AMReX components.}\label{\detokenize{BuildingAMReX:id4}}\label{\detokenize{BuildingAMReX:tab-cmakecomponents}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Option
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Component
\\
\hline
\sphinxAtStartPar
AMReX\_SPACEDIM
&
\sphinxAtStartPar
1D, 2D, 3D
\\
\hline
\sphinxAtStartPar
AMReX\_PRECISION
&
\sphinxAtStartPar
DOUBLE, SINGLE
\\
\hline
\sphinxAtStartPar
AMReX\_FORTRAN
&
\sphinxAtStartPar
FORTRAN
\\
\hline
\sphinxAtStartPar
AMReX\_PIC
&
\sphinxAtStartPar
PIC
\\
\hline
\sphinxAtStartPar
AMReX\_MPI
&
\sphinxAtStartPar
MPI
\\
\hline
\sphinxAtStartPar
AMReX\_OMP
&
\sphinxAtStartPar
OMP
\\
\hline
\sphinxAtStartPar
AMReX\_GPU\_BACKEND
&
\sphinxAtStartPar
CUDA, HIP, SYCL
\\
\hline
\sphinxAtStartPar
AMReX\_FORTRAN\_INTERFACES
&
\sphinxAtStartPar
FINTERFACES
\\
\hline
\sphinxAtStartPar
AMReX\_LINEAR\_SOLVERS
&
\sphinxAtStartPar
LSOLVERS
\\
\hline
\sphinxAtStartPar
AMReX\_AMRDATA
&
\sphinxAtStartPar
AMRDATA
\\
\hline
\sphinxAtStartPar
AMReX\_AMRLEVEL
&
\sphinxAtStartPar
AMRLEVEL
\\
\hline
\sphinxAtStartPar
AMReX\_EB
&
\sphinxAtStartPar
EB
\\
\hline
\sphinxAtStartPar
AMReX\_PARTICLES
&
\sphinxAtStartPar
PARTICLES
\\
\hline
\sphinxAtStartPar
AMReX\_PARTICLES\_PRECISION
&
\sphinxAtStartPar
PDOUBLE, PSINGLE
\\
\hline
\sphinxAtStartPar
AMReX\_BASE\_PROFILE
&
\sphinxAtStartPar
BASEP
\\
\hline
\sphinxAtStartPar
AMReX\_TINY\_PROFILE
&
\sphinxAtStartPar
TINYP
\\
\hline
\sphinxAtStartPar
AMReX\_TRACE\_PROFILE
&
\sphinxAtStartPar
TRACEP
\\
\hline
\sphinxAtStartPar
AMReX\_COMM\_PROFILE
&
\sphinxAtStartPar
COMMP
\\
\hline
\sphinxAtStartPar
AMReX\_MEM\_PROFILE
&
\sphinxAtStartPar
MEMP
\\
\hline
\sphinxAtStartPar
AMReX\_PROFPARSER
&
\sphinxAtStartPar
PROFPARSER
\\
\hline
\sphinxAtStartPar
AMReX\_FPE
&
\sphinxAtStartPar
FPE
\\
\hline
\sphinxAtStartPar
AMReX\_ASSERTIONS
&
\sphinxAtStartPar
ASSERTIONS
\\
\hline
\sphinxAtStartPar
AMReX\_SENSEI
&
\sphinxAtStartPar
SENSEI
\\
\hline
\sphinxAtStartPar
AMReX\_CONDUIT
&
\sphinxAtStartPar
CONDUIT
\\
\hline
\sphinxAtStartPar
AMReX\_ASCENT
&
\sphinxAtStartPar
ASCENT
\\
\hline
\sphinxAtStartPar
AMReX\_HYPRE
&
\sphinxAtStartPar
HYPRE
\\
\hline
\sphinxAtStartPar
AMReX\_PLOTFILE\_TOOLS
&
\sphinxAtStartPar
PFTOOLS
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
As an example, consider the following CMake code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{find\PYGZus{}package}\PYG{p}{(}\PYG{l+s}{AMReX} \PYG{l+s}{REQUIRED} \PYG{l+s}{3D} \PYG{l+s}{EB}\PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(} \PYG{l+s}{Foo}  \PYG{l+s}{AMReX::amrex} \PYG{l+s}{AMReX::Flags\PYGZus{}CXX} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The code in the snippet above checks wheather an AMReX installation with 3D and Embedded Boundary support
is available on the system. If so, AMReX is linked to target \sphinxcode{\sphinxupquote{Foo}} and AMReX flags preset is used
to compile \sphinxcode{\sphinxupquote{Foo}}’s C++ sources. If no AMReX installation is found or if the available one was built without
3D or Embedded Boundary support, a fatal error is issued.

\sphinxAtStartPar
You can tell CMake to look for the AMReX library in non\sphinxhyphen{}standard paths by setting the environmental variable
\sphinxcode{\sphinxupquote{AMReX\_ROOT}} to point to the AMReX installation directory or by adding
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_ROOT=\textless{}path/to/amrex/installation/directory\textgreater{}}} to the \sphinxcode{\sphinxupquote{cmake}} invocation.
More details on \sphinxcode{\sphinxupquote{find\_package}} can be found
\sphinxhref{https://cmake.org/cmake/help/v3.14/command/find\_package.html}{here}.


\section{AMReX on Windows}
\label{\detokenize{BuildingAMReX:amrex-on-windows}}\label{\detokenize{BuildingAMReX:sec-build-windows}}
\sphinxAtStartPar
The AMReX team does development on Linux machines, from laptops to supercomputers. Many people also use AMReX on Macs without issues.

\sphinxAtStartPar
We do not officially support AMReX on Windows, and many of us do not have access to any Windows
machines.  However, we believe there are no fundamental issues for it to work on Windows.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
\sphinxAtStartPar
AMReX mostly uses standard C++14, but for Windows C++17 is required.  This is because we use
C++17 to support file system operations when POSIX I/O is not available.

\end{enumerate}

\sphinxAtStartPar
(2) We use POSIX signal handling when floating point exceptions, segmentation faults, etc. happen.
This capability is not supported on Windows.

\sphinxAtStartPar
(3) Memory profiling is an optional feature in AMReX that is not enabled by default.  It reads
memory system information from the OS to give us a summary of our memory usage.  This is not
supported on Windows.


\chapter{Basics}
\label{\detokenize{Basics_Chapter:basics}}\label{\detokenize{Basics_Chapter:chap-basics}}\label{\detokenize{Basics_Chapter::doc}}
\sphinxAtStartPar
In this chapter, we present the basics of AMReX. The implementation source
codes are in \sphinxcode{\sphinxupquote{amrex/Src/Base/}}. Note that AMReX classes and functions are in
namespace \sphinxcode{\sphinxupquote{amrex}}. For clarity, we usually drop \sphinxcode{\sphinxupquote{amrex::}} in the example
codes here. It is also assumed that headers have been properly included. We
recommend you study the tutorial in
\sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HeatEquation\_EX1\_C}} while reading this chapter.  After
reading this chapter, one should be able to develop single\sphinxhyphen{}level parallel codes
using AMReX. It should also be noted that this is not a comprehensive reference
manual.


\section{Dimensionality}
\label{\detokenize{Basics:dimensionality}}\label{\detokenize{Basics:sec-basics-dim}}\label{\detokenize{Basics::doc}}
\sphinxAtStartPar
As we have mentioned in {\hyperref[\detokenize{BuildingAMReX_Chapter:chap-buildingamrex}]{\sphinxcrossref{\DUrole{std,std-ref}{Building AMReX}}}}, the dimensionality of
AMReX must be set at compile time. A macro, \sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}}, is defined to
be the number of spatial dimensions. C++ codes can also use the
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{SpaceDim}}} variable. Fortran codes can use either the macro and
preprocessing or do

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}spacedim}
\end{sphinxVerbatim}

\sphinxAtStartPar
The coordinate directions are zero based.


\section{Vector, Array, GpuArray, Array1D, Array2D, and Array3D}
\label{\detokenize{Basics:vector-array-gpuarray-array1d-array2d-and-array3d}}\label{\detokenize{Basics:sec-basics-vecandarr}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Vector}}} class in \sphinxcode{\sphinxupquote{AMReX\_Vector.H}} is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{vector}}}. The
main difference between \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{vector}}} is that
\sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{::}\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}} provides bound checking when compiled with
\sphinxcode{\sphinxupquote{\DUrole{name}{DEBUG}\DUrole{operator}{=}\DUrole{name}{TRUE}}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Array}}} class in \sphinxcode{\sphinxupquote{AMReX\_Array.H}} is simply an alias to \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{array}}}.
It is used throughout AMReX, however its functions are not defined
for device code. \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}} is AMReX’s built\sphinxhyphen{}in alternative.  It
is a trivial type that works on both host and device.  It also works
when compiled just for CPU.  Besides \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}}, AMReX also
provides GPU safe \sphinxcode{\sphinxupquote{\DUrole{name}{Array1D}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{Array2D}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{Array3D}}} that are
1, 2 and 3\sphinxhyphen{}dimensional fixed size arrays, respectively.  These three
class templates can have non\sphinxhyphen{}zero based indexing.


\section{Real}
\label{\detokenize{Basics:real}}
\sphinxAtStartPar
AMReX can be compiled to use either double precision (which is the default) or
single precision. \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Real}}} is typedef’d to either \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{double}}} or
\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{float}}}. C codes can use \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_real}}}. They are defined in
\sphinxcode{\sphinxupquote{\DUrole{name}{AMReX\_REAL}\DUrole{punctuation}{.}\DUrole{name}{H}}}. The data type is accessible in Fortran codes via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
\end{sphinxVerbatim}

\sphinxAtStartPar
In C++, AMReX also provides a user literal \sphinxcode{\sphinxupquote{\DUrole{name}{\_rt}}} so that one can
have a proper type for constants (e.g., \sphinxcode{\sphinxupquote{\DUrole{literal,number,float}{2.7}\DUrole{name}{\_rt}}}).


\section{Long}
\label{\detokenize{Basics:long}}
\sphinxAtStartPar
AMReX defines a 64 bit integer type \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Long}}} that is an alias to
\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{long}}} on Unix\sphinxhyphen{}like systems and \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{long} \DUrole{keyword,type}{long}}} on Windows.  In
C, the type alias is \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_long}}}.  In Fortran, one can use
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_long}}} defined in \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_fort\_module}}}.


\section{ParallelDescriptor}
\label{\detokenize{Basics:paralleldescriptor}}\label{\detokenize{Basics:sec-basics-paralleldescriptor}}
\sphinxAtStartPar
AMReX users do not need to use MPI directly. Parallel communication is often
handled by the data abstraction classes (e.g.,MultiFab; section on
{\hyperref[\detokenize{Basics:sec-basics-multifab}]{\sphinxcrossref{\DUrole{std,std-ref}{FabArray, MultiFab and iMultiFab}}}}). In addition, AMReX has provided namespace
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelDescriptor}}} in \sphinxcode{\sphinxupquote{AMReX\_ParallelDescriptor.H.}} The frequently
used functions are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{myproc} \PYG{o}{=} \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Return the rank}

\PYG{k+kt}{int} \PYG{n}{nprocs} \PYG{o}{=} \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NProcs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Return the number of processes}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Only the I/O process executes this}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n}{ioproc} \PYG{o}{=} \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessorNumber}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// I/O rank}

\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Barrier}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Broadcast 100 ints from the I/O Processor}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Bcast}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessorNumber}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{// See AMReX\PYGZus{}ParallelDescriptor.H for many other Reduce functions}
\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ReduceRealSum}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Additionally, \sphinxcode{\sphinxupquote{amrex\_paralleldescriptor\_module}} in
\sphinxcode{\sphinxupquote{Src/Base/AMReX\_ParallelDescriptor\_F.F90}} provides a number of
functions for Fortran.


\section{ParallelContext}
\label{\detokenize{Basics:parallelcontext}}
\sphinxAtStartPar
Users can also use groups of MPI subcommunicators to perform
simultaneous physics calculations.  These comms are managed by AMReX’s
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelContext}}} in \sphinxcode{\sphinxupquote{AMReX\_ParallelContext.H.}}  It maintains a
stack of \sphinxcode{\sphinxupquote{\DUrole{name}{MPI\_Comm}}} handlers. A global comm is placed in the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelContext}}} stack during AMReX’s initialization and
additional subcommunicators can be handled by adding comms with
\sphinxcode{\sphinxupquote{\DUrole{name}{push}\DUrole{punctuation}{(}\DUrole{name}{MPI\_Comm}\DUrole{punctuation}{)}}} and removed using \sphinxcode{\sphinxupquote{\DUrole{name}{pop}\DUrole{punctuation}{()}}}.  This creates a
hierarchy of \sphinxcode{\sphinxupquote{\DUrole{name}{MPI\_Comm}}} objects that can be used to split work as
the user sees fit.   Note that \sphinxcode{\sphinxupquote{ParallelDescriptor}} by default uses
AMReX’s base comm, independent of the status of the
\sphinxcode{\sphinxupquote{ParallelContext}} stack.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelContext}}} also tracks and returns information about the
local (most recently added) and global \sphinxcode{\sphinxupquote{\DUrole{name}{MPI\_Comm}}}.  The most common
access functions are given below.  See \sphinxcode{\sphinxupquote{AMReX\_ParallelContext.H.}} for
a full listing of the available functions.
\begin{quote}
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{subCommA} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{subCommB} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{c+c1}{// Add a communicator to ParallelContext.}
\PYG{c+c1}{// After these pushes, subCommB becomes the}
\PYG{c+c1}{//     \PYGZdq{}local\PYGZdq{} communicator.}
\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{push}\PYG{p}{(}\PYG{n}{subCommA}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{push}\PYG{p}{(}\PYG{n}{subCommB}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Get Global and Local communicator (subCommB).}
\PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{globalComm} \PYG{o}{=} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CommunicatorAll}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{localComm}  \PYG{o}{=} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CommunicatorSub}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Get local number of ranks and global IO Processor Number.}
\PYG{k+kt}{int} \PYG{n}{localRanks} \PYG{o}{=} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NProcsSub}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{globalIO}     \PYG{o}{=} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessorNumberAll}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessorSub}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Only the local I/O process executes this}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Translation of global rank to local communicator rank.}
\PYG{c+c1}{// Returns MPI\PYGZus{}UNDEFINED if comms do not overlap.}
\PYG{k+kt}{int} \PYG{n}{localRank} \PYG{o}{=} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{global\PYGZus{}to\PYGZus{}local\PYGZus{}rank}\PYG{p}{(}\PYG{n}{globalrank}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Translations of MPI rank IDs using integer arrays.}
\PYG{c+c1}{// Returns MPI\PYGZus{}UNDEFINED if comms do not overlap.}
\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{global\PYGZus{}to\PYGZus{}local\PYGZus{}rank}\PYG{p}{(}\PYG{n}{local\PYGZus{}array}\PYG{p}{,} \PYG{n}{global\PYGZus{}array}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{local\PYGZus{}to\PYGZus{}global\PYGZus{}rank}\PYG{p}{(}\PYG{n}{global\PYGZus{}array}\PYG{p}{,} \PYG{n}{local\PYGZus{}array}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Remove the last added subcommunicator.}
\PYG{c+c1}{// This would make \PYGZdq{}subCommA\PYGZdq{} the new local communicator.}
\PYG{c+c1}{// Note: The user still needs to free \PYGZdq{}subCommB\PYGZdq{}.}
\PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Print}
\label{\detokenize{Basics:print}}\label{\detokenize{Basics:sec-basics-print}}
\sphinxAtStartPar
AMReX provides classes in \sphinxcode{\sphinxupquote{AMReX\_Print.H}} for printing messages to standard
output or any C++ \sphinxcode{\sphinxupquote{\DUrole{name}{ostream}}}. The main reason one should use them instead
of \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{cout}}} is that messages from multiple processes or threads do not
get mixed up. Below are some examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{c+c1}{// Print on I/O processor}

\PYG{n}{Real} \PYG{n}{pi} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{atan}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{4.0}\PYG{p}{;}
\PYG{c+c1}{// Print on rank 3 with precision of 17 digits}
\PYG{c+c1}{// SetPrecision does not modify cout\PYGZsq{}s floating\PYGZhy{}point decimal precision setting.}
\PYG{n}{Print}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{.}\PYG{n}{SetPrecision}\PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{oldprec} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// Print with 10 digits}

\PYG{n}{AllPrint}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Every process prints}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// Print on every process}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream} \PYG{n+nf}{ofs}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{o}{:}\PYG{o}{:}\PYG{n}{out}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{n}{ofs}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Print to a file}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{n}{ofs}\PYG{p}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{AllPrintToFile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Each process appends to its own file (e.g., file.3)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be emphasized that \sphinxcode{\sphinxupquote{\DUrole{name}{Print}\DUrole{punctuation}{()}}} without any argument only
prints on the I/O process.  A common mistake in using it for debug
printing is one forgets that for non\sphinxhyphen{}I/O processes to print we should
use \sphinxcode{\sphinxupquote{\DUrole{name}{AllPrint}\DUrole{punctuation}{()}}} or \sphinxcode{\sphinxupquote{\DUrole{name}{Print}\DUrole{punctuation}{(}\DUrole{name}{rank}\DUrole{punctuation}{)}}}.


\section{ParmParse}
\label{\detokenize{Basics:parmparse}}\label{\detokenize{Basics:sec-basics-parmparse}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} in AMReX\_ParmParse.H is a class providing a database for the
storage and retrieval of command\sphinxhyphen{}line and input\sphinxhyphen{}file arguments. When
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Initialize}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{operator}{\&} \DUrole{name}{argc}\DUrole{punctuation}{,} \DUrole{keyword,type}{char}\DUrole{operator}{**\&} \DUrole{name}{argv}\DUrole{punctuation}{)}}} is called, the first command\sphinxhyphen{}line argument after the
executable name (if there is one and it does not contain character =) is taken
to be the inputs file, and the contents in the file are used to initialize the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} database. The rest of the command\sphinxhyphen{}line arguments are also
parsed by \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}}. The format of the inputs file is a series of
definitions in the form of \sphinxcode{\sphinxupquote{prefix.name = value value ....}} For each line,
text after \# are comments. Here is an example inputs file.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nsteps}    \PYG{o}{=} \PYG{l+m+mi}{100}               \PYG{c+c1}{\PYGZsh{} integer}
\PYG{n}{nsteps}    \PYG{o}{=} \PYG{l+m+mi}{1000}              \PYG{c+c1}{\PYGZsh{} nsteps appears a second time}
\PYG{n}{dt}        \PYG{o}{=} \PYG{l+m+mf}{0.03}              \PYG{c+c1}{\PYGZsh{} floating point number}
\PYG{n}{ncells}    \PYG{o}{=} \PYG{l+m+mi}{128} \PYG{l+m+mi}{64} \PYG{l+m+mi}{32}         \PYG{c+c1}{\PYGZsh{} a list of 3 ints}
\PYG{n}{xrange}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{l+m+mf}{0.5}          \PYG{c+c1}{\PYGZsh{} a list of 2 reals}
\PYG{n}{title}     \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Three Kingdoms}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} a string}
\PYG{n}{hydro}\PYG{o}{.}\PYG{n}{cfl} \PYG{o}{=} \PYG{l+m+mf}{0.8}               \PYG{c+c1}{\PYGZsh{} with prefix, hydro}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
The following code shows how to use \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} to get/query the values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{nsteps} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nsteps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nsteps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// 1000}

\PYG{n}{Real} \PYG{n}{dt}\PYG{p}{;}
\PYG{n}{pp}\PYG{p}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// runtime error if dt is not in inputs}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{numcells}\PYG{p}{;}
\PYG{c+c1}{// The variable name \PYGZsq{}numcells\PYGZsq{} can be different from parameter name \PYGZsq{}ncells\PYGZsq{}.}
\PYG{n}{pp}\PYG{p}{.}\PYG{n}{getarr}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ncells}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{numcells}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{numcells}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// 3}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{xr} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{queryarr}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xrange}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{xr}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cannot find xrange in inputs, }\PYG{l+s}{\PYGZdq{}}
                   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{so the default \PYGZob{}\PYGZhy{}1.0,1.0\PYGZcb{} will be used}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{title}\PYG{p}{;}
\PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{title}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{title}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// query string}

\PYG{n}{ParmParse} \PYG{n+nf}{pph}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hydro}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// with prefix \PYGZsq{}hydro\PYGZsq{}}
\PYG{n}{Real} \PYG{n}{cfl}\PYG{p}{;}
\PYG{n}{pph}\PYG{p}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cfl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cfl}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// get parameter with prefix}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that when there are multiple definitions for a parameter \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}}
by default returns the last one. The difference between \sphinxcode{\sphinxupquote{\DUrole{name}{query}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{get}}} should also be noted. It is a runtime error if \sphinxcode{\sphinxupquote{\DUrole{name}{get}}} fails to
get the value, whereas \sphinxcode{\sphinxupquote{\DUrole{name}{query}}} returns an error code without generating a
runtime error that will abort the run.  It is sometimes convenient to
override parameters with command\sphinxhyphen{}line arguments without modifying the inputs
file. The command\sphinxhyphen{}line arguments after the inputs file are added later than the
file to the database and are therefore used by default. For example, one can
run with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{myexecutable myinputsfile ncells=\PYGZdq{}64 32 16\PYGZdq{} hydro.cfl=0.9}
\end{sphinxVerbatim}

\sphinxAtStartPar
to change the value of \sphinxcode{\sphinxupquote{\DUrole{name}{ncells}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{hydro}\DUrole{punctuation}{.}\DUrole{name}{cfl}}}.

\sphinxAtStartPar
Sometimes an application code may want to set a default that differs from the
default in AMReX.  In this case, it is often convenient to define a function that
sets the variable(s), and pass the name of that function to \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Initialize}}}.
As an example, we may define \sphinxcode{\sphinxupquote{\DUrole{name}{add\_par}}} to set \sphinxcode{\sphinxupquote{\DUrole{name}{extend\_domain\_face}}}
to false if it hasn’t already been set in the inputs file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{add\PYGZus{}par} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eb2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{not} \PYG{n}{pp}\PYG{p}{.}\PYG{n}{contains}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{extend\PYGZus{}domain\PYGZus{}face}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{pp}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{extend\PYGZus{}domain\PYGZus{}face}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then we would pass \sphinxcode{\sphinxupquote{\DUrole{name}{add\_par}}} into \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Initialize}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Initialize}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{,} \PYG{n+nb}{true}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}COMM\PYGZus{}WORLD}\PYG{p}{,} \PYG{n}{add\PYGZus{}par}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This value replaces the current default value of true in AMReX itself, but
can still be over\sphinxhyphen{}written by setting a value in the inputs file.


\section{Parser}
\label{\detokenize{Basics:parser}}\label{\detokenize{Basics:sec-basics-parser}}
\sphinxAtStartPar
AMReX provides a parser in \sphinxcode{\sphinxupquote{AMReX\_Parser.H}} that can be used at runtime to evaluate mathematical
expressions given in the form of string.  It supports \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{*}},
\sphinxcode{\sphinxupquote{/}}, \sphinxcode{\sphinxupquote{**}} (power), \sphinxcode{\sphinxupquote{\textasciicircum{}}} (power), \sphinxcode{\sphinxupquote{sqrt}}, \sphinxcode{\sphinxupquote{exp}}, \sphinxcode{\sphinxupquote{log}}, \sphinxcode{\sphinxupquote{log10}},
\sphinxcode{\sphinxupquote{sin}}, \sphinxcode{\sphinxupquote{cos}}, \sphinxcode{\sphinxupquote{tan}}, \sphinxcode{\sphinxupquote{asin}}, \sphinxcode{\sphinxupquote{acos}}, \sphinxcode{\sphinxupquote{atan}}, \sphinxcode{\sphinxupquote{sinh}}, \sphinxcode{\sphinxupquote{cosh}},
\sphinxcode{\sphinxupquote{tanh}}, and \sphinxcode{\sphinxupquote{abs}}.  The minimum and maximum of two numbers can be
computed with \sphinxcode{\sphinxupquote{min}} and \sphinxcode{\sphinxupquote{max}}, respectively.  It supports the Heaviside
step function, \sphinxcode{\sphinxupquote{heaviside(x1,x2)}} that gives \sphinxcode{\sphinxupquote{0}}, \sphinxcode{\sphinxupquote{x2}}, \sphinxcode{\sphinxupquote{1}}, for
\sphinxcode{\sphinxupquote{x1 \textless{} 0}}, \sphinxcode{\sphinxupquote{x1 = 0}} and \sphinxcode{\sphinxupquote{x1 \textgreater{} 0}}, respectively.  There is \sphinxcode{\sphinxupquote{if(a,b,c)}}
that gives \sphinxcode{\sphinxupquote{b}} or \sphinxcode{\sphinxupquote{c}} depending on the value of \sphinxcode{\sphinxupquote{a}}.  A number of
comparison operators are supported, including \sphinxcode{\sphinxupquote{\textless{}}}, \sphinxcode{\sphinxupquote{\textgreater{}}}, \sphinxcode{\sphinxupquote{==}}, \sphinxcode{\sphinxupquote{!=}},
\sphinxcode{\sphinxupquote{\textless{}=}}, and \sphinxcode{\sphinxupquote{\textgreater{}=}}.  The Boolean results from comparison can be combined by
\sphinxcode{\sphinxupquote{and}} and \sphinxcode{\sphinxupquote{or}}, and they hold the value \sphinxcode{\sphinxupquote{1}} for true and \sphinxcode{\sphinxupquote{0}} for
false.  The precedence of the operators follows the convention of the C and
C++ programming languages.  Here is an example of using the parser.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Parser} \PYG{n+nf}{parser}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{if(x\PYGZgt{}a and x\PYGZlt{}b, sin(x)}\PYG{o}{*}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{k}{if}\PYG{p}{(}\PYG{n}{z}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{.3}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{p}{;}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{setConstant}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{setConstant}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{setConstant}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{registerVariables}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{auto} \PYG{n}{f} \PYG{o}{=} \PYG{n}{parser}\PYG{p}{.}\PYG{n}{compile}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// 3 because there are three variables.}

\PYG{c+c1}{// f can be used in both host and device code.  It takes 3 arguments in}
\PYG{c+c1}{// this example.  The parser object must be alive for f to be valid.}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{j}\PYG{o}{*}\PYG{n}{dy}\PYG{p}{,} \PYG{n}{k}\PYG{o}{*}\PYG{n}{dz}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Local automatic variables can be defined in the expression.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Parser} \PYG{n}{parser}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r2=x*x+y*y; r=sqrt(r2); cos(a+r2)*log(r)}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{setConstant}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{parser}\PYG{p}{.}\PYG{n}{registerVariables}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{auto} \PYG{n}{f} \PYG{o}{=} \PYG{n}{parser}\PYG{p}{.}\PYG{n}{compile}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// 2 because there are two variables.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that an assignment to an automatic variable must be terminated with
\sphinxcode{\sphinxupquote{;}}, and one should avoid name conflict between the local variables and
the constants set by \sphinxcode{\sphinxupquote{\DUrole{name}{setConstant}}} and the variables registered by
\sphinxcode{\sphinxupquote{\DUrole{name}{registerVariables}}}.

\sphinxAtStartPar
Besides \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Parser}}} for floating point numbers, AMReX also provides
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{IParser}}} for integers.  The two parsers have a lot of
similarity, but floating point number specific functions (e.g., \sphinxcode{\sphinxupquote{sqrt}},
\sphinxcode{\sphinxupquote{sin}}, etc.) are not supported in \sphinxcode{\sphinxupquote{IParser}}.  In addition to \sphinxcode{\sphinxupquote{/}} whose
result truncates towards zero, the integer parser also supports \sphinxcode{\sphinxupquote{//}} whose
result truncates towards negative infinity.


\section{Initialize and Finalize}
\label{\detokenize{Basics:initialize-and-finalize}}\label{\detokenize{Basics:sec-basics-initialize}}
\sphinxAtStartPar
As we have mentioned, \sphinxcode{\sphinxupquote{\DUrole{name}{Initialize}}} must be called to initialize
the execution environment for AMReX and \sphinxcode{\sphinxupquote{\DUrole{name}{Finalize}}} must be paired
with \sphinxcode{\sphinxupquote{\DUrole{name}{Initialize}}} to release the resources used by AMReX.  There
are two versions of \sphinxcode{\sphinxupquote{\DUrole{name}{Initialize}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{Initialize} \PYG{p}{(}\PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{mpi\PYGZus{}comm}\PYG{p}{,}
                 \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}osout} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{p}{,}
                 \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oserr} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cerr}\PYG{p}{,}
                 \PYG{n}{ErrorHandler} \PYG{n}{a\PYGZus{}errhandler} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{Initialize} \PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*}\PYG{o}{\PYGZam{}} \PYG{n}{argv}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{build\PYGZus{}parm\PYGZus{}parse}\PYG{o}{=}\PYG{n+nb}{true}\PYG{p}{,}
                 \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{mpi\PYGZus{}comm} \PYG{o}{=} \PYG{n}{MPI\PYGZus{}COMM\PYGZus{}WORLD}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{function}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{void}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{func\PYGZus{}parm\PYGZus{}parse} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                 \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}osout} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{p}{,}
                 \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}oserr} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cerr}\PYG{p}{,}
                 \PYG{n}{ErrorHandler} \PYG{n}{a\PYGZus{}errhandler} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Initialize}}} tests if MPI has been initialized.  If MPI has been
initialized, AMReX will duplicate the \sphinxcode{\sphinxupquote{MPI\_Comm}} argument.  If not,
AMReX will initialize MPI and ignore the \sphinxcode{\sphinxupquote{MPI\_Comm}} argument.

\sphinxAtStartPar
Both versions have two optional \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{ostream}}} parameters, one
for standard output in \sphinxcode{\sphinxupquote{\DUrole{name}{Print}}} (section {\hyperref[\detokenize{Basics:sec-basics-print}]{\sphinxcrossref{\DUrole{std,std-ref}{Print}}}})
and the other for standard error, and they can be accessed with
functions \sphinxcode{\sphinxupquote{\DUrole{name}{OutStream}\DUrole{punctuation}{()}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{ErrorStream}\DUrole{punctuation}{()}}}.  Both versions
can also take an optional error handler function.  If it is provided
by the user, AMReX will use it to handle errors and signals.
Otherwise, AMReX will use its own function for error and signal
handling.

\sphinxAtStartPar
The first version of \sphinxcode{\sphinxupquote{\DUrole{name}{Initialize}}} does not parse the command line
options, whereas the second version will build ParmParse database
(section {\hyperref[\detokenize{Basics:sec-basics-parmparse}]{\sphinxcrossref{\DUrole{std,std-ref}{ParmParse}}}}) unless \sphinxcode{\sphinxupquote{build\_parm\_parse}}
parameter is \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{false}}}.  In the second version, one can pass a
function that adds ParmParse parameters to the database instead of
reading from command line or input file.

\sphinxAtStartPar
Because many AMReX classes and functions (including destructors
inserted by the compiler) do not function properly after
\sphinxcode{\sphinxupquote{\DUrole{name,label}{amrex}\DUrole{punctuation}{:}\DUrole{name}{Finalize}}} is called, it’s best to put the codes between
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Initialize}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Finalize}}} into its scope
(e.g., a pair of curly braces or a separate function) to make sure
resources are properly freed.


\subsection{Sharing the Command Line}
\label{\detokenize{Basics:sharing-the-command-line}}
\sphinxAtStartPar
In some cases we want AMReX to only read part of the command line \textendash{} this happens, for example, when we
are going to use AMReX in cooperation with another code package and that code also takes command\sphinxhyphen{}line
arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{main2d*.exe inputs amrex.v=1 amrex.fpe\PYGZus{}trap\PYGZus{}invalid=1 \PYGZhy{}\PYGZhy{} \PYGZhy{}tao\PYGZus{}monitor}
\end{sphinxVerbatim}

\sphinxAtStartPar
then AMReX will parse the inputs file and the optional AMReX’s command
line arguments, but will ignore everything after the double dashes.


\section{Example of AMR Grids}
\label{\detokenize{Basics:example-of-amr-grids}}\label{\detokenize{Basics:sec-basics-amrgrids}}
\sphinxAtStartPar
In block\sphinxhyphen{}structured AMR, there is a hierarchy of logically rectangular grids.
The computational domain on each AMR level is decomposed into a union of
rectangular domains. \hyperref[\detokenize{Basics:fig-basics-amrgrids}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-amrgrids}}} below shows an example of
AMR with three total levels.  In the AMReX numbering convention, the coarsest
level is level 0. The coarsest grid (\sphinxstyleemphasis{black}) covers the domain with
\(16^2\) cells. Bold lines represent grid boundaries. There are two
intermediate resolution grids (\sphinxstyleemphasis{blue}) at level 1 and the cells are a factor of
two finer than those at level 0. The two finest grids (\sphinxstyleemphasis{red}) are at level 2
and the cells are a factor of two finer than the level 1 cells. There are 1, 2
and 2 Boxes on levels 0, 1, and 2, respectively. Note that there is no direct
parent\sphinxhyphen{}child connection. In this chapter, we will focus on single levels.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3in]{{amrgrids}.png}
\caption{Example of AMR grids. There are three levels in total.
There are 1, 2 and 2 Boxes on levels 0, 1, and 2, respectively.}\label{\detokenize{Basics:id1}}\label{\detokenize{Basics:fig-basics-amrgrids}}\end{figure}

\end{center}


\section{Box, IntVect and IndexType}
\label{\detokenize{Basics:box-intvect-and-indextype}}\label{\detokenize{Basics:sec-basics-box}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} in AMReX\_Box.H is the data structure for representing a rectangular
domain in indexing space.  In \hyperref[\detokenize{Basics:fig-basics-amrgrids}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-amrgrids}}}, there are 1, 2 and
2 Boxes on levels 0, 1 and 2, respectively.  \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} is a
dimension\sphinxhyphen{}dependent class. It has lower and upper corners (represented by
\sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}}) and an index type (represented by \sphinxcode{\sphinxupquote{\DUrole{name}{IndexType}}}). A
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} contains no floating\sphinxhyphen{}point data.


\subsection{IntVect}
\label{\detokenize{Basics:intvect}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{IntVec}}} is a dimension\sphinxhyphen{}dependent class representing an integer vector in
\sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_SPACEDIM}}}\sphinxhyphen{}dimensional space. An \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} can be constructed
as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IntVect} \PYG{n+nf}{iv}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_D\_DECL}}} is a macro that expands \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_D\_DECL}\DUrole{punctuation}{(}\DUrole{literal,number,integer}{19}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{0}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{5}\DUrole{punctuation}{)}}} to
either \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{19}}} or \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{19}\DUrole{punctuation}{,} \DUrole{literal,number,integer}{0}}} or \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{19}\DUrole{punctuation}{,} \DUrole{literal,number,integer}{0}\DUrole{punctuation}{,} \DUrole{literal,number,integer}{5}}} depending on the number of
dimensions. The data can be accessed via \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}}, and the internal
data pointer can be returned by function \sphinxcode{\sphinxupquote{\DUrole{name}{getVect}}}. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{idim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{idim} \PYG{o}{\PYGZlt{}} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{idim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iv[}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{idim} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iv}\PYG{p}{[}\PYG{n}{idim}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{o}{*} \PYG{n}{p} \PYG{o}{=} \PYG{n}{iv}\PYG{p}{.}\PYG{n}{getVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// This can be passed to Fortran/C as an array}
\end{sphinxVerbatim}

\sphinxAtStartPar
The class has a static function \sphinxcode{\sphinxupquote{\DUrole{name}{TheZeroVector}\DUrole{punctuation}{()}}} returning the zero
vector, \sphinxcode{\sphinxupquote{\DUrole{name}{TheUnitVector}\DUrole{punctuation}{()}}} returning the unit vector, and
\sphinxcode{\sphinxupquote{\DUrole{name}{TheDimensionVector} \DUrole{punctuation}{(}\DUrole{keyword,type}{int} \DUrole{name}{dir}\DUrole{punctuation}{)}}} returning a reference to a constant
\sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} that is zero except in the \sphinxcode{\sphinxupquote{\DUrole{name}{dir}}}\sphinxhyphen{}direction. Note the
direction is zero\sphinxhyphen{}based. \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} has a number of relational operators,
\sphinxcode{\sphinxupquote{\DUrole{operator}{==}}}, \sphinxcode{\sphinxupquote{\DUrole{operator}{!=}}}, \sphinxcode{\sphinxupquote{\DUrole{operator}{\textless{}}}}, \sphinxcode{\sphinxupquote{\DUrole{operator}{\textless{}=}}}, \sphinxcode{\sphinxupquote{\DUrole{operator}{\textgreater{}}}} , and \sphinxcode{\sphinxupquote{\DUrole{operator}{\textgreater{}=}}} that can be
used for lexicographical comparison (e.g., key of \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{map}}}), and a class
\sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}\DUrole{operator}{::}\DUrole{name}{shift\_hasher}}} that can be used as a hash function (e.g., for
\sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{unordered\_map}}}). It also has various arithmetic operators. For
example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IntVect} \PYG{n+nf}{iv}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntVect} \PYG{n+nf}{iv2}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iv} \PYG{o}{+}\PYG{o}{=} \PYG{n}{iv2}\PYG{p}{;}  \PYG{c+c1}{// iv is now (23,8,5)}
\PYG{n}{iv} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}    \PYG{c+c1}{// iv is now (46,16,10);}
\end{sphinxVerbatim}

\sphinxAtStartPar
In AMR codes, one often needs to do refinement and coarsening on
\sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}}. The refinement operation can be done with the multiplication
operation. However, the coarsening requires care because of the rounding
towards zero behavior of integer division in Fortran, C and C++. For example
\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{i} \DUrole{operator}{=} \DUrole{literal,number,integer}{\sphinxhyphen{}1}\DUrole{operator}{/}\DUrole{literal,number,integer}{2}}} gives \sphinxcode{\sphinxupquote{\DUrole{name}{i} \DUrole{operator}{=} \DUrole{literal,number,integer}{0}}}, and what we want is usually \sphinxcode{\sphinxupquote{\DUrole{name}{i} \DUrole{operator}{=}
\DUrole{literal,number,integer}{\sphinxhyphen{}1}}}. Thus, one should use the coarsen functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IntVect} \PYG{n+nf}{iv}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntVect} \PYG{n+nf}{coarsening\PYGZus{}ratio}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{iv}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}                 \PYG{c+c1}{// Coarsen each component by 2}
\PYG{n}{iv}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{n}{coarsening\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Component\PYGZhy{}wise coarsening}
\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{iv2} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{coarsen}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Return an IntVect w/o modifying iv}
\PYG{n}{IntVect} \PYG{n}{iv3} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{coarsen}\PYG{p}{(}\PYG{n}{iv}\PYG{p}{,} \PYG{n}{coarsening\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// iv not modified}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, we note that \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{operator}{\textless{}\textless{}}}} is overloaded for \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} and
therefore one can call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{IndexType}
\label{\detokenize{Basics:indextype}}
\sphinxAtStartPar
This class defines an index as being cell based or node based in each
dimension. The default constructor defines a cell based type in all directions.
One can also construct an \sphinxcode{\sphinxupquote{\DUrole{name}{IndexType}}} with an \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} with zero and
one representing cell and node, respectively.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Node in x\PYGZhy{}direction and cell based in y and z\PYGZhy{}directions}
\PYG{c+c1}{// (i.e., x\PYGZhy{}face of numerical cells)}
\PYG{n}{IndexType} \PYG{n+nf}{xface}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The class provides various functions including

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// True if the IndexType is cell based in all directions.}
\PYG{k+kt}{bool} \PYG{n+nf}{cellCentered} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// True if the IndexType is cell based in dir\PYGZhy{}direction.}
\PYG{k+kt}{bool} \PYG{n+nf}{cellCentered} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dir}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// True if the IndexType is node based in all directions.}
\PYG{k+kt}{bool} \PYG{n+nf}{nodeCentered} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// True if the IndexType is node based in dir\PYGZhy{}direction.}
\PYG{k+kt}{bool} \PYG{n+nf}{nodeCentered} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dir}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Index type is a very important concept in AMReX. It is a way of representing
the notion of indices \(i\) and \(i+1/2\).


\subsection{Box}
\label{\detokenize{Basics:box}}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{Box}} is an abstraction for defining discrete regions of
\sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_SPACEDIM}}}\sphinxhyphen{}dimensional indexing space. Boxes have an
\sphinxcode{\sphinxupquote{\DUrole{name}{IndexType}}} and two \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}}s representing the lower and upper
corners. Boxes can exist in positive and negative indexing space. Typical ways
of defining a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IntVect} \PYG{n+nf}{lo}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IntVect} \PYG{n+nf}{hi}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IndexType} \PYG{n+nf}{typ}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Box} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// By default, Box is cell based.}
\PYG{n}{Box} \PYG{n+nf}{nd}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,}\PYG{n}{hi}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{typ}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Construct a nodal Box.}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A cell\PYGZhy{}centered Box }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An all nodal Box    }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nd} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Depending the dimensionality, the output of the code above is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{cell}\PYG{o}{\PYGZhy{}}\PYG{n}{centered} \PYG{n}{Box} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{An} \PYG{n}{all} \PYG{n}{nodal} \PYG{n}{Box}    \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{,}\PYG{l+m+mi}{128}\PYG{p}{,}\PYG{l+m+mi}{128}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For simplicity, we will assume it is 3D for the rest of this section.  In the
output, three integer tuples for each box are the lower corner indices, upper
corner indices, and the index types. Note that 0 and 1 denote cell and node,
respectively. For each tuple like \sphinxcode{\sphinxupquote{\DUrole{punctuation}{(}\DUrole{literal,number,integer}{64}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{64}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{64}\DUrole{punctuation}{)}}}, the 3 numbers are for 3
directions. The two Boxes in the code above represent different indexing views
of the same domain of \(64^3\) cells. Note that in AMReX convention, the
lower side of a cell has the same integer value as the cell centered index.
That is if we consider a cell based index represent \(i\), the nodal index
with the same integer value represents \(i-1/2\).
\hyperref[\detokenize{Basics:fig-basics-indextypes}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-indextypes}}} shows some of the different index types for 2D.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=5in]{{indextypes}.png}
\caption{Some of the different index types in two dimensions: (a) cell\sphinxhyphen{}centered, (b) \(x\)\sphinxhyphen{}face\sphinxhyphen{}centered
(i.e., nodal in \(x\)\sphinxhyphen{}direction only), and (c) corner/nodal,
i.e., nodal in all dimensions.}\label{\detokenize{Basics:id2}}\label{\detokenize{Basics:fig-basics-indextypes}}\end{figure}

\end{center}

\sphinxAtStartPar
There are a number of ways of converting a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} from one type to another.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{b0} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Index type: (cell, cell, cell)}

\PYG{n}{Box} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// A new Box with type (node, node, node)}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b1}\PYG{p}{;}                  \PYG{c+c1}{// ((64,64,64) (128,128,128) (1,1,1))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b0}\PYG{p}{;}                  \PYG{c+c1}{// Still ((64,64,64) (127,127,127) (0,0,0))}

\PYG{n}{Box} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{enclosedCells}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// A new Box with type (cell, cell, cell)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{b2} \PYG{o}{=}\PYG{o}{=} \PYG{n}{b0}\PYG{p}{)} \PYG{p}{\PYGZob{}}                 \PYG{c+c1}{// Yes, they are identical.}
   \PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b0 and b2 are identical!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Box} \PYG{n}{b3} \PYG{o}{=} \PYG{n}{convert}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// A new Box with type (cell, node, cell)}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b3}\PYG{p}{;}                  \PYG{c+c1}{// ((64,64,64) (127,128,127) (0,1,0))}

\PYG{n}{b3}\PYG{p}{.}\PYG{n}{convert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}            \PYG{c+c1}{// Convert b0 to type (cell, cell, node)}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b3}\PYG{p}{;}                  \PYG{c+c1}{// ((64,64,64) (127,127,128) (0,0,1))}

\PYG{n}{b3}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}          \PYG{c+c1}{//  Exercise for you}
\PYG{n}{b3}\PYG{p}{.}\PYG{n}{enclosedCells}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{//  Exercise for you}
\end{sphinxVerbatim}

\sphinxAtStartPar
The internal data of \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} can be accessed via various member functions.
Examples are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n+nf}{smallEnd} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{o}{\PYGZam{}}\PYG{p}{;}  \PYG{c+c1}{// Get the small end of the Box}
\PYG{k+kt}{int} \PYG{n+nf}{bigEnd} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dir}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}         \PYG{c+c1}{// Get the big end in dir direction}
\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*} \PYG{n+nf}{loVect} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{o}{\PYGZam{}}\PYG{p}{;}        \PYG{c+c1}{// Get a const pointer to the lower end}
\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*} \PYG{n+nf}{hiVect} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{o}{\PYGZam{}}\PYG{p}{;}        \PYG{c+c1}{// Get a const pointer to the upper end}
\end{sphinxVerbatim}

\sphinxAtStartPar
Boxes can be refined and coarsened. Refinement or coarsening does not change
the index type. Some examples are shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{ccbx} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ccbx}\PYG{p}{.}\PYG{n}{refine}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ccbx}\PYG{p}{;}                   \PYG{c+c1}{// ((32,32,32) (63,63,63) (0,0,0))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ccbx}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// ((16,16,16) (31,31,31) (0,0,0))}

\PYG{n}{Box} \PYG{n+nf}{ndbx} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ndbx}\PYG{p}{.}\PYG{n}{refine}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ndbx}\PYG{p}{;}                   \PYG{c+c1}{// ((32,32,32) (64,64,64) (1,1,1))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ndbx}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// ((16,16,16) (32,32,32) (1,1,1))}

\PYG{n}{Box} \PYG{n+nf}{facebx} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{facebx}\PYG{p}{.}\PYG{n}{refine}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{facebx}\PYG{p}{;}                 \PYG{c+c1}{// ((32,32,32) (64,63,63) (1,0,0))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{facebx}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// ((16,16,16) (32,31,31) (1,0,0))}

\PYG{n}{Box} \PYG{n+nf}{uncoarsenable} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uncoarsenable}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ((8,8,8), (15,15,15));}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uncoarsenable}\PYG{p}{.}\PYG{n}{refine}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// ((16,16,16), (31,31,31));}
                                     \PYG{c+c1}{// Different from the original!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the behavior of refinement and coarsening depends on the
index type.  A refined \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} covers the same physical domain as
the original \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}, and a coarsened \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} also covers the
same physical domain if the original \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} is coarsenable.
\sphinxcode{\sphinxupquote{\DUrole{name}{Box} \DUrole{name}{uncoarsenable}}} in the example above is considered
uncoarsenable because its coarsened version does not cover the same
physical domain in the AMR context.

\sphinxAtStartPar
Boxes can grow in one or all directions.  There are a number of grow functions.
Some are member functions of the \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} class and others are free
functions in the \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}}} namespace.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} class provides the following member functions testing if a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} or \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} is contained within this \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. Note that it
is a runtime error if the two Boxes have different types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n+nf}{contains} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n+nf}{strictly\PYGZus{}contains} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n+nf}{contains} \PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n+nf}{strictly\PYGZus{}contains} \PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another very common operation is the intersection of two Boxes like in the
following examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{b0} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Box} \PYG{n+nf}{b1} \PYG{p}{(}\PYG{p}{\PYGZob{}} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{23}\PYG{p}{,}\PYG{l+m+mi}{23}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{b0}\PYG{p}{.}\PYG{n}{intersects}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}                  \PYG{c+c1}{// true}
    \PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b0 and b1 intersect.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Box} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{b0} \PYG{o}{\PYGZam{}} \PYG{n}{b1}\PYG{p}{;}     \PYG{c+c1}{// b0 and b1 unchanged}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b2}\PYG{p}{;}        \PYG{c+c1}{// ((16,16,30) (23,23,31) (0,0,0))}

\PYG{n}{Box} \PYG{n}{b3} \PYG{o}{=} \PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// b0 and b1 unchanged}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b3}\PYG{p}{;}        \PYG{c+c1}{// ((16,16,30) (24,24,32) (1,1,1))}

\PYG{n}{b0} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}             \PYG{c+c1}{// b2 unchanged}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b0}\PYG{p}{;}        \PYG{c+c1}{// ((16,16,30) (23,23,31) (0,0,0))}

\PYG{n}{b0} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{b3}\PYG{p}{;}             \PYG{c+c1}{// Runtime error because of type mismatch!}
\end{sphinxVerbatim}


\section{Dim3 and XDim3}
\label{\detokenize{Basics:dim3-and-xdim3}}\label{\detokenize{Basics:sec-basics-dim3}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Dim3}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{XDim3}}} are plain structs with three fields,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n+nc}{Dim3} \PYG{p}{\PYGZob{}} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{z}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{struct} \PYG{n+nc}{XDim3} \PYG{p}{\PYGZob{}} \PYG{n}{Real} \PYG{n}{x}\PYG{p}{;} \PYG{n}{Real} \PYG{n}{y}\PYG{p}{;} \PYG{n}{Real} \PYG{n}{z}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can convert an \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} to \sphinxcode{\sphinxupquote{\DUrole{name}{Dim3}}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{IntVect} \PYG{n+nf}{iv}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dim3} \PYG{n}{d3} \PYG{o}{=} \PYG{n}{iv}\PYG{p}{.}\PYG{n}{dim3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Dim3}}} always has three fields even when AMReX is built for 1D or
2D.  For the example above, the extra fields are set to zero.  Given a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}, one can get its lower and upper bounds and use them to
write dimension agnostic loops.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{bx}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dim3} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{lbound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dim3} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{ubound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}     \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{for}   \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can also call function \sphinxcode{\sphinxupquote{Dim3 length(Box const\&)}} to return the length of a Box.


\section{RealBox and Geometry}
\label{\detokenize{Basics:realbox-and-geometry}}\label{\detokenize{Basics:sec-basics-geom}}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{\DUrole{name}{RealBox}}} stores the physical location in floating\sphinxhyphen{}point numbers of the
lower and upper corners of a rectangular domain.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} class in AMReX\_Geometry.H describes problem domain and
coordinate system for rectangular problem domains. A \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} object can
be constructed with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{explicit} \PYG{n}{Geometry} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}}     \PYG{n}{dom}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{RealBox}\PYG{o}{*} \PYG{n}{rb}     \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{,}
                   \PYG{k+kt}{int}            \PYG{n}{coord}  \PYG{o}{=} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}
                   \PYG{k+kt}{int}\PYG{o}{*}           \PYG{n}{is\PYGZus{}per} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}

\PYG{n}{Geometry} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{dom}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealBox}\PYG{o}{\PYGZam{}} \PYG{n}{rb}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{coord}\PYG{p}{,}
          \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{is\PYGZus{}per}\PYG{p}{)} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the constructors take a cell\sphinxhyphen{}centered \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} specifying the indexing
space domain, a \sphinxcode{\sphinxupquote{\DUrole{name}{RealBox}}} specifying the
physical domain, an \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}}} specifying coordinate system type, and
an \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}}} pointer or array specifying periodicity. If a \sphinxcode{\sphinxupquote{\DUrole{name}{RealBox}}} is not
given in the first constructor, AMReX  will construct one based on \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} parameters,
\sphinxcode{\sphinxupquote{geometry.prob\_lo}} and \sphinxcode{\sphinxupquote{geometry.prob\_hi}}, where each of the parameter is
an array of \sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} real numbers. It’s a runtime error if this
fails. The argument for coordinate system is an integer type with
valid values being 0 (Cartesian), or 1 (cylindrical), or 2 (spherical). If it
is invalid as in the case of the default argument value of the first constructor, AMReX will query the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} database for \sphinxcode{\sphinxupquote{geometry.coord\_sys}} and use it if one is
found. If it cannot find the parameter, the coordinate system is set to 0
(i.e., Cartesian coordinates). The \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} class has the concept of
periodicity.  An argument can be passed specifying periodicity in each
dimension. If it is not given in the first constructor, the domain is assumed to be non\sphinxhyphen{}periodic unless
there is the \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} integer array parameter \sphinxcode{\sphinxupquote{geometry.is\_periodic}}
with 0 denoting non\sphinxhyphen{}periodic and 1 denoting periodic. Below is an example of
defining a \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} for a periodic rectangular domain of
\([-1.0,1.0]\) in each direction discretized with \(64\) numerical
cells in each direction.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{n\PYGZus{}cell} \PYG{o}{=} \PYG{l+m+mi}{64}\PYG{p}{;}

\PYG{c+c1}{// This defines a Box with n\PYGZus{}cell cells in each direction.}
\PYG{n}{Box} \PYG{n+nf}{domain}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}       \PYG{l+m+mi}{0}\PYG{p}{,}        \PYG{l+m+mi}{0}\PYG{p}{,}        \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
           \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// This defines the physical box, [\PYGZhy{}1,1] in each direction.}
\PYG{n}{RealBox} \PYG{n+nf}{real\PYGZus{}box}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{,}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{,}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                 \PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// This says we are using Cartesian coordinates}
\PYG{k+kt}{int} \PYG{n}{coord} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// This sets the boundary conditions to be doubly or triply periodic}
\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{is\PYGZus{}periodic} \PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// This defines a Geometry object}
\PYG{n}{Geometry} \PYG{n+nf}{geom}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,} \PYG{n}{real\PYGZus{}box}\PYG{p}{,} \PYG{n}{coord}\PYG{p}{,} \PYG{n}{is\PYGZus{}periodic}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} object can return various information of the physical domain
and the indexing space domain. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{k}{auto} \PYG{n}{problo} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{ProbLoArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Lower corner of the physical}
                                        \PYG{c+c1}{// domain.  The return type is}
                                        \PYG{c+c1}{// GpuArray\PYGZlt{}Real,AMREX\PYGZus{}SPACEDIM\PYGZgt{}.}
\PYG{n}{Real} \PYG{n}{yhi} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{ProbHi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// y\PYGZhy{}direction upper corner}
\PYG{k}{const} \PYG{k}{auto} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{CellSizeArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Cell size for each direction.}
\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{domain} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{Domain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// Index domain}
\PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}per} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{isPeriodic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// Is periodic in x\PYGZhy{}direction?}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{isAllPeriodic}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}            \PYG{c+c1}{// Periodic in all direction?}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{isAnyPeriodic}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}            \PYG{c+c1}{// Periodic in any direction?}
\end{sphinxVerbatim}


\section{BoxArray}
\label{\detokenize{Basics:boxarray}}\label{\detokenize{Basics:sec-basics-ba}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} is a class in \sphinxcode{\sphinxupquote{AMReX\_BoxArray.H}} for storing a collection of
Boxes on a single AMR level. One can make a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} out of a single
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} and then chop it into multiple Boxes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{domain}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BoxArray} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Make a new BoxArray out of a single Box}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BoxArray size is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ba}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// 1}
\PYG{n}{ba}\PYG{p}{.}\PYG{n}{maxSize}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// Chop into boxes of 64\PYGZca{}3 cells}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ba}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{BoxArray} \PYG{n}{maxbox}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
       \PYG{n}{m\PYGZus{}ref}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{m\PYGZus{}hash\PYGZus{}sig}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It shows that \sphinxcode{\sphinxupquote{ba}} now has 8 Boxes, and it also prints out each Box.

\sphinxAtStartPar
In AMReX, \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} is a global data structure. It holds all the Boxes in
a collection, even though a single process in a parallel run only owns some of
the Boxes via domain decomposition. In the example above, a 4\sphinxhyphen{}process run may
divide the work and each process owns say 2 Boxes (see section
on {\hyperref[\detokenize{Basics:sec-basics-dm}]{\sphinxcrossref{\DUrole{std,std-ref}{DistributionMapping}}}}). Each process can then allocate memory for the
floating point data on the Boxes it owns (see sections
on {\hyperref[\detokenize{Basics:sec-basics-multifab}]{\sphinxcrossref{\DUrole{std,std-ref}{FabArray, MultiFab and iMultiFab}}}} \& {\hyperref[\detokenize{Basics:sec-basics-fab}]{\sphinxcrossref{\DUrole{std,std-ref}{BaseFab, FArrayBox, IArrayBox, and Array4}}}}).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} has an indexing type, just like \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. Each Box in a
BoxArray has the same type as the BoxArray itself. In the following example, we
show how one can convert BoxArray to a different type.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BoxArray} \PYG{n+nf}{cellba}\PYG{p}{(}\PYG{n}{Box}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{cellba}\PYG{p}{.}\PYG{n}{maxSize}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BoxArray} \PYG{n}{faceba} \PYG{o}{=} \PYG{n}{cellba}\PYG{p}{;}       \PYG{c+c1}{// Make a copy}
\PYG{n}{faceba}\PYG{p}{.}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// convert to index type (cell, cell, node)}
\PYG{c+c1}{// Return an all node BoxArray}
\PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{nodeba} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{faceba}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cellba}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// ((0,0,0) (63,63,63) (0,0,0))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{faceba}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// ((0,0,0) (63,63,64) (0,0,1))}
\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nodeba}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}  \PYG{c+c1}{// ((0,0,0) (64,64,64) (1,1,1))}
\end{sphinxVerbatim}

\sphinxAtStartPar
As shown in the example above, \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} has an \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}} that
returns a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} given an index. It should be emphasized that there is a
difference between its behavior and the usual behavior of an subscript operator
one might expect. The subscript operator in \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} returns by \sphinxstylestrong{value
instead of reference}. This means code like below is meaningless because it
modifies a temporary return value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ba}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// DO NOT DO THIS!  Doesn\PYGZsq{}t do what one might expect.}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} has a number of member functions that allow the Boxes to be
modified. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n+nf}{refine} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{refinement\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Refine each Box in BoxArray}
\PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n+nf}{refine} \PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{refinement\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n+nf}{coarsen} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{refinement\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Coarsen each Box in BoxArray}
\PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n+nf}{coarsen} \PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{refinement\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have mentioned at the beginning of this section that \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} is a
global data structure storing Boxes shared by all processes.  The operation of
a deep copy is thus undesirable because it is expensive and the extra copy
wastes memory. The implementation of the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} class uses
\sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{shared\_ptr}}} to an internal container holding the actual Box data.
Thus making a copy of \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} is a quite cheap operation. The
conversion of types and coarsening are also cheap because they can share the
internal data with the original \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}. In our implementation,
function \sphinxcode{\sphinxupquote{\DUrole{name}{refine}}} does create a new deep copy of the original data. Also
note that a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and its variant with a different type share the
same internal data is an implementation detail.  We discuss this so that the
users are aware of the performance and resource cost. Conceptually we can think
of them as completely independent of each other.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BoxArray} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// original BoxArray}
\PYG{n}{BoxArray} \PYG{n}{ba2} \PYG{o}{=} \PYG{n}{ba}\PYG{p}{;} \PYG{c+c1}{// a copy that shares the internal data with the original}
\PYG{n}{ba2}\PYG{p}{.}\PYG{n}{coarsen}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// Modify the copy}
\PYG{c+c1}{// The original copy is unmodified even though they share internal data.}
\end{sphinxVerbatim}

\sphinxAtStartPar
For advanced users, AMReX provides functions performing the intersection of a
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. These functions are much faster than a naive
implementation of performing intersection of the Box with each Box in the
BoxArray. If one needs to perform those intersections, functions
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{intersect}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}\DUrole{operator}{::}\DUrole{name}{intersects}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}\DUrole{operator}{::}\DUrole{name}{intersections}}} should be used.


\section{DistributionMapping}
\label{\detokenize{Basics:distributionmapping}}\label{\detokenize{Basics:sec-basics-dm}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} is a class in \sphinxcode{\sphinxupquote{AMReX\_DistributionMapping.H}} that
describes which process owns the data living on the domains specified by the
Boxes in a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}. Like \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}, there is an element for each
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} in \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}, including the ones owned by other
parallel processes. One can construct a \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} object given
a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DistributionMapping} \PYG{n}{dm} \PYG{p}{\PYGZob{}}\PYG{n}{ba}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or by simply making a copy,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DistributionMapping} \PYG{n}{dm} \PYG{p}{\PYGZob{}}\PYG{n}{another\PYGZus{}dm}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this class is built using \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{shared\_ptr}}}. Thus making a copy
is relatively cheap in terms of performance and memory resources. This class
has a subscript operator that returns the process ID at a given index.

\sphinxAtStartPar
By default, \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} uses an algorithm based on space filling
curve to determine the distribution. One can change the default via the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} parameter \sphinxcode{\sphinxupquote{DistributionMapping.strategy}}.  \sphinxcode{\sphinxupquote{KNAPSACK}} is a
common choice that is optimized for load balance.  One can also explicitly
construct a distribution.  The \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} class allows the user
to have complete control by passing an array of integers that represent the
mapping of grids to processes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DistributionMapping} \PYG{n}{dm}\PYG{p}{;}   \PYG{c+c1}{// empty object}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{pmap} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// The user fills the pmap array with the values specifying owner processes}
\PYG{n}{dm}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{pmap}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Build DistributionMapping given an array of process IDs.}
\end{sphinxVerbatim}


\section{BaseFab, FArrayBox, IArrayBox, and Array4}
\label{\detokenize{Basics:basefab-farraybox-iarraybox-and-array4}}\label{\detokenize{Basics:sec-basics-fab}}
\sphinxAtStartPar
AMReX is a block\sphinxhyphen{}structured AMR framework. Although AMR introduces irregularity
to the data and algorithms, there is regularity at the block/Box level because
each is still logically rectangular, and the data structure at the Box level is
conceptually simple. \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} is a class template for multi\sphinxhyphen{}dimensional
array\sphinxhyphen{}like data structure on a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. The template parameter is typically
basic types such as \sphinxcode{\sphinxupquote{\DUrole{name}{Real}}}, \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}}} or \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{char}}}. The dimensionality
of the array is \sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} \sphinxstyleemphasis{plus one}. The additional dimension is for
the number of components. The data are internally stored in a contiguous block
of memory in Fortran array order (i.e., column\sphinxhyphen{}major order) for
\((x,y,z,\mathrm{component})\), and each component also occupies a
contiguous block of memory because of the ordering. For example, a
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{name}{Real}\DUrole{operator}{\textgreater{}}}} with 4 components defined on a three\sphinxhyphen{}dimensional
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{punctuation}{(}\DUrole{name}{IntVect}\DUrole{punctuation}{\{}\DUrole{literal,number,integer}{\sphinxhyphen{}4}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{32}\DUrole{punctuation}{\},}\DUrole{name}{IntVect}\DUrole{punctuation}{\{}\DUrole{literal,number,integer}{32}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{64}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{48}\DUrole{punctuation}{\})}}} is like a Fortran array of
\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{real}\DUrole{punctuation}{(}\DUrole{name}{amrex\_real}\DUrole{punctuation}{),} \DUrole{keyword}{dimension}\DUrole{punctuation}{(}\DUrole{operator}{\sphinxhyphen{}}\DUrole{literal,number,integer}{4}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{32}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{64}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{32}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{48}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{0}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{3}\DUrole{punctuation}{)}}}.  Note that the
convention in C++ part of AMReX is the component index is zero based. The code
for constructing such an object is as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{bx}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{32}\PYG{p}{,}\PYG{l+m+mi}{64}\PYG{p}{,}\PYG{l+m+mi}{48}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{numcomps} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{fab}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}\PYG{n}{numcomps}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Most applications do not use \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} directly, but utilize specialized
classes derived from \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}. The most common types are \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}
in AMReX\_FArrayBox.H derived from \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{name}{Real}\DUrole{operator}{\textgreater{}}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{IArrayBox}}} in
AMReX\_IArrayBox.H derived from \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{keyword,type}{int}\DUrole{operator}{\textgreater{}}}}.

\sphinxAtStartPar
These derived classes also obtain many \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} member functions via
inheritance. We now show some common usages of these functions.  To get the
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} where a \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} or its derived object is defined, one can
call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n+nf}{box}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To the number of component, one can call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{nComp}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To get a pointer to the array data, one can call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{T}\PYG{o}{*} \PYG{n+nf}{dataPtr}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Data pointer to the nth component}
                         \PYG{c+c1}{// T is template parameter (e.g., Real)}
\PYG{k}{const} \PYG{n}{T}\PYG{o}{*} \PYG{n+nf}{dataPtr}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// const version}
\end{sphinxVerbatim}

\sphinxAtStartPar
The typical usage of the returned pointer is then to pass it to a Fortran or C
function that works on the array data (see the section on
{\hyperref[\detokenize{Basics:sec-basics-fortran}]{\sphinxcrossref{\DUrole{std,std-ref}{Fortran and C++ Kernels}}}}).  \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} has several functions that set the
array data to a constant value. Two examples are as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setVal}\PYG{p}{(}\PYG{n}{T} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Set all data to x}
\PYG{c+c1}{// Set the sub\PYGZhy{}region specified by bx to value x starting from component}
\PYG{c+c1}{// nstart.  ncomp is the total number of component to be set.}
\PYG{k+kt}{void} \PYG{n+nf}{setVal}\PYG{p}{(}\PYG{n}{T} \PYG{n}{x}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nstart}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ncomp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One can copy data from one \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} to another.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{copy} \PYG{p}{(}\PYG{k}{const} \PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{src}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{srcbox}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{srccomp}\PYG{p}{,}
                  \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{destbox}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{destcomp}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{numcomp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the function copies the data from the region specified by \sphinxcode{\sphinxupquote{\DUrole{name}{srcbox}}} in
the source \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab} \DUrole{name}{src}}} into the region specified by \sphinxcode{\sphinxupquote{\DUrole{name}{destbox}}} in
the destination BaseFab that invokes the function call. Note that although
\sphinxcode{\sphinxupquote{\DUrole{name}{srcbox}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{destbox}}} may be different, they must be the same size,
shape and index type, otherwise a runtime error occurs. The user also specifies
how many components (\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{numcomp}}}) are copied starting at component
srccomp in src and stored starting at component destcomp. BaseFab has functions
returning the minimum or maximum value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{T} \PYG{n+nf}{min} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{comp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}  \PYG{c+c1}{// Minimum value of given component.}
\PYG{n}{T} \PYG{n+nf}{min} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{subbox}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{comp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// Minimum value of given}
                                             \PYG{c+c1}{// component in given subbox.}
\PYG{n}{T} \PYG{n+nf}{max} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{comp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}  \PYG{c+c1}{// Maximum value of given component.}
\PYG{n}{T} \PYG{n+nf}{max} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{subbox}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{comp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// Maximum value of given}
                                             \PYG{c+c1}{// component in given subbox.}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} also has many arithmetic functions. Here are some examples using
FArrayBox.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{box}\PYG{p}{(}\PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{,}\PYG{l+m+mi}{63}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{FArrayBox} \PYG{n+nf}{fab1}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{FArrayBox} \PYG{n+nf}{fab2}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fab1}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// Fill fab1 with 1.0}
\PYG{n}{fab1}\PYG{p}{.}\PYG{n}{mult}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Multiply component 0 by 10.0}
\PYG{n}{fab2}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// Fill fab2 with 2.0}
\PYG{n}{Real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{3.0}\PYG{p}{;}
\PYG{n}{fab2}\PYG{p}{.}\PYG{n}{saxpy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{fab1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// For both components, fab2 \PYGZlt{}\PYGZhy{} a * fab1 + fab2}
\end{sphinxVerbatim}

\sphinxAtStartPar
These floating point operation functions are templated with parameter
\sphinxcode{\sphinxupquote{\DUrole{name}{RunOn}}} specifying where they run, \sphinxcode{\sphinxupquote{\DUrole{name}{RunOn}\DUrole{operator}{::}\DUrole{name}{Host}}} or
\sphinxcode{\sphinxupquote{\DUrole{name}{RunOn}\DUrole{operator}{::}\DUrole{name}{Device}}}.  When AMReX is built just for CPU, the
template parameter has a default value of \sphinxcode{\sphinxupquote{\DUrole{name}{RunOn}\DUrole{operator}{::}\DUrole{name}{Host}}} so that
the user does not need to specify it for backward compatibility,
and if \sphinxcode{\sphinxupquote{\DUrole{name}{RunOn}\DUrole{operator}{::}\DUrole{name}{Device}}} is provided it will be ignored.
However, when AMReX is built with GPU support, one must specify where
to run for these \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} functions.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fab1}\PYG{p}{.}\PYG{n}{setVal}\PYG{o}{\PYGZlt{}}\PYG{n}{RunOn}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Host}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// Fill fab1 with 1.0}
\PYG{n}{fab1}\PYG{p}{.}\PYG{n}{mult}\PYG{o}{\PYGZlt{}}\PYG{n}{RunOn}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Device}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Multiply component 0 by 10.0}
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{Basics:sec-basics-array4}}
\sphinxAtStartPar
For more complicated expressions that are not supported, one can write
Fortran or C/C++ functions for those (see the section
on {\hyperref[\detokenize{Basics:sec-basics-fortran}]{\sphinxcrossref{\DUrole{std,std-ref}{Fortran and C++ Kernels}}}}).  In C++, one can use \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}},
which is a class template for accessing \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} data in a more
array like manner using \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{()}}}.  Below is an example of
using \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FArrayBox} \PYG{n+nf}{afab}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{bfab}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{IArrayBox} \PYG{n+nf}{ifab}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a} \PYG{o}{=} \PYG{n}{afab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const} \PYG{n}{b} \PYG{o}{=} \PYG{n}{bfab}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{n}{m} \PYG{o}{=} \PYG{n}{ifab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dim3} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{lbound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dim3} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{ubound}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nc} \PYG{o}{=} \PYG{n}{a}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{nc}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{for}     \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for}   \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{m}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
          \PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{b}\PYG{p}{(}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{b}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{()}}} of \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} takes either three or
four arguments.  The optional fourth argument has a default value of
zero.  The two \sphinxcode{\sphinxupquote{\DUrole{keyword}{const}}}s in \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}\DUrole{operator}{\textless{}}\DUrole{name}{Real} \DUrole{keyword}{const}\DUrole{operator}{\textgreater{}} \DUrole{keyword}{const}\DUrole{operator}{\&}}}
have different meaning.  The first \sphinxcode{\sphinxupquote{\DUrole{keyword}{const}}} inside \sphinxcode{\sphinxupquote{\DUrole{operator}{\textless{}\textgreater{}}}} means
the data accessed via \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} is read\sphinxhyphen{}only, whereas the second
\sphinxcode{\sphinxupquote{\DUrole{keyword}{const}}} means the \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} object itself cannot be modified
to point to other data.  In the example above, neither \sphinxcode{\sphinxupquote{m(i,j,k) =
0}} nor \sphinxcode{\sphinxupquote{b(i,j,k) = 0.0}} is allowed.  However one is allowed to do
\sphinxcode{\sphinxupquote{m = ifab2.array()}} to assign \sphinxcode{\sphinxupquote{\DUrole{name}{m}}} again, but not to \sphinxcode{\sphinxupquote{\DUrole{name}{b}}}.
The behavior is in some sense similar to \sphinxcode{\sphinxupquote{double const * const p}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} and its derived classes are containers for data on \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}.
Recall that \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} has various types (see the section on {\hyperref[\detokenize{Basics:sec-basics-box}]{\sphinxcrossref{\DUrole{std,std-ref}{Box, IntVect and IndexType}}}}).
The examples in this section so far use the default cell based type.  However,
some functions will result in a runtime error if the types mismatch.  For
example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{ccbx} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}           \PYG{c+c1}{// cell centered box}
\PYG{n}{Box} \PYG{n+nf}{ndbx} \PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{,}\PYG{l+m+mi}{31}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// nodal box}
\PYG{n}{FArrayBox} \PYG{n+nf}{ccfab}\PYG{p}{(}\PYG{n}{ccbx}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{FArrayBox} \PYG{n+nf}{ndfab}\PYG{p}{(}\PYG{n}{ndbx}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ccfab}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ndfab}\PYG{p}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{ccfab}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// runtime error due to type mismatch}
\end{sphinxVerbatim}

\sphinxAtStartPar
Because it typically contains a lot of data, BaseFab’s copy constructor and
copy assignment operator are disabled to prevent performance degradation. However, BaseFab does
provide a move constructor. In addition, it also provides a constructor for
making an alias of an existing object. Here is an example using
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FArrayBox} \PYG{n+nf}{orig\PYGZus{}fab}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// 4\PYGZhy{}component FArrayBox}
\PYG{c+c1}{// Make a 2\PYGZhy{}component FArrayBox that is an alias of orig\PYGZus{}fab}
\PYG{c+c1}{// starting from component 1.}
\PYG{n}{FArrayBox} \PYG{n+nf}{alias\PYGZus{}fab}\PYG{p}{(}\PYG{n}{orig\PYGZus{}fab}\PYG{p}{,} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}alias}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, the alias \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} has only two components even though
the original one has four components. The alias has a sliced component view of
the original \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}. This is possible because of the array ordering.
However, it is not possible to slice in the real space (i.e., the first
\sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} dimensions).  Note that no new memory is allocated in
constructing the alias and the alias contains a non\sphinxhyphen{}owning pointer. It should
be emphasized that the alias will contain a dangling pointer after the original
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} reaches its end of life.  One can also construct an
alias \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} given an \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const} \PYG{n}{a} \PYG{o}{=} \PYG{n}{orig\PYGZus{}fab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{FArrayBox} \PYG{n+nf}{alias\PYGZus{}fab}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{FabArray, MultiFab and iMultiFab}
\label{\detokenize{Basics:fabarray-multifab-and-imultifab}}\label{\detokenize{Basics:sec-basics-multifab}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}\DUrole{operator}{\textless{}}\DUrole{name}{FAB}\DUrole{operator}{\textgreater{}}}} is a class template in AMReX\_FabArray.H for a collection
of FABs on the same AMR level associated with a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} (see the
section on {\hyperref[\detokenize{Basics:sec-basics-ba}]{\sphinxcrossref{\DUrole{std,std-ref}{BoxArray}}}}). The template parameter \sphinxcode{\sphinxupquote{\DUrole{name}{FAB}}} is usually
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{name}{T}\DUrole{operator}{\textgreater{}}}} or its derived classes (e.g., \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}). However, FabArray
can also be used to hold other data structures. To construct a FabArray, a
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} must be provided because the FabArray is intended to hold \sphinxstyleemphasis{grid} data
defined on a union of rectangular regions embedded in a uniform index space.
For example, a FabArray object can be used to hold data for one level as in
\hyperref[\detokenize{Basics:fig-basics-amrgrids}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-amrgrids}}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}} is a parallel data structure in which the data (i.e., FAB) are
distributed among parallel processes. For each process, a FabArray contains
only the FAB objects owned by that process, and the process operates only on
its local data. For operations that require data owned by other processes,
remote communications are involved. Thus, the construction of a \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}}
requires a \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} (see the section on {\hyperref[\detokenize{Basics:sec-basics-dm}]{\sphinxcrossref{\DUrole{std,std-ref}{DistributionMapping}}}})
that specifies which process owns which Box. For level 2 (\sphinxstyleemphasis{red}) in
\hyperref[\detokenize{Basics:fig-basics-amrgrids}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-amrgrids}}}, there are two Boxes. Suppose there are two
parallel processes, and we use a DistributionMapping that assigns one Box to
each process. Then the \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}} on each process is built on the
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} with both Boxes, but contains only the FAB associated with its process.

\sphinxAtStartPar
In AMReX, there are some specialized classes derived from \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}}. The
\sphinxcode{\sphinxupquote{\DUrole{name}{iMultiFab}}} class in AMReX\_iMultiFab.H is derived from
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}\DUrole{operator}{\textless{}}\DUrole{name}{IArrayBox}\DUrole{operator}{\textgreater{}}}}. The most commonly used \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}} kind class
is \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} in AMReX\_MultiFab.H derived from \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}\DUrole{operator}{\textless{}}\DUrole{name}{FArrayBox}\DUrole{operator}{\textgreater{}}}}.
In the rest of this section, we use \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} as example. However, these
concepts are equally applicable to other types of FabArrays. There are many
ways to define a MultiFab. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// ba is BoxArray}
\PYG{c+c1}{// dm is DistributionMapping}
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ngrow} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{mf}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{ngrow}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we define a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with 4 components and 1 ghost cell. A MultiFab
contains a number of \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}es (see the section
on {\hyperref[\detokenize{Basics:sec-basics-fab}]{\sphinxcrossref{\DUrole{std,std-ref}{BaseFab, FArrayBox, IArrayBox, and Array4}}}}) defined on Boxes grown by the number of ghost cells
(1 in this example). That is the \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} in the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} is not
exactly the same as in the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}.  If the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} has a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{punctuation}{\{(}\DUrole{literal,number,integer}{7}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{7}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{7}\DUrole{punctuation}{)} \DUrole{punctuation}{(}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{)\}}}}, the one used for constructing \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}
will be \sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{punctuation}{\{(}\DUrole{literal,number,integer}{6}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{6}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{6}\DUrole{punctuation}{)} \DUrole{punctuation}{(}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{)\}}}} in this example. For cells in
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}, we call those in the original \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} \sphinxstylestrong{valid cells} and
the grown part \sphinxstylestrong{ghost cells}. Note that \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} itself does not have
the concept of ghost cells.  Ghost cells are a key concept of
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, however, that allows for local operations on ghost cell data
originated from remote processes. We will discuss how to fill ghost cells with
data from valid cells later in this section.  \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} also has a
default constructor. One can define an empty \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} first and then
call the \sphinxcode{\sphinxupquote{\DUrole{name}{define}}} function as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MultiFab} \PYG{n}{mf}\PYG{p}{;}
\PYG{c+c1}{// ba is BoxArray}
\PYG{c+c1}{// dm is DistributionMapping}
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ngrow} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{ngrow}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Given an existing \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, one can also make an alias \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}
as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// orig\PYGZus{}mf is an existing MultiFab}
\PYG{k+kt}{int} \PYG{n}{start\PYGZus{}comp} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{num\PYGZus{}comps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{alias\PYGZus{}mf}\PYG{p}{(}\PYG{n}{orig\PYGZus{}mf}\PYG{p}{,} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}alias}\PYG{p}{,} \PYG{n}{start\PYGZus{}comp}\PYG{p}{,} \PYG{n}{num\PYGZus{}comps}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the first integer parameter is the starting component in the original
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} that will become component 0 in the alias \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and
the second integer parameter is the number of components in the alias. It’s a
runtime error if the sum of the two integer parameters is greater than the
number of the components in the original MultiFab. Note that the alias MultiFab
has exactly the same number of ghost cells as the original MultiFab.

\sphinxAtStartPar
We often need to build new MultiFabs that have the same \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} as a given MultiFab.  Below is an example of how to
achieve this.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// mf0 is an already defined MultiFab}
\PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{ba} \PYG{o}{=} \PYG{n}{mf0}\PYG{p}{.}\PYG{n}{boxArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{dm} \PYG{o}{=} \PYG{n}{mf0}\PYG{p}{.}\PYG{n}{DistributionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{n}{mf0}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ngrow} \PYG{o}{=} \PYG{n}{mf0}\PYG{p}{.}\PYG{n}{nGrow}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{mf1}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,}\PYG{n}{dm}\PYG{p}{,}\PYG{n}{ncomp}\PYG{p}{,}\PYG{n}{ngrow}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// new MF with the same ncomp and ngrow}
\PYG{n}{MultiFab} \PYG{n+nf}{mf2}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,}\PYG{n}{dm}\PYG{p}{,}\PYG{n}{ncomp}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// new MF with no ghost cells}
\PYG{c+c1}{// new MF with 1 component and 2 ghost cells}
\PYG{n}{MultiFab} \PYG{n+nf}{mf3}\PYG{p}{(}\PYG{n}{mf0}\PYG{p}{.}\PYG{n}{boxArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mf0}\PYG{p}{.}\PYG{n}{DistributionMap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we have repeatedly mentioned in this chapter that \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} have various index types. Thus, \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} also has an
index type that is obtained from the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} used for defining the
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}. It should be noted again that index type is a very important
concept in AMReX. Let’s consider an example of a finite\sphinxhyphen{}volume code, in which
the state is defined as cell averaged variables and the fluxes are defined as
face averaged variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// ba is cell\PYGZhy{}centered BoxArray}
\PYG{c+c1}{// dm is DistributionMapping}
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}  \PYG{c+c1}{// Suppose the system has 3 components}
\PYG{k+kt}{int} \PYG{n}{ngrow} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}  \PYG{c+c1}{// no ghost cells}
\PYG{n}{MultiFab} \PYG{n+nf}{state}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{ngrow}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{xflux}\PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{yflux}\PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{zflux}\PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here all \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s  use the same \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}, but their
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}s have different index types. The state is cell\sphinxhyphen{}based, whereas
the fluxes are on the faces. Suppose the cell based \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} contains a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{punctuation}{\{(}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{),} \DUrole{punctuation}{(}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{31}\DUrole{punctuation}{)\}}}}. The state on that \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} is conceptually
a Fortran Array with the dimension of \sphinxcode{\sphinxupquote{\DUrole{punctuation}{(}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{31}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{0}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{2}\DUrole{punctuation}{)}}}. The
fluxes are arrays with slightly different indices. For example, the
\(x\)\sphinxhyphen{}direction flux for that \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} has the dimension of
\sphinxcode{\sphinxupquote{\DUrole{punctuation}{(}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{15}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{16}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{31}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{0}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{2}\DUrole{punctuation}{)}}}. Note there is an extra element in
\(x\)\sphinxhyphen{}direction.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} class provides many functions performing common arithmetic
operations on a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} or between \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s  built with the
\sphinxstyleemphasis{same} \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMap}}}.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n}{dmin} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{min}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Minimum value in component 3 of MultiFab mf}
                         \PYG{c+c1}{// no ghost cells included}
\PYG{n}{Real} \PYG{n}{dmax} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{max}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Maximum value in component 3 of MultiFab mf}
                         \PYG{c+c1}{// including 1 ghost cell}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}          \PYG{c+c1}{// Set all values to zero including ghost cells}

\PYG{n}{MultiFab}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(}\PYG{n}{mfdst}\PYG{p}{,} \PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{sc}\PYG{p}{,} \PYG{n}{dc}\PYG{p}{,} \PYG{n}{nc}\PYG{p}{,} \PYG{n}{ng}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Add mfsrc to mfdst}
\PYG{n}{MultiFab}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Copy}\PYG{p}{(}\PYG{n}{mfdst}\PYG{p}{,} \PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{sc}\PYG{p}{,} \PYG{n}{dc}\PYG{p}{,} \PYG{n}{nc}\PYG{p}{,} \PYG{n}{ng}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Copy from mfsrc to mfdst}
\PYG{c+c1}{// MultiFab mfdst: destination}
\PYG{c+c1}{// MultiFab mfsrc: source}
\PYG{c+c1}{// int      sc   : starting component index in mfsrc for this operation}
\PYG{c+c1}{// int      dc   : starting component index in mfdst for this operation}
\PYG{c+c1}{// int      nc   : number of components for this operation}
\PYG{c+c1}{// int      ng   : number of ghost cells involved in this operation}
\PYG{c+c1}{//                 mfdst and mfsrc may have more ghost cells}
\end{sphinxVerbatim}

\sphinxAtStartPar
We refer the reader to \sphinxcode{\sphinxupquote{amrex/Src/Base/AMReX\_MultiFab.H}} and
\sphinxcode{\sphinxupquote{amrex/Src/Base/AMReX\_FabArray.H}} for more details. It should be noted again
it is a runtime error if the two \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s  passed to functions like
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{Copy}}} are not built with the \sphinxstyleemphasis{same} \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} (including
index type) and \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}.

\sphinxAtStartPar
It is usually the case that the Boxes in the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} used for building
a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} are non\sphinxhyphen{}intersecting except that they can be overlapping due
to nodal index type. However, \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} can have ghost cells, and in that
case FArrayBoxes are defined on Boxes larger than the Boxes in the
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}.  Parallel communication is then needed to fill the ghost cells
with valid cell data from other FArrayBoxes possibly on other parallel
processes. The function for performing this type of communication is
\sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MultiFab} \PYG{n+nf}{mf}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{n}{parameters} \PYG{n}{omitted}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Geometry} \PYG{n+nf}{geom}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{n}{parameters} \PYG{n}{omitted}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                    \PYG{c+c1}{// Fill ghost cells for all components}
                                      \PYG{c+c1}{// Periodic boundaries are not filled.}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Fill ghost cells for all components}
                                      \PYG{c+c1}{// Periodic boundaries are filled.}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Fill 3 components starting from component 2}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} does not modify any valid cells. Also note that
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} itself does not have the concept of periodic boundary, but
\sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} has, and we can provide that information so that periodic
boundaries can be filled as well. You might have noticed that a ghost cell
could overlap with multiple valid cells from different FArrayBoxes in the case
of nodal index type. In that case, it is unspecified that which valid cell’s
value is used to fill the ghost cell. It ought to be the case the values in
those overlapping valid cells are the same up to roundoff errors.  If
a ghost cell does not overlap with any valid cells, its value will not
be modified by \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}}.

\sphinxAtStartPar
Another type of parallel communication is copying data from one \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}
to another \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with a different \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} or the same
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} with a different \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}. The data copy is
performed on the regions of intersection. The most generic interface for this
is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mfdst}\PYG{p}{.}\PYG{n}{ParallelCopy}\PYG{p}{(}\PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{compsrc}\PYG{p}{,} \PYG{n}{compdst}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{ngsrc}\PYG{p}{,} \PYG{n}{ngdst}\PYG{p}{,} \PYG{n}{period}\PYG{p}{,} \PYG{n}{op}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{\DUrole{name}{mfdst}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{mfsrc}}} are destination and source MultiFabs,
respectively. Parameters \sphinxcode{\sphinxupquote{\DUrole{name}{compsrc}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{compdst}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{ncomp}}} are
integers specifying the range of components. The copy is performed on
\sphinxcode{\sphinxupquote{\DUrole{name}{ncomp}}} components starting from component \sphinxcode{\sphinxupquote{\DUrole{name}{compsrc}}} of \sphinxcode{\sphinxupquote{\DUrole{name}{mfsrc}}}
and component \sphinxcode{\sphinxupquote{\DUrole{name}{compdst}}} of \sphinxcode{\sphinxupquote{\DUrole{name}{mfdst}}}. Parameters \sphinxcode{\sphinxupquote{\DUrole{name}{ngsrc}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{ngdst}}} specify the number of ghost cells involved for the source and
destination, respectively. Parameter \sphinxcode{\sphinxupquote{\DUrole{name}{period}}} is optional, and by default
no periodic copy is performed. Like \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}}, one can use
\sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}\DUrole{operator}{::}\DUrole{name}{periodicity}\DUrole{punctuation}{()}}} to provide the periodicity information. The last
parameter is also optional and is set to \sphinxcode{\sphinxupquote{\DUrole{name}{FabArrayBase}\DUrole{operator}{::}\DUrole{name}{COPY}}} by default.
One could also use \sphinxcode{\sphinxupquote{\DUrole{name}{FabArrayBase}\DUrole{operator}{::}\DUrole{name}{ADD}}}. This determines whether the
function copies or adds data from the source to the
destination. Similar to \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}}, if a destination cell has
multiple cells as source, it is unspecified that which source cell is used in
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArrayBase}\DUrole{operator}{::}\DUrole{name}{COPY}}}, and, for \sphinxcode{\sphinxupquote{\DUrole{name}{FabArrayBase}\DUrole{operator}{::}\DUrole{name}{ADD}}}, the multiple
values are all added to the destination cell.  This function has two
variants, in which the periodicity and operation type are also optional.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mfdst}\PYG{p}{.}\PYG{n}{ParallelCopy}\PYG{p}{(}\PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{period}\PYG{p}{,} \PYG{n}{op}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// mfdst and mfsrc must have the same}
                                        \PYG{c+c1}{// number of components}
\PYG{n}{mfdst}\PYG{p}{.}\PYG{n}{ParallelCopy}\PYG{p}{(}\PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{compsrc}\PYG{p}{,} \PYG{n}{compdst}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{period}\PYG{p}{,} \PYG{n}{op}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the number of ghost cells involved is zero, and the copy is performed on
all components if unspecified (assuming the two MultiFabs have the same number
of components).

\sphinxAtStartPar
Both \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelCopy}\DUrole{punctuation}{(…)}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}\DUrole{punctuation}{(…)}}} are blocking calls. They
will only return when the communication is completed and the destination MultiFab is
guaranteed to be properly updated.  AMReX also provides non\sphinxhyphen{}blocking versions of
these calls to allow users to overlap communication with calculation and potentially
improve overall application performance.

\sphinxAtStartPar
The non\sphinxhyphen{}blocking calls are used by calling the \sphinxcode{\sphinxupquote{\DUrole{operator}{***}\DUrole{name}{\_nowait}\DUrole{punctuation}{(…)}}} function
to begin the comm operation, followed by the \sphinxcode{\sphinxupquote{\DUrole{operator}{***}\DUrole{name}{\_finish}\DUrole{punctuation}{()}}} function at a later
time to complete it. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mfA}\PYG{p}{.}\PYG{n}{ParallelCopy\PYGZus{}nowait}\PYG{p}{(}\PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{period}\PYG{p}{,} \PYG{n}{op}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// ... Any overlapping calc work here on other data, e.g.}
\PYG{n}{mfB}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{mfA}\PYG{p}{.}\PYG{n}{ParallelCopy\PYGZus{}finish}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{mfB}\PYG{p}{.}\PYG{n}{FillBoundary\PYGZus{}nowait}\PYG{p}{(}\PYG{n}{period}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// ... Overlapping work here}
\PYG{n}{mfB}\PYG{p}{.}\PYG{n}{FillBoundary\PYGZus{}finish}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
All function signatures of the blocking calls are also available in the non\sphinxhyphen{}blocking
calls and should be used in the \sphinxtitleref{nowait} function.  The \sphinxtitleref{finish} functions take no
parameters, as the required data is stored during \sphinxtitleref{nowait} and retrieved.  Users that
choose to use non\sphinxhyphen{}blocking calls must ensure the calls are properly used to avoid race
conditions, which typically means not interacting with the MultiFab between the
\sphinxcode{\sphinxupquote{\DUrole{name}{\_nowait}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{\_finish}}} calls.


\section{MFIter and Tiling}
\label{\detokenize{Basics:mfiter-and-tiling}}\label{\detokenize{Basics:sec-basics-mfiter}}
\sphinxAtStartPar
In this section, we will first show how \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} works without tiling.
Then we will introduce the concept of logical tiling.  Finally we will show how
logical tiling can be launched via \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}.


\subsection{MFIter without Tiling}
\label{\detokenize{Basics:mfiter-without-tiling}}\label{\detokenize{Basics:sec-basics-mfiter-notiling}}
\sphinxAtStartPar
In the section on {\hyperref[\detokenize{Basics:sec-basics-multifab}]{\sphinxcrossref{\DUrole{std,std-ref}{FabArray, MultiFab and iMultiFab}}}}, we have shown some of the
arithmetic functionalities of \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, such as adding two MultiFabs
together. In this section, we will show how you can operate on the
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} data with your own functions. AMReX provides an iterator,
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} for looping over the FArrayBoxes in MultiFabs. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{c+c1}{// Loop over grids}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// This is the valid Box of the current FArrayBox.}
    \PYG{c+c1}{// By \PYGZdq{}valid\PYGZdq{}, we mean the original ungrown Box in BoxArray.}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// A reference to the current FArrayBox in this loop iteration.}
    \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Obtain Array4 from FArrayBox.  We can also do}
    \PYG{c+c1}{//     Array4\PYGZlt{}Real\PYGZgt{} const\PYGZam{} a = mf.array(mfi);}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a} \PYG{o}{=} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Call function f1 to work on the region specified by box.}
    \PYG{c+c1}{// Note that the whole region of the Fab includes ghost}
    \PYG{c+c1}{// cells (if there are any), and is thus larger than or}
    \PYG{c+c1}{// equal to \PYGZdq{}box\PYGZdq{}.}
    \PYG{n}{f1}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here function \sphinxcode{\sphinxupquote{\DUrole{name}{f1}}} might be something like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{f1} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{k}{auto} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{lbound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{k}{auto} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{ubound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for}     \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
     \PYG{k}{for}   \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
       \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} only loops over grids owned by this process. For example, suppose
there are 5 Boxes in total and processes 0 and 1 own 2 and 3 Boxes,
respectively. That is the MultiFab on process 0 has 2 FArrayBoxes, whereas
there are 3 FArrayBoxes on process 1. Thus the numbers of iterations of MFIter
are 2 and 3 on processes 0 and 1, respectively.

\sphinxAtStartPar
In the example above, \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} is assumed to have a single
component. If it has multiple components, we can call \sphinxcode{\sphinxupquote{int nc =
mf.nComp()}} or \sphinxcode{\sphinxupquote{int nc = a.nComp()}} to get the number of components.

\sphinxAtStartPar
There is only one \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} in the example above. Below is an example of
working with multiple MultiFabs. Note that these two MultiFabs are not
necessarily built on the same \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}.  But they must have the same
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}, and their BoxArrays are typically related (e.g.,
they are different due to index types).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// U and F are MultiFabs}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{F}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{c+c1}{// Loop over grids}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{u} \PYG{o}{=} \PYG{n}{U}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}      \PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{f} \PYG{o}{=} \PYG{n}{F}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{f2}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here function \sphinxcode{\sphinxupquote{\DUrole{name}{f2}}} might be something like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{f1} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{,}
         \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{k}{auto} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{lbound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{k}{auto} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{ubound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{nf} \PYG{o}{=} \PYG{n}{f}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{nf}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
     \PYG{k}{for}     \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{k}{for}   \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
           \PYG{n}{f}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{u}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
         \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
     \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{MFIter with Tiling}
\label{\detokenize{Basics:mfiter-with-tiling}}\label{\detokenize{Basics:sec-basics-mfiter-tiling}}
\sphinxAtStartPar
Tiling, also known as cache blocking, is a well known loop transformation
technique for improving data locality.  This is often done by transforming the
loops into tiling loops that iterate over tiles and element loops that iterate
over the data elements within a tile. For example, the original loops might
look like this in Fortran

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{do }\PYG{n}{k} \PYG{o}{=} \PYG{n}{kmin}\PYG{p}{,} \PYG{n}{kmax}
  \PYG{k}{do }\PYG{n}{j} \PYG{o}{=} \PYG{n}{jmin}\PYG{p}{,} \PYG{n}{jmax}
    \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{n}{imin}\PYG{p}{,} \PYG{n}{imax}
      \PYG{n}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZam{}}
                \PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0d0}\PYG{o}{*}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
    \PYG{k}{end }\PYG{k}{do}
\PYG{k}{  }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{end }\PYG{k}{do}
\end{sphinxVerbatim}

\sphinxAtStartPar
And the manually tiled loops might look like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jblocksize} \PYG{o}{=} \PYG{l+m+mi}{11}
\PYG{n}{kblocksize} \PYG{o}{=} \PYG{l+m+mi}{16}
\PYG{n}{jblocks} \PYG{o}{=} \PYG{p}{(}\PYG{n}{jmax}\PYG{o}{\PYGZhy{}}\PYG{n}{jmin}\PYG{o}{+}\PYG{n}{jblocksize}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{jblocksize}
\PYG{n}{kblocks} \PYG{o}{=} \PYG{p}{(}\PYG{n}{kmax}\PYG{o}{\PYGZhy{}}\PYG{n}{kmin}\PYG{o}{+}\PYG{n}{kblocksize}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{kblocksize}
\PYG{k}{do }\PYG{n}{kb} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{kblocks}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
  \PYG{k}{do }\PYG{n}{jb} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{jblocks}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{do }\PYG{n}{k} \PYG{o}{=} \PYG{n}{kb}\PYG{o}{*}\PYG{n}{kblocksize}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kb}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{kblocksize}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{kmax}\PYG{p}{)}
      \PYG{k}{do }\PYG{n}{j} \PYG{o}{=} \PYG{n}{jb}\PYG{o}{*}\PYG{n}{jblocksize}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{p}{(}\PYG{n}{jb}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{jblocksize}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{jmax}\PYG{p}{)}
        \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{n}{imin}\PYG{p}{,} \PYG{n}{imax}
          \PYG{n}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZam{}}
                    \PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{+}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.0d0}\PYG{o}{*}\PYG{n}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
        \PYG{k}{end }\PYG{k}{do}
\PYG{k}{      }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{    }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{  }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{end }\PYG{k}{do}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we can see, to manually tile individual loops is very labor\sphinxhyphen{}intensive and
error\sphinxhyphen{}prone for large applications. AMReX has incorporated the tiling construct
into \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} so that the application codes can get the benefit of tiling
easily. An \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop with tiling is almost the same as the non\sphinxhyphen{}tiling
version. The first example in (see the previous section on
{\hyperref[\detokenize{Basics:sec-basics-mfiter-notiling}]{\sphinxcrossref{\DUrole{std,std-ref}{MFIter without Tiling}}}}) requires only two minor changes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
passing \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{true}}} when defining \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} to indicate tiling;

\item {} 
\sphinxAtStartPar
calling \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}} instead of \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}} to obtain the work region
for the loop iteration.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//               * true *  turns on tiling}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{c+c1}{// Loop over tiles}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//                   tilebox() instead of validbox()}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a} \PYG{o}{=} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f1}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The second example in the previous section on {\hyperref[\detokenize{Basics:sec-basics-mfiter-notiling}]{\sphinxcrossref{\DUrole{std,std-ref}{MFIter without Tiling}}}}
also requires only two minor changes.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//              * true *  turns on tiling}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{F}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{c+c1}{// Loop over tiles}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//                   tilebox() instead of validbox()}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{u} \PYG{o}{=} \PYG{n}{U}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}      \PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{f} \PYG{o}{=} \PYG{n}{F}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f2}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The kernels functions like \sphinxcode{\sphinxupquote{\DUrole{name}{f1}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{f2}}} in the two examples here
usually require very little changes.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Comparison of \sphinxstyleliteralintitle{\sphinxupquote{MFIter}} with (right) and without (left) tiling.}\label{\detokenize{Basics:id3}}\label{\detokenize{Basics:fig-basics-cc-comparison}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{cc_validbox}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{cc_tilebox}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] Example of cell\sphinxhyphen{}centered valid boxes.
\item[] There are two valid boxes in this example.
\item[] Each has \(8^2\) cells.
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] Example of cell\sphinxhyphen{}centered tile boxes. Each grid
\item[] is \sphinxstyleemphasis{logically} broken into 4 tiles, and each tile
\item[] as \(4^2\) cells. There are 8 tiles in total.
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\hyperref[\detokenize{Basics:fig-basics-cc-comparison}]{Table \ref{\detokenize{Basics:fig-basics-cc-comparison}}} shows an example of the difference between
\sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}}. In this example, there are two grids of
cell\sphinxhyphen{}centered index type. The function \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}} always returns a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} for the valid region of an \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} no matter whether or not
tiling is enabled, whereas the function \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}} returns a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} for
a tile. (Note that when tiling is disabled, \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}} returns the same
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} as \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}}.) The number of loop iteration is 2 in the
non\sphinxhyphen{}tiling version, whereas in the tiling version the kernel function is called
8 times.

\sphinxAtStartPar
It is important to use the correct \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} when implementing tiling, especially
if the box is used to define a work region inside of the loop. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// MFIter loop with tiling on.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Box} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Gets box of entire, untiled region.}
    \PYG{n}{calcOverBox}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{// ERROR! Works on entire box, not tiled box.}
                                 \PYG{c+c1}{// Other iterations will redo many of the same cells.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The tile size can be explicitly set when defining \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// No tiling in x\PYGZhy{}direction. Tile size is 16 for y and 32 for z.}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{IntVect}\PYG{p}{(}\PYG{l+m+mi}{1024000}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
An \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} is used to specify the tile size for every dimension.  A tile
size larger than the grid size simply means tiling is disabled in that
direction. AMReX has a default tile size \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}\DUrole{punctuation}{\{}\DUrole{literal,number,integer}{1024000}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{,}\DUrole{literal,number,integer}{8}\DUrole{punctuation}{\}}}} in 3D and
no tiling in 2D. This is used when tile size is not explicitly set but the
tiling flag is on. One can change the default size using \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}}
(section {\hyperref[\detokenize{Basics:sec-basics-parmparse}]{\sphinxcrossref{\DUrole{std,std-ref}{ParmParse}}}}) parameter \sphinxcode{\sphinxupquote{fabarray.mfiter\_tile\_size.}}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Comparison of \sphinxstyleliteralintitle{\sphinxupquote{MFIter}} with (right) and without (left) tiling, for face\sphinxhyphen{}centered nodal indexing.}\label{\detokenize{Basics:id4}}\label{\detokenize{Basics:fig-basics-ec-comparison}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{ec_validbox}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{ec_tilebox}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] Example of face valid boxes. There are two
\item[] valid boxes in this example. Each has
\item[] \(9\times 8\) points. Note that points in one
\item[] \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} may overlap with points in the other
\item[] \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. However, the memory locations for
\item[] storing floating point data of those points do
\item[] not overlap, because they belong to separate
\item[] FArrayBoxes.
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] Example of face tile boxes. Each grid is
\item[] \sphinxstyleemphasis{logically} broken into 4 tiles as indicated by
\item[] the symbols. There are 8 tiles in total. Some
\item[] tiles have \(5\times 4\) points, whereas
\item[] others have \(4 \times 4\) points. Points from
\item[] different Boxes may overlap, but points from
\item[] different tiles of the same Box do not.
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Dynamic tiling, which runs one box per OpenMP thread, is also available.
This is useful when the underlying work cannot benefit from thread
parallelization.  Dynamic tiling is implemented using the \sphinxcode{\sphinxupquote{\DUrole{name}{MFItInfo}}}
object and requires the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop to be defined in an OpenMP
parallel region:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Dynamic tiling, one box per OpenMP thread.}
\PYG{c+c1}{// No further tiling details,}
\PYG{c+c1}{//   so each thread works on a single tilebox.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{MFItInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{SetDynamic}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Dynamic tiling also allows explicit definition of a tile size:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Dynamic tiling, one box per OpenMP thread.}
\PYG{c+c1}{// No tiling in x\PYGZhy{}direction. Tile size is 16 for y and 32 for z.}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{MFItInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{SetDynamic}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{.}\PYG{n}{EnableTiling}\PYG{p}{(}\PYG{l+m+mi}{1024000}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Usually \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} is used for accessing multiple MultiFabs like the second
example, in which two MultiFabs, \sphinxcode{\sphinxupquote{\DUrole{name}{U}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{F}}}, use \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} via
\sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}}. These different MultiFabs may have different BoxArrays. For
example, \sphinxcode{\sphinxupquote{\DUrole{name}{U}}} might be cell\sphinxhyphen{}centered, whereas \sphinxcode{\sphinxupquote{\DUrole{name}{F}}} might be nodal in
\(x\)\sphinxhyphen{}direction and cell in other directions. The \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}\DUrole{operator}{::}\DUrole{name}{validbox}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}} functions return Boxes of the same type as the
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} used in defining the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} (\sphinxcode{\sphinxupquote{\DUrole{name}{F}}} in this example).
\hyperref[\detokenize{Basics:fig-basics-ec-comparison}]{Table \ref{\detokenize{Basics:fig-basics-ec-comparison}}} illustrates an example of non\sphinxhyphen{}cell\sphinxhyphen{}centered
valid and tile boxes. Besides \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}
has a number of functions returning various Boxes.  Examples include,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{fabbox}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}       \PYG{c+c1}{// Return the Box of the FArrayBox}

\PYG{c+c1}{// Return grown tile box.  By default it grows by the number of}
\PYG{c+c1}{// ghost cells of the MultiFab used for defining the MFIter.}
\PYG{n}{Box} \PYG{n+nf}{growntilebox}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ng}\PYG{o}{=}\PYG{l+m+mi}{\PYGZhy{}1000000}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// Return tilebox with provided nodal flag as if the MFIter}
\PYG{c+c1}{// is constructed with MultiFab of such flag.}
\PYG{n}{Box} \PYG{n+nf}{tilebox}\PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{nodal\PYGZus{}flag}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be noted that the function \sphinxcode{\sphinxupquote{\DUrole{name}{growntilebox}}} does not grow the tile
Box like a normal \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}. Growing a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} normally means the Box is
extended in every face of every dimension.  However, the function
\sphinxcode{\sphinxupquote{\DUrole{name}{growntilebox}}} only extends the tile Box in such a way that tiles from the
same grid do not overlap. This is the basic design principle of these various
tiling functions. Tiling is a way of domain decomposition for work sharing.
Overlapping tiles is undesirable because work would be wasted and for
multi\sphinxhyphen{}threaded codes race conditions could occur.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Comparing growing cell\sphinxhyphen{}type and face\sphinxhyphen{}type tile boxes.}\label{\detokenize{Basics:id5}}\label{\detokenize{Basics:fig-basics-growbox-comparison}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{cc_growbox}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=0.900\linewidth]{{ec_growbox}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] Example of cell\sphinxhyphen{}centered grown tile boxes. As
\item[] indicated by symbols, there are 8 tiles and four
\item[] in each grid in this example. Tiles from the
\item[] same grid do not overlap. But tiles from
\item[] different grids may overlap.
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] Example of face type grown tile boxes. As
\item[] indicated by symbols, there are 8 tiles and four
\item[] in each grid in this example. Tiles from the
\item[] same grid do not overlap even though they
\item[] have face index type.
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\hyperref[\detokenize{Basics:fig-basics-growbox-comparison}]{Table \ref{\detokenize{Basics:fig-basics-growbox-comparison}}} illustrates an example of
\sphinxcode{\sphinxupquote{\DUrole{name}{growntilebox}}}. These functions in \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} return \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} by
value. There are three ways of using these functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// const\PYGZam{} to temporary object is legal}

\PYG{c+c1}{// Make a copy if Box needs to be modified later.}
\PYG{c+c1}{// Compilers can optimize away the temporary object.}
\PYG{n}{Box} \PYG{n}{bx2} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{bx2}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Box}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{bx3} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// bound to the return value}
\PYG{n}{bx3}\PYG{p}{.}\PYG{n}{enclosedCells}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
But \sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{operator}{\&} \DUrole{name}{bx} \DUrole{operator}{=} \DUrole{name}{mfi}\DUrole{punctuation}{.}\DUrole{name}{validbox}\DUrole{punctuation}{()}}} is not legal and will not compile.

\sphinxAtStartPar
Finally it should be emphasized that tiling should not be used when
running on GPUs because of kernel launch overhead.


\subsection{Multiple MFIters}
\label{\detokenize{Basics:multiple-mfiters}}
\sphinxAtStartPar
To avoid some common bugs, it is not allowed to have multiple active
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} objects like below by default.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi1}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi2}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}mfiter\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}mfiter\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf2}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The will results in an assertion failure at runtime.  To disable the
assertion, one could call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{old\PYGZus{}flag} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MFIter}\PYG{o}{:}\PYG{o}{:}\PYG{n}{allowMultipleMFIters}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{logical} \PYG{k+kd}{::} \PYG{n}{old\PYGZus{}flag}
\PYG{n}{old\PYGZus{}flag} \PYG{o}{=} \PYG{n}{amrex\PYGZus{}mfiter\PYGZus{}allow\PYGZus{}multiple}\PYG{p}{(}\PYG{p}{.}\PYG{n}{true}\PYG{p}{.}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Fortran and C++ Kernels}
\label{\detokenize{Basics:fortran-and-c-kernels}}\label{\detokenize{Basics:sec-basics-fortran}}
\sphinxAtStartPar
In the section on {\hyperref[\detokenize{Basics:sec-basics-mfiter}]{\sphinxcrossref{\DUrole{std,std-ref}{MFIter and Tiling}}}}, we have shown that a typical
pattern for working with MultiFabs is to use \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} to iterate over the
data. In each iteration, a kernel function is called to work on the data and
the work region is specified by a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}.  When tiling is used, the work
region is a tile. The tiling is logical in the sense that there is no data
layout transformation. The kernel function still gets the whole arrays in
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}es, even though it is supposed to work on a tile region of the
arrays.  We have shown examples of writing kernels in C++ in the
previous section.  Fortran is also often used for writing these kernels because of its
native multi\sphinxhyphen{}dimensional array support.  To C++, these kernel functions are
C functions, whose function signatures are typically declared in a header file
named \sphinxcode{\sphinxupquote{*\_f.H}} or \sphinxcode{\sphinxupquote{*\_F.H}}. We recommend the users to follow this convention.
Examples of these function declarations are as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}BLFort.H\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{k+kt}{void} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{n}{amrex\PYGZus{}real}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,}
            \PYG{k}{const} \PYG{n}{amrex\PYGZus{}real}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}
            \PYG{n}{amrex\PYGZus{}real}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

\sphinxAtStartPar
These Fortran functions take C pointers and view them
as multi\sphinxhyphen{}dimensional arrays of the shape specified by the additional integer
arguments.  Note that Fortran takes arguments by reference unless the
\sphinxcode{\sphinxupquote{\DUrole{keyword}{value}}} keyword is used. So an integer argument on the Fortran side
matches an integer pointer on the C++ side. Thanks to Fortran 2003, function
name mangling is easily achieved by declaring the Fortran function as
\sphinxcode{\sphinxupquote{\DUrole{keyword}{bind}\DUrole{punctuation}{(}\DUrole{name}{c}\DUrole{punctuation}{)}}}.

\sphinxAtStartPar
AMReX provides many macros for passing an FArrayBox’s data into Fortran/C. For
example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f}\PYG{p}{(}\PYG{n}{BL\PYGZus{}TO\PYGZus{}FORTRAN\PYGZus{}BOX}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{BL\PYGZus{}TO\PYGZus{}FORTRAN\PYGZus{}ANYD}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_BOX}}} takes a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} and provides two \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{operator}{*}}}
s specifying the lower and upper bounds of the Box.  \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_ANYD}}}
takes an \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} returned by \sphinxcode{\sphinxupquote{\DUrole{name}{mf}\DUrole{punctuation}{{[}}\DUrole{name}{mfi}\DUrole{punctuation}{{]}}}} and the preprocessor turns
it into \sphinxcode{\sphinxupquote{\DUrole{name}{Real} \DUrole{operator}{*}\DUrole{punctuation}{,} \DUrole{keyword,type}{int} \DUrole{operator}{*}\DUrole{punctuation}{,} \DUrole{keyword,type}{int} \DUrole{operator}{*}}}, where \sphinxcode{\sphinxupquote{\DUrole{name}{Real} \DUrole{operator}{*}}} is the data pointer
that matches real array argument in Fortran, the first \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{operator}{*}}} (which
matches an integer argument in Fortran) specifies the lower bounds, and the
second \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{operator}{*}}} the upper bounds of the spatial dimensions of the array.
An example of the Fortran function is shown below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{f}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{ulo}\PYG{p}{,} \PYG{n}{uhi}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
  \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}\PYG{k+kd}{::}\PYG{n}{u}\PYG{p}{(}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{f}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, the size of the integer arrays is 3, the maximal number of spatial
dimensions. If the actual spatial dimension is less than 3, the values in the
degenerate dimensions are set to zero. So the Fortran function interface does
not have to change according to the spatial dimensionality, and the bound of
the third dimension of the data array simply becomes \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{0}\DUrole{punctuation}{:}\DUrole{literal,number,integer}{0}}}. With the
data passed by \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_BOX}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_FORTRAN\_ANYD}}}, this
version of Fortran function interface works for any spatial dimensions. If one
wants to write a special version just for 2D and would like to use 2D arrays,
one can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{f2d}\PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{ulo}\PYG{p}{,} \PYG{n}{uhi}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
  \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}\PYG{k+kd}{::}\PYG{n}{u}\PYG{p}{(}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{f2d}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this does not require any changes in the C++ part, because when
C++ passes an integer pointer pointing to an array of three integers Fortran
can treat it as a 2\sphinxhyphen{}element integer array.

\sphinxAtStartPar
Another commonly used macro is \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN}}}. This macro takes an
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} and provides a real pointer for the floating point data array
and a number of integer scalars for the bounds.  However, the number of the
integers depends on the dimensionality.  More specifically, there are 6 and 4
integers for 2D and 3D, respectively. The first half of the integers are the
lower bounds for each spatial dimension and the second half the upper bounds.
For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{f2d}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ulo1}\PYG{p}{,} \PYG{n}{ulo2}\PYG{p}{,} \PYG{n}{uhi1}\PYG{p}{,} \PYG{n}{uhi2}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
  \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{ulo1}\PYG{p}{,} \PYG{n}{ulo2}\PYG{p}{,} \PYG{n}{uhi1}\PYG{p}{,} \PYG{n}{uhi2}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}\PYG{k+kd}{::}\PYG{n}{u}\PYG{p}{(}\PYG{n}{ulo1}\PYG{p}{:}\PYG{n}{uhi1}\PYG{p}{,}\PYG{n}{ulo2}\PYG{p}{:}\PYG{n}{uhi2}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{f2d}

\PYG{k}{subroutine }\PYG{n}{f3d}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ulo1}\PYG{p}{,} \PYG{n}{ulo2}\PYG{p}{,} \PYG{n}{ulo3}\PYG{p}{,} \PYG{n}{uhi1}\PYG{p}{,} \PYG{n}{uhi2}\PYG{p}{,} \PYG{n}{uhi3}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
  \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{ulo1}\PYG{p}{,} \PYG{n}{ulo2}\PYG{p}{,} \PYG{n}{ulo3}\PYG{p}{,} \PYG{n}{uhi1}\PYG{p}{,} \PYG{n}{uhi2}\PYG{p}{,} \PYG{n}{uhi3}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}\PYG{k+kd}{::}\PYG{n}{u}\PYG{p}{(}\PYG{n}{ulo1}\PYG{p}{:}\PYG{n}{uhi1}\PYG{p}{,}\PYG{n}{ulo2}\PYG{p}{:}\PYG{n}{uhi2}\PYG{p}{,}\PYG{n}{ulo3}\PYG{p}{:}\PYG{n}{uhi3}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{f3d}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here for simplicity we have omitted passing the tile Box.

\sphinxAtStartPar
Usually \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s  have multiple components. Thus we often also need to
pass the number of component into Fortran functions. We can obtain the number
by calling the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{nComp}\DUrole{punctuation}{()}}} function, and pass it to
Fortran.  We can also use the
\sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_FAB}}} macro that is similar to \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_ANYD}}}
except that it provides an additional \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{operator}{*}}} for the number of
components. The Fortran function matching \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_TO\_FORTRAN\_FAB}\DUrole{punctuation}{(}\DUrole{name}{fab}\DUrole{punctuation}{)}}} is then
like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{f}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ulo}\PYG{p}{,} \PYG{n}{uhi}\PYG{p}{,}\PYG{n}{nu}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
  \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nu}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}\PYG{k+kd}{::}\PYG{n}{u}\PYG{p}{(}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ulo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{uhi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nu}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{f}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is a potential type safety issue when calling Fortran functions
from C++.  If there is a mismatch between the function declaration on
the C++ side and the function definition in Fortran, the compiler
cannot catch it.  For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// function declaration}
\PYG{k}{extern} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{void} \PYG{n+nf}{f} \PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{o}{*} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{f}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{o}{!} \PYG{n}{Fortran} \PYG{n}{definition}
\PYG{n}{subroutine} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)} \PYG{n}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
    \PYG{n}{implicit} \PYG{n}{none}
    \PYG{n}{integer} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\PYG{n}{end} \PYG{n}{subroutine} \PYG{n}{f}
\end{sphinxVerbatim}

\sphinxAtStartPar
The code above will compile without errors even though the number of
arguments and types don’t match.

\sphinxAtStartPar
To help detect this kind of issues, AMReX provides a type check tool.
Note that it only works when GCC is used.  In the directory an AMReX
based code is compiled, type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{make typecheck}
\end{sphinxVerbatim}

\sphinxAtStartPar
Extra arguments used in a usual AMReX build (e.g., USE\_MPI=TRUE DIM=2)
can be added.  When it finishes, the output may look like,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Function my\PYGZus{}f in main\PYGZus{}F.H vs. Fortran procedure in f.f90}
\PYG{g+go}{    number of arguments 1 does NOT match 2.}
\PYG{g+go}{    arg \PYGZsh{}1: C type [\PYGZsq{}double\PYGZsq{}, \PYGZsq{}pointer\PYGZsq{}] does NOT match Fortran type (\PYGZsq{}INTEGER 4\PYGZsq{}, \PYGZsq{}pointer\PYGZsq{}, \PYGZsq{}x\PYGZsq{}).}
\PYG{g+go}{22 functions checked, 1 error(s) found.  More details can be found in tmp\PYGZus{}build\PYGZus{}dir/t/3d.gnu.DEBUG.EXE/amrex\PYGZus{}typecheck.ou.}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be noted that Fortran by default passes argument by
reference.  In the example output above, \sphinxcode{\sphinxupquote{pointer}} in \sphinxcode{\sphinxupquote{Fortran type
(\textquotesingle{}INTEGER 4\textquotesingle{}, \textquotesingle{}pointer\textquotesingle{}, \textquotesingle{}x\textquotesingle{})}} means it’s a reference to argument
(i.e., C pointer), not a Fortran pointer.

\sphinxAtStartPar
The type check tool has known limitations.  For a function to be
checked by the tool in the GNU make build system, the declaration must
be in a header file named \sphinxcode{\sphinxupquote{*\_f.H}} or \sphinxcode{\sphinxupquote{*\_F.H}}, and the header file
must be in the \sphinxcode{\sphinxupquote{CEXE\_headers}} make variable.  The headers are
preprocessed first by cpp as C language, and is then parsed by
pycparser (\sphinxurl{https://pypi.python.org/pypi/pycparser}) that needs to be
installed on your system.  Because pycparser is a C parser, C++ parts
of the headers (e.g., \sphinxcode{\sphinxupquote{\DUrole{keyword}{extern} \DUrole{literal,string}{“C”} \DUrole{punctuation}{\{}}}) need to be hidden with
macro \sphinxcode{\sphinxupquote{\DUrole{comment,preproc}{\#ifdef \_\_cplusplus}}}.  Headers like \sphinxcode{\sphinxupquote{AMReX\_BLFort.H}} can
be used as a C header, but most other AMReX headers cannot and should
be hidden by \sphinxcode{\sphinxupquote{\DUrole{comment,preproc}{\#ifdef \_\_cplusplus}}} if they are included.  More
details can be found at \sphinxcode{\sphinxupquote{amrex/Docs/Readme.typecheck}}.  Despite
these limitations, it is recommended to use the type check tool and
report issues to us.

\phantomsection\label{\detokenize{Basics:sec-basics-cppkernel}}
\sphinxAtStartPar
Although Fortran has native multi\sphinxhyphen{}dimensional array, we recommend
writing kernels in C++ because of performance portability for CPU and
GPU.  AMReX provides a multi\sphinxhyphen{}dimensional array type of syntax, similar
to Fortran, that is readable and easy to implement.  We have
demonstrated how to use \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} in previous sections.  Because
of its importance, we will summarize its basic usage again with the
example below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{f} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{FArrayBox} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{sfab}\PYG{p}{,} \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{dfab}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Dim3} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lbound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Dim3} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ubound}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{src} \PYG{o}{=} \PYG{n}{sfab}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}      \PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{dst} \PYG{o}{=} \PYG{n}{dfab2}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for}         \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for}     \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{AMREX\PYGZus{}PRAGMA\PYGZus{}SIMD}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{dst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{src}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{+}\PYG{n}{src}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{mf1}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mf2}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} and two \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}es are passed to a C++ kernel
function.  In the function, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{lbound}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ubound}}}
are called to get the start and end of the loops from \sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{operator}{::}\DUrole{name}{smallEnd}\DUrole{punctuation}{()}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{operator}{::}\DUrole{name}{bigEnd}}} of \sphinxcode{\sphinxupquote{bx}}.  Both functions return a
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Dim3}}}, a trivial type containing three integers.
The individual components are accessed by using \sphinxcode{\sphinxupquote{\DUrole{punctuation}{.}\DUrole{name}{x}}}, \sphinxcode{\sphinxupquote{\DUrole{punctuation}{.}\DUrole{name}{y}}} and
\sphinxcode{\sphinxupquote{\DUrole{punctuation}{.}\DUrole{name}{z}}}, as shown in the \sphinxcode{\sphinxupquote{\DUrole{keyword}{for}}} loops.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{::}\DUrole{name}{array}\DUrole{punctuation}{()}}} is called to obtain an \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} object that is
designed as an independent, \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{()}}} based accessor to the
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} data. \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} is an AMReX class that contains a
pointer to the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} data and two \sphinxcode{\sphinxupquote{\DUrole{name}{Dim3}}} structs that
contain the bounds of the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}.  The bounds are stored to
properly translate the three dimensional coordinates to the appropriate
location in the one\sphinxhyphen{}dimensional array.  \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}\textquotesingle{}s \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{()}}}
can also take a fourth integer to access across states of the
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}.  When AMReX is built for 1D or 2D, it can be used
by passing \sphinxtitleref{0} to the missing dimensions.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{AMREX\_PRAGMA\_SIMD}} macro is placed in the innermost loop to notify
the compiler that loop iterations are independent and it is safe to
vectorize the loop.  This should be done whenever possible to achieve the
best performance. Be aware: the macro generates a compiler dependent
pragma, so their exact effect on the resulting code is also compiler
dependent.  It should be emphasized that using the \sphinxcode{\sphinxupquote{AMREX\_PRAGMA\_SIMD}}
macro on loops that are not safe for vectorization may lead to errors,
so if unsure about the independence of the iterations of a
loop, test and verify before adding the macro.

\sphinxAtStartPar
These loops should usually use \sphinxcode{\sphinxupquote{\DUrole{name}{i} \DUrole{operator}{\textless{}=} \DUrole{name}{hi}\DUrole{punctuation}{.}\DUrole{name}{x}}}, not \sphinxcode{\sphinxupquote{\DUrole{name}{i} \DUrole{operator}{\textless{}} \DUrole{name}{hi}\DUrole{punctuation}{.}\DUrole{name}{x}}}, when
defining the loop bounds. If not, the highest index cells will be left out
of the calculation.


\section{ParallelFor}
\label{\detokenize{Basics:parallelfor}}\label{\detokenize{Basics:sec-basics-parallelfor}}
\sphinxAtStartPar
In the examples so far, we have explicitly written out the for loops
when we iterate over a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}.  AMReX also provides function
templates for writing these in a concise and performance portable way
like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel if (Gpu::notInLaunchRegion())}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mfa}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a} \PYG{o}{=} \PYG{n}{mfa}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{b} \PYG{o}{=} \PYG{n}{mfb}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{c} \PYG{o}{=} \PYG{n}{mfc}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{a}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelFor}}} takes two arguments.  The first argument is a
\sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} specifying the iteration index space, and the second
argument is a C++ lambda function that works on cell \sphinxcode{\sphinxupquote{\DUrole{punctuation}{(}\DUrole{name}{i}\DUrole{punctuation}{,}\DUrole{name}{j}\DUrole{punctuation}{,}\DUrole{name}{k}\DUrole{punctuation}{)}}}.
Variables a, b and c in the lambda function are captured by value from
the enclosing scope.  The code above is performance portable.  It
works with and without GPU support.  When AMReX is built with GPU support,
AMREX\_GPU\_DEVICE indicates that the lambda function is a device
function and \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelFor}}} launches a GPU kernel to do the work.
When it is built without GPU support, AMREX\_GPU\_DEVICE has no effects
whatsoever.  More details on \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelFor}}} will be presented in
section {\hyperref[\detokenize{GPU:sec-gpu-for}]{\sphinxcrossref{\DUrole{std,std-ref}{Launching C++ nested loops}}}}.  It should be emphasized that
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelFor}}} does not start an OpenMP parallel region.  The OpenMP parallel
region will be started by the pragma above the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop if it is
built with OpenMP and without enabling GPU.  Tiling is turned off if
GPU is enabled so that more parallelism is exposed to GPU kernels.
Also note that when tiling is off, \sphinxcode{\sphinxupquote{\DUrole{name}{tilbox}}} returns
\sphinxcode{\sphinxupquote{\DUrole{name}{validbox}}}.

\sphinxAtStartPar
There are other versions of \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelFor}}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 1D for loop}
\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 4D for loop}
\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,} \PYG{n}{numcomps}\PYG{p}{,}
            \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Ghost Cells}
\label{\detokenize{Basics:ghost-cells}}
\sphinxAtStartPar
AMReX uses a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} as a container for floating point data on
multiple Boxes at a single level of refinement. Each rectangular Box has its own boundaries
on the low and high side in each coordinate direction.
Each Box within a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} can have ghost cells for storing data outside
the Box’s valid region. This allows us to, e.g., perform stencil\sphinxhyphen{}type operations on
regular arrays. There are three basic types of boundaries:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
interior boundary

\item {} 
\sphinxAtStartPar
coarse/fine boundary

\item {} 
\sphinxAtStartPar
physical boundary

\end{enumerate}

\sphinxAtStartPar
Interior boundary is the border among the grid Boxes themselves.  For example,
in \hyperref[\detokenize{Basics:fig-basics-amrgrids}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-amrgrids}}}, the two blue grid Boxes on level 1 share an
interior boundary that is 10 cells long. For a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with ghost cells
on level 1, we can use the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{FillBoundary}}} function introduced in
the section on {\hyperref[\detokenize{Basics:sec-basics-multifab}]{\sphinxcrossref{\DUrole{std,std-ref}{FabArray, MultiFab and iMultiFab}}}} to fill ghost cells at the interior
boundary with valid cell data from other Boxes.  \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{FillBoundary}}}
can optionally fill periodic boundary ghost cells as well.

\sphinxAtStartPar
A coarse/fine boundary is the border between two AMR levels.
\sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} does not fill these ghost cells. These ghost cells on the
fine level need to be interpolated from the coarse level data.  This is a
subject that will be discussed in the section on {\hyperref[\detokenize{AmrCore:sec-amrcore-fillpatch}]{\sphinxcrossref{\DUrole{std,std-ref}{FillPatchUtil and Interpolater}}}}.

\sphinxAtStartPar
Note that periodic boundary is not considered a basic type in the discussion here because
after periodic transformation it becomes either interior boundary or
coarse/fine boundary.

\sphinxAtStartPar
The third type of boundary is the physical boundary at the physical domain.
Note that both coarse and fine AMR levels could have grids touching the
physical boundary. It is up to the application codes to properly fill the ghost
cells at the physical boundary. However, AMReX does provide support for some
common operations.  See the section on {\hyperref[\detokenize{Basics:sec-basics-boundary}]{\sphinxcrossref{\DUrole{std,std-ref}{Boundary Conditions}}}} for a
discussion on domain boundary conditions in general, including how to implement
physical (non\sphinxhyphen{}periodic) boundary conditions.


\section{Boundary Conditions}
\label{\detokenize{Basics:boundary-conditions}}\label{\detokenize{Basics:sec-basics-boundary}}
\sphinxAtStartPar
This section describes how to implement domain boundary conditions in AMReX.  A
ghost cell that is outside of the valid region can be thought of as either
“interior” (which includes periodic and coarse\sphinxhyphen{}fine ghost cells), or “physical”.
Physical boundary conditions can occur on domain boundaries and can
be characterized as inflow, outflow, slip/no\sphinxhyphen{}slip walls, etc., and are
ultimately linked to mathematical Dirichlet or Neumann conditions.

\sphinxAtStartPar
The basic idea behind physical boundary conditions is as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a \sphinxcode{\sphinxupquote{\DUrole{name}{BCRec}}} object, which is essentially a multidimensional
integer array of \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{2}\DUrole{operator}{*}\DUrole{name}{DIM}}} components. Each component defines a boundary
condition type for the lo/hi side of the domain, for each direction.  See
\sphinxcode{\sphinxupquote{amrex/Src/Base/AMReX\_BC\_TYPES.H}} for common physical and mathematical
types.  Below is an example of setting up a \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{name}{BCRec}\DUrole{operator}{\textgreater{}}}} for
multiple components before the call to ghost cell routines.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Set up BC; see ``amrex/Src/Base/AMReX\PYGZus{}BC\PYGZus{}TYPES.H`` for supported types}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BCRec}\PYG{o}{\PYGZgt{}} \PYG{n}{bc}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{idim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{idim} \PYG{o}{\PYGZlt{}} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{idim}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{isPeriodic}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setLo}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{,} \PYG{n}{BCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{int\PYGZus{}dir}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// interior}
            \PYG{n}{bc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setHi}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{,} \PYG{n}{BCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{int\PYGZus{}dir}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{bc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setLo}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{,} \PYG{n}{BCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{foextrap}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// first\PYGZhy{}order extrapolation}
            \PYG{n}{bc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setHi}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{,} \PYG{n}{BCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{foextrap}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{BCType}}} has the following types,
\begin{quote}
\begin{description}
\item[{int\_dir}] \leavevmode
\sphinxAtStartPar
Interior, including periodic boundary

\item[{ext\_dir}] \leavevmode
\sphinxAtStartPar
“External Dirichlet”. It is the user’s responsibility to write a routine
to fill ghost cells (more details below).

\item[{foextrap}] \leavevmode
\sphinxAtStartPar
“First Order Extrapolation”
First order extrapolation from last cell in interior.

\item[{reflect\_even}] \leavevmode
\sphinxAtStartPar
Reflection from interior cells with sign
unchanged, \(q(-i) = q(i)\).

\item[{reflect\_odd}] \leavevmode
\sphinxAtStartPar
Reflection from interior cells with sign
changed, \(q(-i) = -q(i)\).

\end{description}
\end{quote}

\item {} 
\sphinxAtStartPar
For external Dirichlet boundaries, the user needs to provide a
callable object like below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n+nc}{MyExtBCFill} \PYG{p}{\PYGZob{}}
    \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE}
    \PYG{k+kt}{void} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{iv}\PYG{p}{,} \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{dest}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{dcomp}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{numcomp}\PYG{p}{,}
                     \PYG{n}{GeometryData} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{geom}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,}
                     \PYG{k}{const} \PYG{n}{BCRec}\PYG{o}{*} \PYG{n}{bcr}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{bcomp}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{orig\PYGZus{}comp}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// external Dirichlet for cell iv}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, for the CPU build, the AMREX\_GPU\_DEVICE macro has no effect
whatsoever, whereas for the GPU build, this marks the operator as a GPU
device function.

\item {} 
\sphinxAtStartPar
It is the user’s responsibility to have a consistent definition of
what the ghost cells represent. A common option used in AMReX codes is to
fill the domain ghost cells with the value that lies on the boundary (as
opposed to another common option where the value in the ghost cell represents
an extrapolated value based on the boundary condition type). Then in our
stencil based “work” codes, we also pass in the \sphinxcode{\sphinxupquote{\DUrole{name}{BCRec}}} object and use
modified stencils near the domain boundary that know the value in the first
ghost cell represents the value on the boundary.

\end{itemize}

\sphinxAtStartPar
Depending on the level of complexity of your code, there are various options
for filling domain boundary ghost cells.

\sphinxAtStartPar
For single\sphinxhyphen{}level codes built from \sphinxcode{\sphinxupquote{amrex/Src/Base}} (excluding the
\sphinxcode{\sphinxupquote{amrex/Src/AmrCore}} and \sphinxcode{\sphinxupquote{amrex/Src/Amr}} source code directories), you will
have single\sphinxhyphen{}level MultiFabs filled with data in the valid region where you need
to fill the ghost cells on each grid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MultiFab} \PYG{n}{mf}\PYG{p}{;}
\PYG{n}{Geometry} \PYG{n}{geom}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BCRec}\PYG{o}{\PYGZgt{}} \PYG{n}{bc}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{time}\PYG{p}{;}

\PYG{c+c1}{// ...}

\PYG{c+c1}{// fills interior and periodic domain boundary ghost cells}
\PYG{n}{mf}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// fills physical domain boundary ghost cells for a cell\PYGZhy{}centered multifab}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{not} \PYG{n}{geom}\PYG{p}{.}\PYG{n}{isAllPeriodic}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{GpuBndryFuncFab}\PYG{o}{\PYGZlt{}}\PYG{n}{MyExtBCFill}\PYG{o}{\PYGZgt{}} \PYG{n}{bf}\PYG{p}{(}\PYG{n}{MyExtBCFill}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{PhysBCFunct}\PYG{o}{\PYGZlt{}}\PYG{n}{GpuBndryFuncFab}\PYG{o}{\PYGZlt{}}\PYG{n}{MyExtBCFill}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{physbcf}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{bc}\PYG{p}{,} \PYG{n}{bf}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{physbcf}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{nGrowVector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Memory Allocation}
\label{\detokenize{Basics:memory-allocation}}
\sphinxAtStartPar
Some constructors of \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}, etc. can take
an \sphinxcode{\sphinxupquote{\DUrole{name}{Arena}}} argument for memory allocation.  This is usually not
important for CPU codes, but very important for GPU codes.  We will
present more details in {\hyperref[\detokenize{GPU:sec-gpu-memory}]{\sphinxcrossref{\DUrole{std,std-ref}{Memory Allocation}}}} in Chapter GPU.

\sphinxAtStartPar
AMReX has a Fortran module, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mempool\_module}}} that can be used to
allocate memory for Fortran pointers. The reason that such a module exists in
AMReX is that memory allocation is often very slow in multi\sphinxhyphen{}threaded OpenMP
parallel regions. AMReX \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mempool\_module}}} provides a much faster
alternative approach, in which each thread has its own memory pool. Here are
examples of using the module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}mempool\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}allocate}\PYG{p}{,} \PYG{n}{amrex\PYGZus{}deallocate}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer}\PYG{p}{,} \PYG{k}{contiguous} \PYG{k+kd}{::} \PYG{n}{a}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{lo1}\PYG{p}{,} \PYG{n}{hi1}\PYG{p}{,} \PYG{n}{lo2}\PYG{p}{,} \PYG{n}{hi2}\PYG{p}{,} \PYG{n}{lo3}\PYG{p}{,} \PYG{n}{hi3}\PYG{p}{,} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c}{! lo1 = ...}
\PYG{c}{! a(lo1:hi1, lo2:hi2, lo3:hi3)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}allocate}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{lo1}\PYG{p}{,} \PYG{n}{hi1}\PYG{p}{,} \PYG{n}{lo2}\PYG{p}{,} \PYG{n}{hi2}\PYG{p}{,} \PYG{n}{lo3}\PYG{p}{,} \PYG{n}{hi3}\PYG{p}{)}
\PYG{c}{! b(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),lo(4):hi(4))}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}allocate}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{lo}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{)}
\PYG{c}{! ......}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}deallocate}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}deallocate}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The downside of this is we have to use \sphinxcode{\sphinxupquote{\DUrole{keyword}{pointer}}} instead of
\sphinxcode{\sphinxupquote{\DUrole{keyword}{allocatable}}}. This means we must explicitly free the memory via
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_deallocate}}} and we need to declare the pointers as
\sphinxcode{\sphinxupquote{\DUrole{keyword}{contiguous}}} for performance reason.  Also, we often
pass the Fortran pointer to a procedure with explicit array argument
to get rid of the pointerness completely.


\section{Abort, Assertion and Backtrace}
\label{\detokenize{Basics:abort-assertion-and-backtrace}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Abort}\DUrole{punctuation}{(}\DUrole{keyword}{const} \DUrole{keyword,type}{char} \DUrole{operator}{*} \DUrole{name}{message}\DUrole{punctuation}{)}}} is used to terminate a run usually
when something goes wrong. This function takes a message and writes it to
stderr. Files named like \sphinxcode{\sphinxupquote{Backtrace.1}} (where 1 means process 1)
are produced containing backtrace information of the call stack. In Fortran, we
can call \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_abort}}} from the \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_error\_module}}}, which
takes a Fortran character variable with assumed size (i.e., \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{len}\DUrole{operator}{=*}}})
as a message.  A \sphinxcode{\sphinxupquote{ParmParse}} runtime boolean parameter
\sphinxcode{\sphinxupquote{amrex.throw\_handling}} (which is defaulted to 0, i.e., \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{false}}})
can be set to 1 (i.e., \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{true}}}) so that AMReX will throw an
exception instead of aborting.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_ASSERT}}} is a macro that takes a Boolean expression. For debug build
(e.g., \sphinxcode{\sphinxupquote{DEBUG=TRUE}} using the GNU Make build system), if the expression at
runtime is evaluated to false, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Abort}}} will be called and the run
is thus terminated. For optimized build (e.g., \sphinxcode{\sphinxupquote{DEBUG=FALSE}} using the GNU
Make build system), the \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_ASSERT}}} statement is removed at compile
time and thus has no effect at runtime. We often use this as a means of putting
debug statement in the code without adding any extra cost for production runs.
For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMREX\PYGZus{}ASSERT}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{.}\PYG{n}{nGrow}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{mf2}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here for debug build we like to assert that \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab} \DUrole{name}{mf}}} has ghost cells
and it also has the same number of components as \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab} \DUrole{name}{mf2}}}. If we
always want the assertion, we can use \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_ALWAYS\_ASSERT}}}.  The
assertion macros have a \sphinxcode{\sphinxupquote{\_WITH\_MESSAGE}} variant that will print a
message when assertion fails.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMREX\PYGZus{}ASSERT\PYGZus{}WITH\PYGZus{}MESSAGE}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{.}\PYG{n}{boxArray}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n}{mf2}\PYG{p}{.}\PYG{n}{boxArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                          \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{These two mfs must have the same BoxArray}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Backtrace files are produced by AMReX signal handler by default when
segfault occurs or \sphinxcode{\sphinxupquote{Abort}} is called.  If the application does not
want AMReX to handle this, \sphinxcode{\sphinxupquote{ParmParse}} parameter
\sphinxtitleref{amrex.signal\_handling=0} can be used to disable it.


\section{Debugging}
\label{\detokenize{Basics:debugging}}\label{\detokenize{Basics:sec-basics-debugging}}
\sphinxAtStartPar
Debugging is an art.  Everyone has their own favorite method.  Here we
offer a few tips we have found to be useful.

\sphinxAtStartPar
To help debugging, AMReX handles various signals in the C standard
library raised in the runs.  This gives us a chance to print out more
information using Linux/Unix backtrace capability.  The signals
include seg fault, interruption by the user (control\sphinxhyphen{}c), assertion
errors, and floating point exceptions (NaNs, divided by zero and
overflow).  The handling of seg fault, assertion errors and
interruption by control\sphinxhyphen{}C are enabled by default.  Note that
\sphinxcode{\sphinxupquote{AMREX\_ASSERT()}} is only on when compiled with \sphinxcode{\sphinxupquote{DEBUG=TRUE}} or
\sphinxcode{\sphinxupquote{USE\_ASSERTION=TRUE}} in GNU make, or with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_BUILD\_TYPE=Debug}} or
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_ASSERTIONS=YES}} in CMake.  The trapping of floating point exceptions is not
enabled by default unless the code is compiled with \sphinxcode{\sphinxupquote{DEBUG=TRUE}} in GNU make, or with
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_BUILD\_TYPE=Debug}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_FPE=YES}} in CMake to turn on compiler flags
if supported.  Alternatively, one can always use runtime parameters to control the
handling of floating point exceptions: \sphinxcode{\sphinxupquote{amrex.fpe\_trap\_invalid}} for
NaNs, \sphinxcode{\sphinxupquote{amrex.fpe\_trap\_zero}} for division by zero and
\sphinxcode{\sphinxupquote{amrex.fpe\_trap\_overflow}} for overflow.  To more effectively trap the
use of uninitialized values, AMReX also initializes \sphinxcode{\sphinxupquote{FArrayBox}}s in
\sphinxcode{\sphinxupquote{MulitFab}}s and arrays allocated by \sphinxcode{\sphinxupquote{bl\_allocate}} to signaling NaNs when it is compiled
with \sphinxcode{\sphinxupquote{TEST=TRUE}} or \sphinxcode{\sphinxupquote{DEBUG=TRUE}} in GNU make, or with \sphinxcode{\sphinxupquote{\sphinxhyphen{}DCMAKE\_BUILD\_TYPE=Debug}} in CMake.
One can also control the setting for \sphinxcode{\sphinxupquote{FArrayBox}} using the runtime parameter, \sphinxcode{\sphinxupquote{fab.init\_snan}}.

\sphinxAtStartPar
One can get more information than the backtrace of the call stack by
instrumenting the code.  Here is an example.
You know the line \sphinxcode{\sphinxupquote{Real rho = state(cell,0);}} is causing a segfault.  You
could add a print statement before that.  But it might print out
thousands (or even millions) of line before it hits the segfault.  What
you could do is the following,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}AMReX\PYGZus{}BLBackTrace.H\PYGZgt{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ostringstream} \PYG{n}{ss}\PYG{p}{;}
\PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{state.box() = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{state}\PYG{p}{.}\PYG{n}{box}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cell = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cell}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}BACKTRACE\PYGZus{}PUSH}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{.}\PYG{n}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// PUSH takes std::string}

\PYG{n}{Real} \PYG{n}{rho} \PYG{o}{=} \PYG{n}{state}\PYG{p}{(}\PYG{n}{cell}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// state is a Fab, and cell is an IntVect.}

\PYG{n}{BL\PYGZus{}BACKTRACE\PYGZus{}POP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// One can omit this line.  In that case,}
                    \PYG{c+c1}{// there is an implicit POP when \PYGZdq{}PUSH\PYGZdq{} is}
                    \PYG{c+c1}{// out of scope.}
\end{sphinxVerbatim}

\sphinxAtStartPar
When it hits the segfault, you will only see the last pint out.

\sphinxAtStartPar
Writing a \sphinxcode{\sphinxupquote{MultiFab}} to disk with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Write}\PYG{p}{(}\PYG{k}{const} \PYG{n}{FabArray}\PYG{o}{\PYGZlt{}}\PYG{n}{FArrayBox}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{mf}\PYG{p}{,} \PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{name}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
in \sphinxcode{\sphinxupquote{AMReX\_VisMF.H}} and examining it with \sphinxcode{\sphinxupquote{Amrvis}} (section
{\hyperref[\detokenize{Visualization:sec-amrvis}]{\sphinxcrossref{\DUrole{std,std-ref}{Amrvis}}}}) can be helpful as well.  In
\sphinxcode{\sphinxupquote{AMReX\_MultiFabUtil.H}}, function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{print\PYGZus{}state}\PYG{p}{(}\PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{mf}\PYG{p}{,} \PYG{k}{const} \PYG{n}{IntVect}\PYG{o}{\PYGZam{}} \PYG{n}{cell}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
can output the data for a single cell.

\sphinxAtStartPar
Valgrind is one of our favorite debugging tools.  For MPI runs, one can
tell valgrind to output to different files for different processes.
For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{mpiexec \PYGZhy{}n 4 valgrind \PYGZhy{}\PYGZhy{}leak\PYGZhy{}check=yes \PYGZhy{}\PYGZhy{}track\PYGZhy{}origins=yes \PYGZhy{}\PYGZhy{}log\PYGZhy{}file=vallog.\PYGZpc{}p ./foo.exe ...}
\end{sphinxVerbatim}


\section{Breaking into Debuggers}
\label{\detokenize{Basics:breaking-into-debuggers}}
\sphinxAtStartPar
In order to break into debuggers and use modern IDEs, the backtrace signal handling described above needs to be disabled.

\sphinxAtStartPar
The following runtime options need to be set in order to prevent AMReX from catching the break signals before a debugger can attach to a crashing process:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{amrex.throw\PYGZus{}exception = 1}
\PYG{g+go}{amrex.signal\PYGZus{}handling = 0}
\end{sphinxVerbatim}

\sphinxAtStartPar
This default behavior can also be modified by applications, see for example \sphinxhref{https://github.com/Exawind/amr-wind/blob/84f81a990152f4f748c1ab0fa17c8c663e51df86/amr-wind/main.cpp\#L21}{this custom application initializer}.


\section{Example: HeatEquation\_EX1\_C}
\label{\detokenize{Basics:example-heatequation-ex1-c}}\label{\detokenize{Basics:sec-basics-heat1}}
\sphinxAtStartPar
We now present an example of solving the heat equation.  The source
code tree for the heat equation example is simple, as shown in
\hyperref[\detokenize{Basics:fig-basics-heat-flowchart}]{Fig.\@ \ref{\detokenize{Basics:fig-basics-heat-flowchart}}}. We recommend you study
\sphinxcode{\sphinxupquote{main.cpp}} and \sphinxcode{\sphinxupquote{advance.cpp}} to see some of the classes described
below in action.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4in]{{flowchart1}.png}
\caption{Diagram of the source code structure for the HeatEquation\_EX1\_C example.}\label{\detokenize{Basics:id6}}\label{\detokenize{Basics:fig-basics-heat-flowchart}}\end{figure}

\end{center}

\sphinxAtStartPar
Source code tree for the HeatEquation\_EX1\_C example
\begin{quote}
\begin{description}
\item[{amrex/Src/Base}] \leavevmode
\sphinxAtStartPar
Contains source code for single\sphinxhyphen{}level simulations.  Note that in
\sphinxcode{\sphinxupquote{amrex/Src}} there are many sub\sphinxhyphen{}directories, e.g., \sphinxcode{\sphinxupquote{Base}}, \sphinxcode{\sphinxupquote{Amr}},
\sphinxcode{\sphinxupquote{AmrCore}}, \sphinxcode{\sphinxupquote{LinearSolvers}}, etc.  In this tutorial the only source
code directory we need is \sphinxcode{\sphinxupquote{Base}}.

\item[{amrex/Tutorials/HeatEquation\_EX1\_C/Source}] \leavevmode
\sphinxAtStartPar
Contains the following source code specific to this tutorial:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Make.package}}: lists the source code files

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{main.cpp}}: contains the C++ \sphinxcode{\sphinxupquote{main}} function

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{myfunc.cpp}}: contains function \sphinxcode{\sphinxupquote{advance}} that advances
the solution by a time step, and function \sphinxcode{\sphinxupquote{init\_phi}} that
initializes the initial solution.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{myfunc.H}}: header file for C++ functions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mykernel.H}}: kernels functions called by \sphinxcode{\sphinxupquote{advance}} and \sphinxcode{\sphinxupquote{init\_phi}}.

\end{enumerate}

\item[{amrex/Tutorials/HeatEquation\_EX1\_C/Exec}] \leavevmode
\sphinxAtStartPar
This is where you build the code with make.  There is a GNUmakefile
and inputs file.

\end{description}
\end{quote}

\sphinxAtStartPar
Now we highlight a few key sections of the code.  In \sphinxcode{\sphinxupquote{main.cpp}} we
demonstrate how to read in parameters from the inputs file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// inputs parameters}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// ParmParse is way of reading inputs from the inputs file}
    \PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{;}

    \PYG{c+c1}{// We need to get n\PYGZus{}cell from the inputs file \PYGZhy{} this is the number of cells on each side of}
    \PYG{c+c1}{//   a square (or cubic) domain.}
    \PYG{n}{pp}\PYG{p}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{n\PYGZus{}cell}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{n\PYGZus{}cell}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// The domain is broken into boxes of size max\PYGZus{}grid\PYGZus{}size}
    \PYG{n}{pp}\PYG{p}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max\PYGZus{}grid\PYGZus{}size}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Default plot\PYGZus{}int to \PYGZhy{}1, allow us to set it to something else in the inputs file}
    \PYG{c+c1}{//  If plot\PYGZus{}int \PYGZlt{} 0 then no plot files will be writtenq}
    \PYG{n}{plot\PYGZus{}int} \PYG{o}{=} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
    \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot\PYGZus{}int}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{plot\PYGZus{}int}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Default nsteps to 10, allow us to set it to something else in the inputs file}
    \PYG{n}{nsteps} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{n}{pp}\PYG{p}{.}\PYG{n}{query}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nsteps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{nsteps}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{main.cpp}} we demonstrate how to define a \sphinxcode{\sphinxupquote{Box}} for the problem domain,
and then how to chop that \sphinxcode{\sphinxupquote{Box}} up into multiple boxes that define a
\sphinxcode{\sphinxupquote{BoxArray}}  We also define a \sphinxcode{\sphinxupquote{Geometry}} object that knows about the problem
domain, the physical coordinates of the box, and the periodicity:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// make BoxArray and Geometry}
\PYG{n}{BoxArray} \PYG{n}{ba}\PYG{p}{;}
\PYG{n}{Geometry} \PYG{n}{geom}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{n}{IntVect} \PYG{n+nf}{dom\PYGZus{}lo}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}       \PYG{l+m+mi}{0}\PYG{p}{,}        \PYG{l+m+mi}{0}\PYG{p}{,}        \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{IntVect} \PYG{n+nf}{dom\PYGZus{}hi}\PYG{p}{(}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Box} \PYG{n+nf}{domain}\PYG{p}{(}\PYG{n}{dom\PYGZus{}lo}\PYG{p}{,} \PYG{n}{dom\PYGZus{}hi}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Initialize the boxarray \PYGZdq{}ba\PYGZdq{} from the single box \PYGZdq{}domain\PYGZdq{}}
    \PYG{n}{ba}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Break up boxarray \PYGZdq{}ba\PYGZdq{} into chunks no larger than \PYGZdq{}max\PYGZus{}grid\PYGZus{}size\PYGZdq{} along a direction}
    \PYG{n}{ba}\PYG{p}{.}\PYG{n}{maxSize}\PYG{p}{(}\PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// This defines the physical box, [\PYGZhy{}1,1] in each direction.}
    \PYG{n}{RealBox} \PYG{n+nf}{real\PYGZus{}box}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{,}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{,}\PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                     \PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// periodic in all direction by default}
    \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{is\PYGZus{}periodic}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{c+c1}{// This defines a Geometry object}
    \PYG{n}{geom}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,}\PYG{n}{real\PYGZus{}box}\PYG{p}{,}\PYG{n}{CoordSys}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cartesian}\PYG{p}{,}\PYG{n}{is\PYGZus{}periodic}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{main.cpp}} we demonstrate how to build a \sphinxcode{\sphinxupquote{DistributionMapping}} from the
\sphinxcode{\sphinxupquote{BoxArray}}, and then build \sphinxcode{\sphinxupquote{MultiFabs}} with a desired number of components
and ghost cells associated with each grid:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Nghost = number of ghost cells for each array}
\PYG{k+kt}{int} \PYG{n}{Nghost} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Ncomp = number of components for each array}
\PYG{k+kt}{int} \PYG{n}{Ncomp}  \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// How Boxes are distributed among MPI processes}
\PYG{n}{DistributionMapping} \PYG{n+nf}{dm}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// we allocate two phi multifabs; one will store the old state, the other the new.}
\PYG{n}{MultiFab} \PYG{n+nf}{phi\PYGZus{}old}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{Ncomp}\PYG{p}{,} \PYG{n}{Nghost}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiFab} \PYG{n+nf}{phi\PYGZus{}new}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{Ncomp}\PYG{p}{,} \PYG{n}{Nghost}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We demonstrate how to build an array of face\sphinxhyphen{}based \sphinxcode{\sphinxupquote{MultiFabs}} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// build the flux multifabs}
\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{flux}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dir} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{dir} \PYG{o}{\PYGZlt{}} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{n}{dir}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// flux(dir) has one component, zero ghost cells, and is nodal in direction dir}
    \PYG{n}{BoxArray} \PYG{n}{edge\PYGZus{}ba} \PYG{o}{=} \PYG{n}{ba}\PYG{p}{;}
    \PYG{n}{edge\PYGZus{}ba}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{n}{dir}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{flux}\PYG{p}{[}\PYG{n}{dir}\PYG{p}{]}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{edge\PYGZus{}ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To access and/or modify data in a \sphinxcode{\sphinxupquote{MultiFab}} we use the \sphinxcode{\sphinxupquote{MFIter}}, where each
processor loops over grids it owns to access and/or modify data on that grid:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Initialize phi\PYGZus{}new by calling a Fortran routine.}
\PYG{c+c1}{// MFIter = MultiFab Iterator}
\PYG{k}{for} \PYG{p}{(} \PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{phi\PYGZus{}new}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi} \PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{vbx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{phiNew} \PYG{o}{=} \PYG{n}{phi\PYGZus{}new}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{vbx}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{init\PYGZus{}phi}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{phiNew}\PYG{p}{,}\PYG{n}{dx}\PYG{p}{,}\PYG{n}{prob\PYGZus{}lo}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the kernel function \sphinxcode{\sphinxupquote{init\_phi}} for initializing a single
cell is is \sphinxcode{\sphinxupquote{mykernel.H}}.  It’s marked with \sphinxtitleref{AMREX\_GPU\_DEVICE} to
make it a GPU device function, if it built with GPU support.  It’s
also marked with \sphinxtitleref{AMREX\_FORCE\_INLINE} for inlining.

\sphinxAtStartPar
Ghost cells are filled using the \sphinxcode{\sphinxupquote{FillBoundary}} function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Fill the ghost cells of each grid from the other grids}
\PYG{c+c1}{// includes periodic domain boundaries}
\PYG{n}{phi\PYGZus{}old}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\chapter{Gridding and Load Balancing}
\label{\detokenize{ManagingGridHierarchy_Chapter:gridding-and-load-balancing}}\label{\detokenize{ManagingGridHierarchy_Chapter:chap-managinggridhierarchy}}\label{\detokenize{ManagingGridHierarchy_Chapter::doc}}
\sphinxAtStartPar
AMReX provides a great deal of generality when it comes to how to decompose the
computational domain into individual logically rectangular grids, and how to distribute
those grids to MPI ranks.  We use the phrase “load balancing” here to refer to the combined process
of grid creation (and re\sphinxhyphen{}creation when regridding) and distribution of grids to MPI ranks.

\sphinxAtStartPar
Even for single\sphinxhyphen{}level calculations, AMReX provides the flexibility to have different size grids,
more than one grid per MPI rank, and different strategies for distributing the grids to MPI ranks.

\sphinxAtStartPar
For multi\sphinxhyphen{}level calculations, the same principles for load balancing apply as in single\sphinxhyphen{}level calculations,
but there is additional complexity in how to tag cells for refinement and how to create the
union of grids at levels \textgreater{} 0 where that union most likely does not cover the computational domain.

\sphinxAtStartPar
See {\hyperref[\detokenize{GridCreation:sec-grid-creation}]{\sphinxcrossref{\DUrole{std,std-ref}{Grid Creation}}}} for grids are created, i.e. how the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} on which
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFabs}}} will be built is defined at each level.

\sphinxAtStartPar
See {\hyperref[\detokenize{LoadBalancing:sec-load-balancing}]{\sphinxcrossref{\DUrole{std,std-ref}{Load Balancing}}}} for the strategies AMReX supports for distributing
grids to MPI ranks, i.e. defining the \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} with which
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFabs}}} at that level will be built.

\sphinxAtStartPar
We also note that we can create separate grids, and map them in different ways to MPI ranks, for
different types of data in a single calculation.  We refer to this as the “dual grid approach”
and the most common usage is to load balance mesh and particle data separately. See {\hyperref[\detokenize{DualGrid:sec-dual-grid}]{\sphinxcrossref{\DUrole{std,std-ref}{Dual Grid Approach}}}}
for more about this approach.

\sphinxAtStartPar
When running on multicore machines with OpenMP, we can also control the distribution of
work by setting the size of grid tiles (by defining \sphinxcode{\sphinxupquote{\DUrole{name}{fabarray\_mfiter}\DUrole{punctuation}{.}\DUrole{name}{tile\_size}}}), and if relevant, of
particle tiles (by defining \sphinxcode{\sphinxupquote{\DUrole{name}{particle}\DUrole{punctuation}{.}\DUrole{name}{tile\_size}}}).  We can also specify the strategy for assigning
tiles to OpenMP threads.  See {\hyperref[\detokenize{Basics:sec-basics-mfiter-tiling}]{\sphinxcrossref{\DUrole{std,std-ref}{MFIter with Tiling}}}} for more about tiling.


\section{Grid Creation}
\label{\detokenize{GridCreation:grid-creation}}\label{\detokenize{GridCreation:sec-grid-creation}}\label{\detokenize{GridCreation::doc}}
\sphinxAtStartPar
To run an AMReX\sphinxhyphen{}based application you must specify the domain size by
specifying \sphinxcode{\sphinxupquote{\DUrole{name}{n\_cell}}} \textendash{} this is the number of cells spanning the domain
in each coordinate direction at level 0.

\sphinxAtStartPar
Users often specify \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} as well. The default load balancing algorithm then divides the
domain in every direction so that each grid is no longer than \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} in that direction.
If not specified by the user, \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} defaults to 128 in 2D and 32 in 3D (in each coordinate direction).

\sphinxAtStartPar
Another popular input is \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}.  The value of \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}
constrains grid creation in that in that each grid must be divisible by \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}.
Note that both the domain (at each level) and \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} must be divisible by \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}},
and that \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} must be either 1 or a power of 2 (otherwise the gridding algorithm
would not in fact create grids divisible by  \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} because of how  \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}
is used in the gridding algorithm).

\sphinxAtStartPar
If not specified by the user, \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} defaults to 8 in each coordinate direction.
The typical purpose of \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} is to ensure that the grids will be
sufficiently coarsenable for good multigrid performance.

\sphinxAtStartPar
There is one more default behavior to be aware of.  There is a boolean \sphinxcode{\sphinxupquote{\DUrole{name}{refine\_grid\_layout}}}
that defaults to true but can be over\sphinxhyphen{}ridden at run\sphinxhyphen{}time.
If \sphinxcode{\sphinxupquote{\DUrole{name}{refine\_grid\_layout}}} is true and the number of grids created is less than the number of processors
(Ngrids \textless{} Nprocs), then grids will be further subdivided until Ngrids \textgreater{}= Nprocs.

\sphinxAtStartPar
Caveat: if subdividing the grids to achieve Ngrids \textgreater{}= Nprocs would violate the
\sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} criterion then additional grids are not created and the
number of grids will remain less than the number of processors

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{\DUrole{name}{n\_cell}}} must be given as three separate integers, one for each coordinate direction.

\sphinxAtStartPar
However, \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} can be specified as a single value
applying to all coordinate directions, or as separate values for each direction.
\begin{itemize}
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} (or \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}) is specified as multiple integers then the first
integer applies to level 0, the second to level 1, etc.  If you don’t specify as many
integers as there are levels, the final value will be used for the remaining levels.

\item {} 
\sphinxAtStartPar
If different values of \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} (or \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}}) are wanted for each coordinate direction,
then \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size\_x}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size\_y}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size\_z}}}
(or \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor\_x}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor\_y}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor\_z}}}) must be used.
If you don’t specify as many integers as there are levels, the final value will be used for the remaining levels.

\end{itemize}

\sphinxAtStartPar
Additional notes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
To create identical grids of a specific size, e.g. of length \sphinxstyleemphasis{m} in each direction,
then set \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} = \sphinxstyleemphasis{m} and \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} = \sphinxstyleemphasis{m}.

\item {} 
\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} is just an upper bound; with \sphinxcode{\sphinxupquote{\DUrole{name}{n\_cell} \DUrole{operator}{=} \DUrole{literal,number,integer}{48}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size} \DUrole{operator}{=} \DUrole{literal,number,integer}{32}}}, we will typically have one grid of length 32 and one of length 16.

\end{itemize}

\sphinxAtStartPar
The grid creation process at level 0 proceeds as follows (if not using the KD\sphinxhyphen{}tree approach):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The domain is initially defined by a single grid of size \sphinxcode{\sphinxupquote{\DUrole{name}{n\_cell}}}.

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{\DUrole{name}{n\_cell}}} is greater than \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} then the grids are subdivided until
each grid is no longer than  \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} cells on each side.  The \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} criterion
(ie that the length of each side of each grid is divisible by \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} in that direction)
is satisfied during this process.

\item {} 
\sphinxAtStartPar
Next, if \sphinxcode{\sphinxupquote{\DUrole{name}{refine\_grid\_layout} \DUrole{operator}{=} \DUrole{name,builtin}{true}}} and there are more processors than grids
at this level, then the grids at this level are further divided until Ngrids \textgreater{}= Nprocs
(unless doing so would violate the \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} criterion).

\end{enumerate}

\sphinxAtStartPar
The creation of grids at levels \textgreater{} 0 begins by tagging cells at the coarser level and follows
the Berger\sphinxhyphen{}Rigoutsos clustering algorithm with the additional constraints of satisfying
the \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{max\_grid\_size}}} criteria.  An additional parameter
becomes relevant here: the “grid efficiency”, specified as \sphinxcode{\sphinxupquote{\DUrole{name}{amr}\DUrole{punctuation}{.}\DUrole{name}{grid\_eff}}} in the inputs file.
This threshold value, which defaults to 0.7 (or 70\%), is used to ensure that
grids do not contain too large a fraction of un\sphinxhyphen{}tagged cells.   We note that the grid creation
process attempts to satisfy the \sphinxcode{\sphinxupquote{\DUrole{name}{amr}\DUrole{punctuation}{.}\DUrole{name}{grid\_eff}}} constraint but will not do so if it means
violating the \sphinxcode{\sphinxupquote{\DUrole{name}{blocking\_factor}}} criterion.

\sphinxAtStartPar
Users often like to ensure that coarse/fine boundaries are not too close to tagged cells; the
way to do this is to set \sphinxcode{\sphinxupquote{\DUrole{name}{amr}\DUrole{punctuation}{.}\DUrole{name}{n\_error\_buf}}} to a large integer value (the default is 1).
This parameter is used to increase the number of tagged cells before the grids are defined;
if cell “\sphinxstyleemphasis{(i,j,k)}” satisfies the tagging criteria, then, for example, if \sphinxcode{\sphinxupquote{\DUrole{name}{amr}\DUrole{punctuation}{.}\DUrole{name}{n\_error\_buf}}} is 3,
all cells in the 7x7x7 box from lower corner “\sphinxstyleemphasis{(i\sphinxhyphen{}3,j\sphinxhyphen{}3,k\sphinxhyphen{}3)}” to “\sphinxstyleemphasis{(i+3,j+3,k+3)}” will be tagged.


\section{Dual Grid Approach}
\label{\detokenize{DualGrid:dual-grid-approach}}\label{\detokenize{DualGrid:sec-dual-grid}}\label{\detokenize{DualGrid::doc}}
\sphinxAtStartPar
In AMReX\sphinxhyphen{}based applications that have both mesh data and particle data,
the mesh work and particle work have very different requirements for load balancing.

\sphinxAtStartPar
Rather than using a combined work estimate to create the same grids for mesh and particle
data, we have the option to pursue a “dual grid” approach.

\sphinxAtStartPar
With this approach the mesh (\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}) and particle (\sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}}) data
are allocated on different \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArrays}}} with different \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMappings}}}.

\sphinxAtStartPar
This enables separate load balancing strategies to be used for the mesh and particle work.

\sphinxAtStartPar
The cost of this strategy, of course, is the need to copy mesh data onto temporary
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFabs}}} defined on the particle \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArrays}}} when mesh\sphinxhyphen{}particle communication
is required.


\section{Load Balancing}
\label{\detokenize{LoadBalancing:load-balancing}}\label{\detokenize{LoadBalancing:sec-load-balancing}}\label{\detokenize{LoadBalancing::doc}}
\sphinxAtStartPar
The process of load balancing is typically independent of the process of grid creation;
the inputs to load balancing are a given set of grids with a set of weights
assigned to each grid.  (The exception to this is the KD\sphinxhyphen{}tree approach in which the
grid creation process is governed by trying to balance the work in each grid.)

\sphinxAtStartPar
Single\sphinxhyphen{}level load balancing algorithms are sequentially applied to each AMR level independently,
and the resulting distributions are mapped onto the ranks taking into account the weights
already assigned to them (assign heaviest set of grids to the least loaded rank).  Note that the
load of each process is measured by how much memory has already been allocated, not how much memory
will be allocated.  Therefore the following code is not recommended because it tends to generate
non\sphinxhyphen{}optimal distributions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{nlevels}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// build DistributionMapping for Level lev}
\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{nlevels}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// build MultiFabs for Level lev}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Instead, one should do,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{nlevels}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// build DistributionMapping for Level lev}
    \PYG{c+c1}{// build MultiFabs for Level lev}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Distribution options supported by AMReX include the following; the default is SFC:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Knapsack: the default weight of a grid in the knapsack algorithm is the number of grid cells,
but AMReX supports the option to pass an array of weights \textendash{} one per grid \textendash{} or alternatively
to pass in a MultiFab of weights per cell which is used to compute the weight per grid.

\item {} 
\sphinxAtStartPar
SFC: enumerate grids with a space\sphinxhyphen{}filling Z\sphinxhyphen{}morton curve, then partition the
resulting ordering across ranks in a way that balances the load.

\item {} 
\sphinxAtStartPar
Round\sphinxhyphen{}robin: sort grids and assign them to ranks in round\sphinxhyphen{}robin fashion \textendash{} specifically
FAB i is owned by CPU i\%N where N is the total number of MPI ranks.

\end{itemize}


\chapter{AmrCore Source Code}
\label{\detokenize{AmrCore_Chapter:amrcore-source-code}}\label{\detokenize{AmrCore_Chapter:chap-amrcore}}\label{\detokenize{AmrCore_Chapter::doc}}
\sphinxAtStartPar
In this Chapter we give an overview of functionality contained in the
\sphinxcode{\sphinxupquote{amrex/Src/AmrCore}} source code.  This directory contains source code for the
following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Storing information about the grid layout and processor distribution mapping
at each level of refinement.

\item {} 
\sphinxAtStartPar
Functions to create grids at different levels of refinement, including
tagging operations.

\item {} 
\sphinxAtStartPar
Operations on data at different levels of refinement, such as interpolation
and restriction operators.

\item {} 
\sphinxAtStartPar
Flux registers used to store and manipulate fluxes at coarse\sphinxhyphen{}fine
interfaces.

\item {} 
\sphinxAtStartPar
Particle support for AMR (see {\hyperref[\detokenize{Particle_Chapter:chap-particles}]{\sphinxcrossref{\DUrole{std,std-ref}{Particles}}}}).

\end{itemize}

\sphinxAtStartPar
There is another source directory, \sphinxcode{\sphinxupquote{amrex/Src/Amr/}}, which contains
additional classes used to manage the time\sphinxhyphen{}stepping for AMR simulations.
However, it is possible to build a fully adaptive, subcycling\sphinxhyphen{}in\sphinxhyphen{}time
simulation code without these additional classes.

\sphinxAtStartPar
In this Chapter, we restrict our use to the \sphinxcode{\sphinxupquote{amrex/Src/AmrCore}} source code
and present a tutorial that performs an adaptive, subcycling\sphinxhyphen{}in\sphinxhyphen{}time simulation
of the advection equation for a passively advected scalar.  The accompanying
tutorial code is available in \sphinxcode{\sphinxupquote{amrex/Tutorials/Amr/Advection\_AmrCore}} with
build/run directory \sphinxcode{\sphinxupquote{Exec/SingleVortex}}. In this example, the velocity field
is a specified function of space and time, such that an initial Gaussian
profile is displaced but returns to its original configuration at the final
time.  The boundary conditions are periodic and we use a refinement ratio of
\(r=2\) between each AMR level. The results of the simulation in
two\sphinxhyphen{}dimensions are depicted in the Table showing the {\hyperref[\detokenize{AmrCore:fig-adv}]{\sphinxcrossref{\DUrole{std,std-ref}{SingleVortex
Tutorial}}}}.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Time sequence (\protect\(t=0,0.5,1,1.5,2\protect\) s) of advection of a Gaussian profile using the SingleVortex tutorial. The analytic velocity field distorts the profile, and then restores the profile to the original configuration.  The red, green, and blue boxes indicate grids at AMR levels \protect\(\ell=0,1\protect\), and \protect\(2\protect\).}\label{\detokenize{AmrCore:id1}}\label{\detokenize{AmrCore:fig-adv}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Adv1}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Adv2}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Adv3}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Adv4}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Adv5}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}


\section{AmrCore Source Code: Details}
\label{\detokenize{AmrCore:amrcore-source-code-details}}\label{\detokenize{AmrCore:ss-amrcore}}\label{\detokenize{AmrCore::doc}}
\sphinxAtStartPar
Here we provide more information about the source code in \sphinxcode{\sphinxupquote{amrex/Src/AmrCore}}.


\subsection{AmrMesh and AmrCore}
\label{\detokenize{AmrCore:amrmesh-and-amrcore}}
\sphinxAtStartPar
For single\sphinxhyphen{}level simulations
(see e.g., \sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HeatEquation\_EX1\_C/main.cpp}})
the user needs to build \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}},
and \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} objects associated with the simulation. For simulations
with multiple levels of refinement, the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrMesh}}} class can be thought
of as a container to store arrays of these objects (one for each level), and
information about the current grid structure.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amrex/Src/AmrCore/AMReX\_AmrMesh.cpp/H}} contains the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrMesh}}} class.
The protected data members are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{protected}\PYG{o}{:}
    \PYG{k+kt}{int}            \PYG{n}{verbose}\PYG{p}{;}
    \PYG{k+kt}{int}            \PYG{n}{max\PYGZus{}level}\PYG{p}{;}       \PYG{c+c1}{// Maximum allowed level.}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{IntVect}\PYG{o}{\PYGZgt{}} \PYG{n}{ref\PYGZus{}ratio}\PYG{p}{;}       \PYG{c+c1}{// Refinement ratios [0:finest\PYGZus{}level\PYGZhy{}1]}

    \PYG{k+kt}{int}            \PYG{n}{finest\PYGZus{}level}\PYG{p}{;}    \PYG{c+c1}{// Current finest level.}

    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{IntVect}\PYG{o}{\PYGZgt{}} \PYG{n}{n\PYGZus{}error\PYGZus{}buf}\PYG{p}{;}     \PYG{c+c1}{// Buffer cells around each tagged cell.}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{IntVect}\PYG{o}{\PYGZgt{}} \PYG{n}{blocking\PYGZus{}factor}\PYG{p}{;} \PYG{c+c1}{// Blocking factor in grid generation}
                                    \PYG{c+c1}{// (by level).}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{IntVect}\PYG{o}{\PYGZgt{}} \PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{;}   \PYG{c+c1}{// Maximum allowable grid size (by level).}
    \PYG{n}{Real}           \PYG{n}{grid\PYGZus{}eff}\PYG{p}{;}        \PYG{c+c1}{// Grid efficiency.}
    \PYG{k+kt}{int}            \PYG{n}{n\PYGZus{}proper}\PYG{p}{;}        \PYG{c+c1}{// \PYGZsh{} cells required for proper nesting.}

    \PYG{k+kt}{bool} \PYG{n}{use\PYGZus{}fixed\PYGZus{}coarse\PYGZus{}grids}\PYG{p}{;}
    \PYG{k+kt}{int}  \PYG{n}{use\PYGZus{}fixed\PYGZus{}upto\PYGZus{}level}\PYG{p}{;}
    \PYG{k+kt}{bool} \PYG{n}{refine\PYGZus{}grid\PYGZus{}layout}\PYG{p}{;}        \PYG{c+c1}{// chop up grids to have the number of}
                                    \PYG{c+c1}{// grids no less the number of procs}

    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}}            \PYG{n}{geom}\PYG{p}{;}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DistributionMapping}\PYG{o}{\PYGZgt{}} \PYG{n}{dmap}\PYG{p}{;}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BoxArray}\PYG{o}{\PYGZgt{}}            \PYG{n}{grids}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following parameters are frequently set via the inputs file or the command line.
Their usage is described in the section on {\hyperref[\detokenize{GridCreation:sec-grid-creation}]{\sphinxcrossref{\DUrole{std,std-ref}{Grid Creation}}}}

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AmrCore parameters}\label{\detokenize{AmrCore:id2}}\label{\detokenize{AmrCore:tab-makevarimp}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Value
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
amr.verbose
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
amr.max\_level
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
none
\\
\hline
\sphinxAtStartPar
amr.max\_grid\_size
&
\sphinxAtStartPar
ints
&
\sphinxAtStartPar
32 in 3D, 128 in 2D
\\
\hline
\sphinxAtStartPar
amr.n\_proper
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
amr.grid\_eff
&
\sphinxAtStartPar
Real
&
\sphinxAtStartPar
0.7
\\
\hline
\sphinxAtStartPar
amr.n\_error\_buf
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
amr.blocking\_factor
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
8
\\
\hline
\sphinxAtStartPar
amr.refine\_grid\_layout
&
\sphinxAtStartPar
int
&
\sphinxAtStartPar
true
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
AMReX\_AmrCore.cpp/H contains the pure virtual class \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}},
which is derived from the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrMesh}}} class. AmrCore does not actually
have any data members, just additional member functions, some of which override
the base class AmrMesh.

\sphinxAtStartPar
There are no pure virtual functions in \sphinxcode{\sphinxupquote{\DUrole{name}{AmrMesh}}}, but
there are 5 pure virtual functions in the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}} class. Any applications
you create must implement these functions. The tutorial code
Amr/Advection\_AmrCore provides sample implementation in the derived
class \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//! Tag cells for refinement.  TagBoxArray tags is built on level lev grids.}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{ErrorEst} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{TagBoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{tags}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,}
                       \PYG{k+kt}{int} \PYG{n}{ngrow}\PYG{p}{)} \PYG{k}{override} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//! Make a new level from scratch using provided BoxArray and DistributionMapping.}
\PYG{c+c1}{//! Only used during initialization.}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{MakeNewLevelFromScratch} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{dm}\PYG{p}{)} \PYG{k}{override} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//! Make a new level using provided BoxArray and DistributionMapping and fill}
\PYG{c+c1}{//  with interpolated coarse level data.}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{MakeNewLevelFromCoarse} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{,}
                                     \PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{dm}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//! Remake an existing level using provided BoxArray and DistributionMapping}
\PYG{c+c1}{//  and fill with existing fine and coarse data.}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{RemakeLevel} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{,}
                          \PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{dm}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//! Delete level data}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{ClearLevel} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Refer to the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}}} class in the
\sphinxcode{\sphinxupquote{amrex/Tutorials/Amr/AmrCore\_Advection/Source}}
code for a sample implementation.


\subsection{TagBox, and Cluster}
\label{\detokenize{AmrCore:tagbox-and-cluster}}
\sphinxAtStartPar
These classes are used in the grid generation process.
The \sphinxcode{\sphinxupquote{\DUrole{name}{TagBox}}} class is essentially a data structure that marks which
cells are “tagged” for refinement.
\sphinxcode{\sphinxupquote{\DUrole{name}{Cluster}}} (and \sphinxcode{\sphinxupquote{\DUrole{name}{ClusterList}}} contained within the same file) are classes
that help sort tagged cells and generate a grid structure that contains all
the tagged cells. These classes and their member functions are largely
hidden from any application codes through simple interfaces
such as \sphinxcode{\sphinxupquote{\DUrole{name}{regrid}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{ErrorEst}}} (a routine for tagging cells for refinement).


\subsection{FillPatchUtil and Interpolater}
\label{\detokenize{AmrCore:fillpatchutil-and-interpolater}}\label{\detokenize{AmrCore:sec-amrcore-fillpatch}}
\sphinxAtStartPar
Many codes, including the Advection\_AmrCore example, contain an array of MultiFabs
(one for each level of refinement), and then use “fillpatch” operations to fill temporary
MultiFabs that may include a different number of ghost cells. Fillpatch operations fill
all cells, valid and ghost, from actual valid data at that level, space\sphinxhyphen{}time interpolated data
from the next\sphinxhyphen{}coarser level, neighboring grids at the same level, and domain
boundary conditions (for examples that have non\sphinxhyphen{}periodic boundary conditions).
Note that at the coarsest level,
the interior and domain boundary (which can be periodic or prescribed based on physical considerations)
need to be filled. At the non\sphinxhyphen{}coarsest level, the ghost cells can also be interior or domain,
but can also be at coarse\sphinxhyphen{}fine interfaces away from the domain boundary.
\sphinxcode{\sphinxupquote{\DUrole{name}{AMReX\_FillPatchUtil}\DUrole{punctuation}{.}\DUrole{name}{cpp}\DUrole{operator}{/}\DUrole{name}{H}}} contains two primary functions of interest.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchSingleLevel}\DUrole{punctuation}{()}}} fills a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and its ghost region at a single level of
refinement. The routine is flexible enough to interpolate in time between two MultiFabs
associated with different times.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchTwoLevels}\DUrole{punctuation}{()}}} fills a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and its ghost region at a single level of
refinement, assuming there is an underlying coarse level. This routine is flexible enough to interpolate
the coarser level in time first using \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchSingleLevel}\DUrole{punctuation}{()}}}.

\end{enumerate}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchSingleLevel}\DUrole{punctuation}{()}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchTwoLevels}\DUrole{punctuation}{()}}} call the
single\sphinxhyphen{}level routines \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{FillBoundary}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FillDomainBoundary}\DUrole{punctuation}{()}}}
to fill interior, periodic, and physical boundary ghost cells.  In principle, you can
write a single\sphinxhyphen{}level application that calls \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchSingleLevel}\DUrole{punctuation}{()}}} instead
of using \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{FillBoundary}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FillDomainBoundary}\DUrole{punctuation}{()}}}.

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchUtil}}} uses an \sphinxcode{\sphinxupquote{\DUrole{name}{Interpolator}}}. This is largely hidden from application codes.
AMReX\_Interpolater.cpp/H contains the virtual base class \sphinxcode{\sphinxupquote{\DUrole{name}{Interpolater}}}, which provides
an interface for coarse\sphinxhyphen{}to\sphinxhyphen{}fine spatial interpolation operators. The fillpatch routines described
above require an Interpolater for FillPatchTwoLevels().
Within AMReX\_Interpolater.cpp/H are the derived classes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{NodeBilinear}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CellBilinear}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CellConservativeLinear}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CellConservativeProtected}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CellQuadratic}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{PCInterp}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CellConservativeQuartic}}}

\end{itemize}

\sphinxAtStartPar
The Fortran routines that perform the actual work associated with \sphinxcode{\sphinxupquote{\DUrole{name}{Interpolater}}} are
contained in the files AMReX\_INTERP\_F.H and AMReX\_INTERP\_xD.F.


\subsection{Using FluxRegisters}
\label{\detokenize{AmrCore:using-fluxregisters}}\label{\detokenize{AmrCore:sec-amrcore-fluxreg}}
\sphinxAtStartPar
AMReX\_FluxRegister.cpp/H contains the class \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}}, which is
derived from the class \sphinxcode{\sphinxupquote{\DUrole{name}{BndryRegister}}} (in \sphinxcode{\sphinxupquote{amrex/Src/Boundary/AMReX\_BndryRegister}}).
In the most general terms, a FluxRegister is a special type of BndryRegister
that stores and manipulates data (most often fluxes) at coarse\sphinxhyphen{}fine interfaces.
A simple usage scenario comes from a conservative discretization of a hyperbolic
system:
\begin{equation*}
\begin{split}\frac{\partial\phi}{\partial t} = \nabla\cdot{\bf F}
\rightarrow
\frac{\phi_{i,\,j}^{n+1}-\phi_{i,\,j}^n}{\Delta t} = \frac{F_{i+^1\!/_2,\,j}-F_{i-^1\!/_2,\,j}}{\Delta x} + \frac{F_{i,\,j+^1\!/_2} - F_{i,\,j-^1\!/_2}}{\Delta y}.\end{split}
\end{equation*}
\sphinxAtStartPar
Consider a two\sphinxhyphen{}level, two\sphinxhyphen{}dimensional simulation. A standard methodology for
advancing the solution in time is to first advance the coarse grid solution
ignoring the fine level, and then advance the fine grid solution using the
coarse level only to supply boundary conditions. At the coarse\sphinxhyphen{}fine interface,
the area\sphinxhyphen{}weighted fluxes from the fine grid advance do not in general match the
underlying flux from the coarse grid face, resulting in a lack of global
conservation. Note that for subcycling\sphinxhyphen{}in\sphinxhyphen{}time algorithms (where for each coarse
grid advance, the fine grid is advanced \(r\) times using a coarse grid time
step reduced by a factor of \(r\), where \(r\) is the refinement ratio),
the coarse grid flux must be compared to the area \sphinxstyleemphasis{and} time\sphinxhyphen{}weighted fine grid
fluxes. A \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}} accumulates and ultimately stores the net
difference in fluxes between the coarse grid and fine grid advance over each
face over a given coarse time step. The simplest possible synchronization step
is to modify the coarse grid solution in coarse cells immediately adjacent to
the coarse\sphinxhyphen{}fine interface are updated to account for the mismatch stored in the
FluxRegister. This can be done “simply” by taking the coarse\sphinxhyphen{}level divergence of
the data in the FluxRegister using the \sphinxcode{\sphinxupquote{\DUrole{name}{reflux}}} function.

\sphinxAtStartPar
The Fortran routines that perform the actual floating point work associated with
incrementing data in a \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}} are contained in the files
AMReX\_FLUXREG\_F.H and AMReX\_FLUXREG\_xD.F.


\subsection{AmrParticles and AmrParGDB}
\label{\detokenize{AmrCore:amrparticles-and-amrpargdb}}
\sphinxAtStartPar
The AmrCore/ directory contains derived classes for dealing with particles
in a multi\sphinxhyphen{}level framework. The description of the base classes
are given in the chapter on {\hyperref[\detokenize{Particle_Chapter:chap-particles}]{\sphinxcrossref{\DUrole{std,std-ref}{Particles}}}}.

\sphinxAtStartPar
AMReX\_AmrParticles.cpp/H contains the classes \sphinxcode{\sphinxupquote{\DUrole{name}{AmrParticleContainer}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{AmrTracerParticleContainer}}}, which are derived from the classes
\sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} (in \sphinxcode{\sphinxupquote{amrex/Src/Particle/AMReX\_Particles}})
and \sphinxcode{\sphinxupquote{\DUrole{name}{TracerParticleContainer}}} (in \sphinxcode{\sphinxupquote{amrex/Src/Particle/AMReX\_TracerParticles}}).

\sphinxAtStartPar
AMReX\_AmrParGDB.cpp/H contains the class \sphinxcode{\sphinxupquote{\DUrole{name}{AmrParGDB}}}, which is derived from
the class \sphinxcode{\sphinxupquote{\DUrole{name}{ParGDBBase}}} (in \sphinxcode{\sphinxupquote{amrex/Src/Particle/AMReX\_ParGDB}}).


\section{Example: Advection\_AmrCore}
\label{\detokenize{AmrCore:example-advection-amrcore}}

\subsection{The Advection Equation}
\label{\detokenize{AmrCore:the-advection-equation}}
\sphinxAtStartPar
We seek to solve the advection equation on a multi\sphinxhyphen{}level, adaptive grid structure:
\begin{equation*}
\begin{split}\frac{\partial\phi}{\partial t} = -\nabla\cdot(\phi{\bf U}).\end{split}
\end{equation*}
\sphinxAtStartPar
The velocity field is a specified divergence\sphinxhyphen{}free (so the flow field is incompressible)
function of space and time. The initial scalar field is a
Gaussian profile. To integrate these equations on a given level, we use a simple conservative update,
\begin{equation*}
\begin{split}\frac{\phi_{i,\,j}^{n+1}-\phi_{i,\,j}^n}{\Delta t} = \frac{(\phi u)_{i+^1\!/_2,\,j}^{n+^1\!/_2}-(\phi u)_{i-^1\!/_2,\,j}^{n+^1\!/_2}}{\Delta x} + \frac{(\phi v)_{i,\,j+^1\!/_2}^{n+^1\!/_2} - (\phi v)_{i,\,j-^1\!/_2}^{n+^1\!/_2}}{\Delta y},\end{split}
\end{equation*}
\sphinxAtStartPar
where the velocities on faces are prescribed functions of space and time, and the scalars on faces
are computed using a Godunov advection integration scheme. The fluxes in this case are the face\sphinxhyphen{}centered,
time\sphinxhyphen{}centered “\(\phi u\)” and “\(\phi v\)” terms.

\sphinxAtStartPar
We use a subcycling\sphinxhyphen{}in\sphinxhyphen{}time approach where finer levels are advanced with smaller
time steps than coarser levels, and then synchronization is later performed between levels.
More specifically, the multi\sphinxhyphen{}level procedure can most
easily be thought of as a recursive algorithm in which, to advance level \(\ell\),
\(0\le\ell\le\ell_{\rm max}\), the following steps are taken:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Advance level \(\ell\) in time by one time step, \(\Delta t^{\ell}\), as if it is
the only level. If \(\ell>0\), obtain boundary data (i.e. fill the level \(\ell\) ghost cells)
using space\sphinxhyphen{} and time\sphinxhyphen{}interpolated data from the grids at \(\ell-1\) where appropriate.

\item {} 
\sphinxAtStartPar
If \(\ell<\ell_{\rm max}\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
Advance level \((\ell+1)\) for \(r\) time steps with \(\Delta t^{\ell+1} = \frac{1}{r}\Delta t^{\ell}\).

\item {} 
\sphinxAtStartPar
Synchronize the data between levels \(\ell\) and \(\ell+1\).

\end{itemize}

\end{itemize}

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4in]{{subcycling}.png}
\caption{Schematic of subcycling\sphinxhyphen{}in\sphinxhyphen{}time algorithm.}\label{\detokenize{AmrCore:id3}}\label{\detokenize{AmrCore:fig-subcycling}}\end{figure}

\end{center}

\sphinxAtStartPar
Specifically, for a 3\sphinxhyphen{}level simulation, depicted graphically in the figure
showing the {\hyperref[\detokenize{AmrCore:fig-subcycling}]{\sphinxcrossref{\DUrole{std,std-ref}{Schematic of subcycling\sphinxhyphen{}in\sphinxhyphen{}time algorithm.}}}} above:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Integrate \(\ell=0\) over \(\Delta t\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=1\) over \(\Delta t/2\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=2\) over \(\Delta t/4\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=2\) over \(\Delta t/4\).

\item {} 
\sphinxAtStartPar
Synchronize levels \(\ell=1,2\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=1\) over \(\Delta t/2\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=2\) over \(\Delta t/4\).

\item {} 
\sphinxAtStartPar
Integrate \(\ell=2\) over \(\Delta t/4\).

\item {} 
\sphinxAtStartPar
Synchronize levels \(\ell=1,2\).

\item {} 
\sphinxAtStartPar
Synchronize levels \(\ell=0,1\).

\end{enumerate}

\sphinxAtStartPar
For the scalar field, we keep track volume and time\sphinxhyphen{}weighted fluxes at coarse\sphinxhyphen{}fine interfaces.
We accumulate area and time\sphinxhyphen{}weighted fluxes in \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}} objects, which can be
thought of as special boundary FABsets associated with coarse\sphinxhyphen{}fine interfaces.
Since the fluxes are area and time\sphinxhyphen{}weighted (and sign\sphinxhyphen{}weighted, depending on whether they
come from the coarse or fine level), the flux registers essentially store the extent by
which the solution does not maintain conservation. Conservation only happens if the
sum of the (area and time\sphinxhyphen{}weighted) fine fluxes equals the coarse flux, which in general
is not true.

\sphinxAtStartPar
The idea behind the level \(\ell/(\ell+1)\) synchronization step is to correct for sources of
mismatch in the composite solution:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The data at level \(\ell\) that underlie the level \(\ell+1\) data are not synchronized with the level \(\ell+1\) data.
This is simply corrected by overwriting covered coarse cells to be the average of the overlying fine cells.

\item {} 
\sphinxAtStartPar
The area and time\sphinxhyphen{}weighted fluxes from the level \(\ell\) faces and the level \(\ell+1\) faces
do not agree at the \(\ell/(\ell+1)\) interface, resulting in a loss of conservation.
The remedy is to modify the solution in the coarse cells immediately next to the coarse\sphinxhyphen{}fine interface
to account for the mismatch stored in the flux register (computed by taking the coarse\sphinxhyphen{}level divergence of the
flux register data).

\end{enumerate}


\subsection{Code Structure}
\label{\detokenize{AmrCore:code-structure}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=4in]{{flowchart}.png}
\caption{Source code tree for the AmrAdvection\_AmrCore example.}\label{\detokenize{AmrCore:id4}}\label{\detokenize{AmrCore:fig-amradvection-amrcore-flowchart}}\end{figure}

\sphinxAtStartPar
The figure shows the {\hyperref[\detokenize{AmrCore:fig-amradvection-amrcore-flowchart}]{\sphinxcrossref{\DUrole{std,std-ref}{Source code tree for the AmrAdvection\_AmrCore example.}}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
amrex/Src/
\begin{itemize}
\item {} 
\sphinxAtStartPar
Base/ Base amrex library.

\item {} 
\sphinxAtStartPar
Boundary/ An assortment of classes for handling boundary data.

\item {} 
\sphinxAtStartPar
AmrCore/ AMR data management classes, described in more detail above.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Advection\_AmrCore/Src}} Source code specific to this example. Most notably
is the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}}} class, which is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}}. The subdirectories \sphinxcode{\sphinxupquote{Src\_2d}}
and \sphinxcode{\sphinxupquote{Src\_3d}} contain dimension specific routines. \sphinxcode{\sphinxupquote{Src\_nd}} contains dimension\sphinxhyphen{}independent routines.

\item {} 
\sphinxAtStartPar
Exec Contains a makefile so a user can write other examples besides SingleVortex.

\item {} 
\sphinxAtStartPar
SingleVortex Build the code here by editing the GNUmakefile and running make. There
is also problem\sphinxhyphen{}specific source code here used for initialization or specifying the velocity field used in this
simulation.

\end{itemize}

\sphinxAtStartPar
Here is a high\sphinxhyphen{}level pseudo\sphinxhyphen{}code of the flow of the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Advection\PYGZus{}AmrCore Pseudocode */}
\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{AmrCoreAdv} \PYG{n}{amr\PYGZus{}core\PYGZus{}adv}\PYG{p}{;} \PYG{c+c1}{// build an AmrCoreAdv object}
  \PYG{n}{amr\PYGZus{}core\PYGZus{}adv}\PYG{p}{.}\PYG{n}{InitData}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{// initialize data all all levels}
    \PYG{n}{AmrCore}\PYG{o}{:}\PYG{o}{:}\PYG{n}{InitFromScratch}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{AmrMesh}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MakeNewGrids}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{AmrMesh}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MakeBaseGrids}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// define level 0 grids}
    \PYG{n}{AmrCoreAdv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MakeNewLevelFromScratch}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+cm}{/* allocate phi\PYGZus{}old, phi\PYGZus{}new, t\PYGZus{}new, and flux registers */}
    \PYG{n}{initdata}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{// fill phi}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{max\PYGZus{}level} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{k}{do} \PYG{p}{\PYGZob{}}
        \PYG{n}{AmrMesh}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MakeNewGrids}\PYG{p}{(}\PYG{p}{)}
          \PYG{c+cm}{/* construct next finer grid based on tagging criteria */}
        \PYG{n}{AmrCoreAdv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MakeNewLevelFromScratch}\PYG{p}{(}\PYG{p}{)}
              \PYG{c+cm}{/* allocate phi\PYGZus{}old, phi\PYGZus{}new, t\PYGZus{}new, and flux registers */}
              \PYG{n}{initdata}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{// fill phi}
      \PYG{p}{\PYGZcb{}} \PYG{k}{while} \PYG{p}{(}\PYG{n}{finest\PYGZus{}level} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}level}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
  \PYG{n}{amr\PYGZus{}core\PYGZus{}adv}\PYG{p}{.}\PYG{n}{Evolve}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{loop} \PYG{n}{over} \PYG{n}{time} \PYG{n}{steps} \PYG{p}{\PYGZob{}}
      \PYG{n}{ComputeDt}\PYG{p}{(}\PYG{p}{)}
      \PYG{n}{timeStep}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// advance a level}
        \PYG{c+cm}{/* check regrid conditions and regrid if necessary */}
        \PYG{n}{Advance}\PYG{p}{(}\PYG{p}{)}
          \PYG{c+cm}{/* copy phi into a MultiFab and fill ghost cells */}
          \PYG{c+cm}{/* advance phi */}
          \PYG{c+cm}{/* update flux registers */}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{finest\PYGZus{}level}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{n}{timeStep}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// recursive call to advance the next\PYGZhy{}finer level \PYGZdq{}r\PYGZdq{} times}
            \PYG{c+cm}{/* check regrid conditions and regrid if necessary */}
            \PYG{n}{Advance}\PYG{p}{(}\PYG{p}{)}
              \PYG{c+cm}{/* copy phi into a MultiFab and fill ghost cells */}
              \PYG{c+cm}{/* advance phi */}
              \PYG{c+cm}{/* update flux registers */}
          \PYG{n}{reflux}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// synchronize lev and lev+1 using FluxRegister divergence}
          \PYG{n}{AverageDown}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// set covered coarse cells to be the average of fine}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{The AmrCoreAdv Class}
\label{\detokenize{AmrCore:the-amrcoreadv-class}}
\sphinxAtStartPar
This example uses the class \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}}}, which is derived from the class \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}}
(which is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{AmrMesh}}}). The function definitions/implementations
are given in AmrCoreAdv.H/cpp.


\subsection{FluxRegisters}
\label{\detokenize{AmrCore:fluxregisters}}
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}\DUrole{operator}{::}\DUrole{name}{Advance}\DUrole{punctuation}{()}}} calls the Fortran
subroutine, \sphinxcode{\sphinxupquote{\DUrole{name}{advect}}} (in \sphinxcode{\sphinxupquote{./Src\_xd/Adv\_xd.f90}}). \sphinxcode{\sphinxupquote{\DUrole{name}{advect}}} computes
and returns the time\sphinxhyphen{}advanced state as well as the fluxes used to update the state.
These fluxes are used to set or increment the flux registers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// increment or decrement the flux registers by area and time\PYGZhy{}weighted fluxes}
\PYG{c+c1}{// Note that the fluxes have already been scaled by dt and area}
\PYG{c+c1}{// In this example we are solving phi\PYGZus{}t = \PYGZhy{}div(+F)}
\PYG{c+c1}{// The fluxes contain, e.g., F\PYGZus{}\PYGZob{}i+1/2,j\PYGZcb{} = (phi*u)\PYGZus{}\PYGZob{}i+1/2,j\PYGZcb{}}
\PYG{c+c1}{// Keep this in mind when considering the different sign convention for updating}
\PYG{c+c1}{// the flux registers from the coarse or fine grid perspective}
\PYG{c+c1}{// NOTE: the flux register associated with flux\PYGZus{}reg[lev] is associated}
\PYG{c+c1}{// with the lev/lev\PYGZhy{}1 interface (and has grid spacing associated with lev\PYGZhy{}1)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{do\PYGZus{}reflux}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CrseInit}\PYG{p}{(}\PYG{n}{fluxes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{fluxes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{FineAdd}\PYG{p}{(}\PYG{n}{fluxes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{fluxes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The synchronization is performed at the end of \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}\DUrole{operator}{::}\DUrole{name}{timeStep}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{do\PYGZus{}reflux}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// update lev based on coarse\PYGZhy{}fine flux mismatch}
    \PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Reflux}\PYG{p}{(}\PYG{o}{*}\PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                            \PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{AverageDownTo}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// average lev+1 down to lev}
\end{sphinxVerbatim}


\subsection{Regridding}
\label{\detokenize{AmrCore:regridding}}\label{\detokenize{AmrCore:ss-regridding}}
\sphinxAtStartPar
The regrid function belongs to the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}} class (it is virtual \textendash{} in this
tutorial we use the instance in \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}}).

\sphinxAtStartPar
At the beginning of each time step, we check whether we need to regrid.
In this example, we use a \sphinxcode{\sphinxupquote{\DUrole{name}{regrid\_int}}} and keep track of how many times each level
has been advanced. When any given particular level \(\ell<\ell_{\rm max}\) has been
advanced a multiple of \sphinxcode{\sphinxupquote{\DUrole{name}{regrid\_int}}}, we call the \sphinxcode{\sphinxupquote{\DUrole{name}{regrid}}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{AmrCoreAdv::timeStep} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{iteration}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{regrid\PYGZus{}int} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}  \PYG{c+c1}{// We may need to regrid}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// regrid changes level \PYGZdq{}lev+1\PYGZdq{} so we don\PYGZsq{}t regrid on max\PYGZus{}level}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}level} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{istep}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{istep}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]} \PYG{o}{\PYGZpc{}} \PYG{n}{regrid\PYGZus{}int} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{c+c1}{// regrid could add newly refine levels}
                \PYG{c+c1}{// (if finest\PYGZus{}level \PYGZlt{} max\PYGZus{}level)}
                \PYG{c+c1}{// so we save the previous finest level index}
        \PYG{k+kt}{int} \PYG{n}{old\PYGZus{}finest} \PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;}
        \PYG{n}{regrid}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{time}\PYG{p}{)}\PYG{p}{;}

                \PYG{c+c1}{// if there are newly created levels, set the time step}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n}{old\PYGZus{}finest}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{dt}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dt}\PYG{p}{[}\PYG{n}{k}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]} \PYG{o}{/} \PYG{n}{MaxRefRatio}\PYG{p}{(}\PYG{n}{k}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Central to the regridding process is the concept of “tagging” which cells need refinement.
\sphinxcode{\sphinxupquote{\DUrole{name}{ErrorEst}}} is a pure virtual function of \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}}, so each application code must
contain an implementation. In AmrCoreAdv.cpp the ErrorEst function is essentially an
interface to a Fortran routine that tags cells (in this case, \sphinxcode{\sphinxupquote{\DUrole{name}{state\_error}}} in
\sphinxcode{\sphinxupquote{Src\_nd/Tagging\_nd.f90}}). Note that this code uses tiling.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// tag all cells for refinement}
\PYG{c+c1}{// overrides the pure virtual function in AmrCore}
\PYG{k+kt}{void}
\PYG{n+nf}{AmrCoreAdv::ErrorEst} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{TagBoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{tags}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ngrow}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k+kt}{bool} \PYG{n}{first} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{k}{static} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{phierr}\PYG{p}{;}

    \PYG{c+c1}{// only do this during the first call to ErrorEst}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{first}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
    \PYG{n}{first} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
        \PYG{c+c1}{// read in an array of \PYGZdq{}phierr\PYGZdq{}, which is the tagging threshold}
        \PYG{c+c1}{// in this example, we tag values of \PYGZdq{}phi\PYGZdq{} which are greater than phierr}
        \PYG{c+c1}{// for that particular level}
        \PYG{c+c1}{// in subroutine state\PYGZus{}error, you could use more elaborate tagging, such}
        \PYG{c+c1}{// as more advanced logical expressions, or gradients, etc.}
    \PYG{n}{ParmParse} \PYG{n}{pp}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{pp}\PYG{p}{.}\PYG{n}{countval}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phierr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{pp}\PYG{p}{.}\PYG{n}{getarr}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phierr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{phierr}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{lev} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{phierr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}

    \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{clearval} \PYG{o}{=} \PYG{n}{TagBox}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CLEAR}\PYG{p}{;}
    \PYG{k}{const} \PYG{k+kt}{int}   \PYG{n}{tagval} \PYG{o}{=} \PYG{n}{TagBox}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SET}\PYG{p}{;}

    \PYG{k}{const} \PYG{n}{Real}\PYG{o}{*} \PYG{n}{dx}      \PYG{o}{=} \PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{CellSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Real}\PYG{o}{*} \PYG{n}{prob\PYGZus{}lo} \PYG{o}{=} \PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ProbLo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{state} \PYG{o}{=} \PYG{o}{*}\PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}  \PYG{n}{itags}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{tilebox}  \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

            \PYG{n}{TagBox}\PYG{o}{\PYGZam{}}     \PYG{n}{tagfab}  \PYG{o}{=} \PYG{n}{tags}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}

        \PYG{c+c1}{// We cannot pass tagfab to Fortran because it is BaseFab\PYGZlt{}char\PYGZgt{}.}
        \PYG{c+c1}{// So we are going to get a temporary integer array.}
            \PYG{c+c1}{// set itags initially to \PYGZsq{}untagged\PYGZsq{} everywhere}
            \PYG{c+c1}{// we define itags over the tilebox region}
        \PYG{n}{tagfab}\PYG{p}{.}\PYG{n}{get\PYGZus{}itags}\PYG{p}{(}\PYG{n}{itags}\PYG{p}{,} \PYG{n}{tilebox}\PYG{p}{)}\PYG{p}{;}

            \PYG{c+c1}{// data pointer and index space}
        \PYG{k+kt}{int}\PYG{o}{*}        \PYG{n}{tptr}    \PYG{o}{=} \PYG{n}{itags}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}  \PYG{n}{tlo}     \PYG{o}{=} \PYG{n}{tilebox}\PYG{p}{.}\PYG{n}{loVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{*}  \PYG{n}{thi}     \PYG{o}{=} \PYG{n}{tilebox}\PYG{p}{.}\PYG{n}{hiVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

            \PYG{c+c1}{// tag cells for refinement}
        \PYG{n}{state\PYGZus{}error}\PYG{p}{(}\PYG{n}{tptr}\PYG{p}{,}  \PYG{n}{ARLIM\PYGZus{}3D}\PYG{p}{(}\PYG{n}{tlo}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ARLIM\PYGZus{}3D}\PYG{p}{(}\PYG{n}{thi}\PYG{p}{)}\PYG{p}{,}
            \PYG{n}{BL\PYGZus{}TO\PYGZus{}FORTRAN\PYGZus{}3D}\PYG{p}{(}\PYG{n}{state}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
            \PYG{o}{\PYGZam{}}\PYG{n}{tagval}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{clearval}\PYG{p}{,}
            \PYG{n}{ARLIM\PYGZus{}3D}\PYG{p}{(}\PYG{n}{tilebox}\PYG{p}{.}\PYG{n}{loVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ARLIM\PYGZus{}3D}\PYG{p}{(}\PYG{n}{tilebox}\PYG{p}{.}\PYG{n}{hiVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
            \PYG{n}{ZFILL}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ZFILL}\PYG{p}{(}\PYG{n}{prob\PYGZus{}lo}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{time}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{phierr}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//}
        \PYG{c+c1}{// Now update the tags in the TagBox in the tilebox region}
            \PYG{c+c1}{// to be equal to itags}
        \PYG{c+c1}{//}
        \PYG{n}{tagfab}\PYG{p}{.}\PYG{n}{tags\PYGZus{}and\PYGZus{}untags}\PYG{p}{(}\PYG{n}{itags}\PYG{p}{,} \PYG{n}{tilebox}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{state\_error}}} subroutine in \sphinxcode{\sphinxupquote{Src\_nd/Tagging\_nd.f90}} in this example
is simple:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{state\PYGZus{}error}\PYG{p}{(}\PYG{n}{tag}\PYG{p}{,}\PYG{n}{tag\PYGZus{}lo}\PYG{p}{,}\PYG{n}{tag\PYGZus{}hi}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                       \PYG{n}{state}\PYG{p}{,}\PYG{n}{state\PYGZus{}lo}\PYG{p}{,}\PYG{n}{state\PYGZus{}hi}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                       \PYG{n}{set}\PYG{p}{,}\PYG{n}{clear}\PYG{p}{,}\PYG{p}{\PYGZam{}}
                       \PYG{n}{lo}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{,}\PYG{p}{\PYGZam{}}
                       \PYG{n}{dx}\PYG{p}{,}\PYG{n}{problo}\PYG{p}{,}\PYG{n+nb}{time}\PYG{p}{,}\PYG{n}{phierr}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}state\PYGZus{}error\PYGZdq{}}\PYG{p}{)}

  \PYG{k}{implicit }\PYG{k}{none}

\PYG{k}{  }\PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{state\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{state\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{tag\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{tag\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k+kt}{double precision} \PYG{k+kd}{::} \PYG{n}{state}\PYG{p}{(}\PYG{n}{state\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{state\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                            \PYG{n}{state\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{state\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                            \PYG{n}{state\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{state\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
  \PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{tag}\PYG{p}{(}\PYG{n}{tag\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{tag\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                          \PYG{n}{tag\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{tag\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                          \PYG{n}{tag\PYGZus{}lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{tag\PYGZus{}hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
  \PYG{k+kt}{double precision} \PYG{k+kd}{::} \PYG{n}{problo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dx}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{time}\PYG{p}{,}\PYG{n}{phierr}
  \PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{set}\PYG{p}{,}\PYG{n}{clear}

  \PYG{k+kt}{integer}          \PYG{k+kd}{::} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}

  \PYG{c}{! Tag on regions of high phi}
  \PYG{k}{do       }\PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
     \PYG{k}{do    }\PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
           \PYG{k}{if} \PYG{p}{(}\PYG{n}{state}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{p}{.}\PYG{n}{ge}\PYG{p}{.} \PYG{n}{phierr}\PYG{p}{)} \PYG{k}{then}
\PYG{k}{              }\PYG{n}{tag}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{set}
           \PYG{k}{endif}
\PYG{k}{        }\PYG{k}{enddo}
\PYG{k}{     }\PYG{k}{enddo}
\PYG{k}{  }\PYG{k}{enddo}

\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{state\PYGZus{}error}
\end{sphinxVerbatim}


\subsection{FillPatch}
\label{\detokenize{AmrCore:fillpatch}}\label{\detokenize{AmrCore:ss-fillpatch}}
\sphinxAtStartPar
This example has two functions, \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}\DUrole{operator}{::}\DUrole{name}{FillPatch}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}\DUrole{operator}{::}\DUrole{name}{CoarseFillPatch}}},
that make use of functions in AmrCore/AMReX\_FillPatchUtil.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCoreAdv}\DUrole{operator}{::}\DUrole{name}{Advance}}}, we create a temporary \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} called \sphinxcode{\sphinxupquote{\DUrole{name}{Sborder}}}, which
is essentially \(\phi\) but with ghost cells filled in. The valid and ghost cells are filled in from
actual valid data at that level, space\sphinxhyphen{}time interpolated data from the next\sphinxhyphen{}coarser level,
neighboring grids at the same level, or domain boundary conditions
(for examples that have non\sphinxhyphen{}periodic boundary conditions).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MultiFab} \PYG{n+nf}{Sborder}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{S\PYGZus{}new}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{num\PYGZus{}grow}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{FillPatch}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{Sborder}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Sborder}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Several other calls to fillpatch routines are hidden from the user in the regridding process.


\chapter{Amr Source Code}
\label{\detokenize{AmrLevel_Chapter:amr-source-code}}\label{\detokenize{AmrLevel_Chapter:chap-amrlevel}}\label{\detokenize{AmrLevel_Chapter::doc}}
\sphinxAtStartPar
The source code in \sphinxcode{\sphinxupquote{amrex/Src/Amr}} contains a number of classes, most notably
\sphinxcode{\sphinxupquote{Amr}}, \sphinxcode{\sphinxupquote{AmrLevel}}, and \sphinxcode{\sphinxupquote{LevelBld}}.
These classes provide a more well developed set of tools for writing AMR codes
than the classes created for the Advection\_AmrCore tutorial.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Amr}} class is derived from \sphinxcode{\sphinxupquote{AmrCore}}, and manages data across the
entire AMR hierarchy of grids.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{AmrLevel}} class is a pure virtual class for managing data at a
single level of refinement.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{LevelBld}} class is a pure virtual class for defining variable types
and attributes.

\end{itemize}

\sphinxAtStartPar
Many of our mature, public application codes contain derived classes that
inherit directly from \sphinxcode{\sphinxupquote{AmrLevel}}. These include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Castro}} class in our compressible astrophysics code, CASTRO,
(available in the AMReX\sphinxhyphen{}Astro/Castro github repository)

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Nyx}} class in our computational cosmology code, Nyx
(available in the AMReX\sphinxhyphen{}Astro/Nyx github repository).

\item {} 
\sphinxAtStartPar
Our incompressible Navier\sphinxhyphen{}Stokes code, IAMR
(available in the AMReX\sphinxhyphen{}codes/IAMR github repository) has a pure virtual
class called \sphinxcode{\sphinxupquote{NavierStokesBase}} that inherits from \sphinxcode{\sphinxupquote{AmrLevel}}, and an
additional derived class \sphinxcode{\sphinxupquote{NavierStokes}}.

\item {} 
\sphinxAtStartPar
Our low Mach number combustion code PeleLM
(available in the AMReX\sphinxhyphen{}Combustion/PeleLM github repository)
contains a derived class \sphinxcode{\sphinxupquote{PeleLM}} that also inherits from
\sphinxcode{\sphinxupquote{NavierStokesBase}} (but does not use \sphinxcode{\sphinxupquote{NavierStokes}}).

\end{itemize}

\sphinxAtStartPar
The tutorial code in \sphinxcode{\sphinxupquote{amrex/Tutorials/Amr/Advection\_AmrLevel}} gives a simple
example of a class derived from \sphinxcode{\sphinxupquote{AmrLevel}} that can be used to solve the
advection equation on a subcycling\sphinxhyphen{}in\sphinxhyphen{}time AMR hierarchy. Note that example is
essentially the same as the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/AMR\_Tutorial.html}{Advection AmrCore} tutorial and
documentation in the chapter on {\hyperref[\detokenize{AmrCore_Chapter:chap-amrcore}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrCore Source Code}}}}, except now we use the
provided libraries in \sphinxcode{\sphinxupquote{amrex/Src/Amr}}.

\sphinxAtStartPar
The tutorial code also contains a \sphinxcode{\sphinxupquote{LevelBldAdv}} class (derived from
\sphinxcode{\sphinxupquote{LevelBld}} in the Source/Amr directory). This class is used to define
variable types (how many, nodality, interlevel interpolation stencils, etc.).


\section{Amr Class}
\label{\detokenize{AmrLevel:amr-class}}\label{\detokenize{AmrLevel::doc}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{Amr}}} class is designed to manage parts of the computation which do
not belong on a single level, like establishing and updating the hierarchy of
levels, global timestepping, and managing the different \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}}s.
Most likely you will not need to derive any classes from \sphinxcode{\sphinxupquote{\DUrole{name}{Amr}}}. Our
mature application codes use this base class without any derived classes.

\sphinxAtStartPar
One of the most important data members is an array of \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}}s \sphinxhyphen{} the
\sphinxcode{\sphinxupquote{\DUrole{name}{Amr}}} class calls many functions from the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}} class to do
things like advance the solution on a level, compute a time step to be used for
a level, etc.


\section{AmrLevel Class}
\label{\detokenize{AmrLevel:amrlevel-class}}
\sphinxAtStartPar
Pure virtual functions include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{computeInitialDt}}} Compute an array of time steps for each level of
refinement. Called at the beginning of the simulation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{computeNewDt}}} Compute an array of time steps for each level of
refinement. Called at the end of a coarse level advance.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{advance}}} Advance the grids at a level.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{post\_timestep}}} Work after at time step at a given level. In this
tutorial we do the AMR synchronization here.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{post\_regrid}}} Work after regridding. In this tutorial we redistribute
particles.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{post\_init}}} Work after initialization. In this tutorial we perform
AMR synchronization.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{initData}}} Initialize the data on a given level at the beginning of
the simulation.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{init}}} There are two versions of this function used to initialize
data on a level during regridding. One version is specifically for the
case where the level did not previously exist (a newly created refined
level).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{errorEst}}} Perform the tagging at a level for refinement.

\end{itemize}


\subsection{StateData}
\label{\detokenize{AmrLevel:statedata}}
\sphinxAtStartPar
The most important data managed by the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}} is an array of
\sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}}, which holds the scalar fields, etc., in the boxes that
together make up the level.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}} is a class that essentially holds a pair of MultiFabs: one at
the old time and one at the new time. AMReX knows how to interpolate in time
between these states to get data at any intermediate point in time. The main
data that we care about in our applications codes (such as the fluid state)
will be stored as \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}}.  Essentially, data is made \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}}
if we need it to be stored in checkpoints/plotfiles, and/or we want it to be
automatically interpolated when we refine.  An \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}} stores an array
of \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}} (in a C++ array called \sphinxcode{\sphinxupquote{\DUrole{name}{state}}}). We index this array
using integer keys (defined via an \sphinxcode{\sphinxupquote{\DUrole{keyword}{enum}}} in, e.g., \sphinxcode{\sphinxupquote{AmrLevelAdv.H}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n+nc}{StateType} \PYG{p}{\PYGZob{}} \PYG{n}{Phi\PYGZus{}Type} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
                 \PYG{n}{NUM\PYGZus{}STATE\PYGZus{}TYPE} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In our tutorial code, we use the function \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevelAdv}\DUrole{operator}{::}\DUrole{name}{variableSetup}}} to
tell our simulation about the \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}} (e.g., how many variables, ghost
cells, nodality, etc.). Note that if you have more than one \sphinxcode{\sphinxupquote{\DUrole{name}{StateType}}},
each of the different \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}} carried in the state array can have
different numbers of components, ghost cells, boundary conditions, etc.
This is the main reason we separate all this data into separate \sphinxcode{\sphinxupquote{\DUrole{name}{StateData}}}
objects collected together in an indexable array.


\section{LevelBld Class}
\label{\detokenize{AmrLevel:levelbld-class}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{LevelBld}}} class is a pure virtual class for defining variable types
and attributes. To more easily understand its usage, refer to the derived
class, \sphinxcode{\sphinxupquote{\DUrole{name}{LevelBldAdv}}} in the tutorial. The \sphinxcode{\sphinxupquote{\DUrole{name}{variableSetUp}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{variableCleanUp}}} are implemented, and in this tutorial call routines in
the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevelAdv}}} class, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}
\PYG{n+nf}{AmrLevelAdv::variableSetUp} \PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{BL\PYGZus{}ASSERT}\PYG{p}{(}\PYG{n}{desc\PYGZus{}lst}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Get options, set phys\PYGZus{}bc}
    \PYG{n}{read\PYGZus{}params}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{desc\PYGZus{}lst}\PYG{p}{.}\PYG{n}{addDescriptor}\PYG{p}{(}\PYG{n}{Phi\PYGZus{}Type}\PYG{p}{,}\PYG{n}{IndexType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TheCellType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                           \PYG{n}{StateDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Point}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{NUM\PYGZus{}STATE}\PYG{p}{,}
                           \PYG{o}{\PYGZam{}}\PYG{n}{cell\PYGZus{}cons\PYGZus{}interp}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{lo\PYGZus{}bc}\PYG{p}{[}\PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{hi\PYGZus{}bc}\PYG{p}{[}\PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{lo\PYGZus{}bc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{hi\PYGZus{}bc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{INT\PYGZus{}DIR}\PYG{p}{;}   \PYG{c+c1}{// periodic boundaries}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{BCRec} \PYG{n}{bc}\PYG{p}{(}\PYG{n}{lo\PYGZus{}bc}\PYG{p}{,} \PYG{n}{hi\PYGZus{}bc}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{StateDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BndryFunc} \PYG{n}{bndryfunc}\PYG{p}{(}\PYG{n}{nullfill}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{bndryfunc}\PYG{p}{.}\PYG{n}{setRunOnGPU}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// I promise the bc function will launch gpu kernels.}

    \PYG{n}{desc\PYGZus{}lst}\PYG{p}{.}\PYG{n}{setComponent}\PYG{p}{(}\PYG{n}{Phi\PYGZus{}Type}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phi}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{bc}\PYG{p}{,}
                          \PYG{n}{bndryfunc}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We see how to define the \sphinxcode{\sphinxupquote{\DUrole{name}{StateType}}}, including nodality, whether or not
we want the variable to represent a point in time or an interval over time
(useful for returning the time associated with data), the number of ghost
cells, number of components, and the interlevel interpolation (See
AMReX\_Interpolator for various interpolation types). We also see how to specify
physical boundary functions by providing a function (in this case,
\sphinxcode{\sphinxupquote{\DUrole{name}{nullfill}}} since we are not using physical boundary conditions), where
\sphinxcode{\sphinxupquote{\DUrole{name}{nullfill}}} is defined in \sphinxcode{\sphinxupquote{Src/bc\_nullfill.cpp}} in the tutorial source
code.


\section{Example: Advection\_AmrLevel}
\label{\detokenize{AmrLevel:example-advection-amrlevel}}
\sphinxAtStartPar
The Advection\_AmrLevel example is documented in detail
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/AMR\_Tutorial.html\#advection-amrlevel}{here}
in the AMReX tutorial documentation.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Src}} subdirectory contains source code that is specific to this example. Most notably is the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevelAdv}}} class, which is derived from the base
\sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}} class, and the \sphinxcode{\sphinxupquote{\DUrole{name}{LevelBldAdv}}} class, derived from the base
\sphinxcode{\sphinxupquote{\DUrole{name}{LevelBld}}} class as described above. The subdirectory \sphinxcode{\sphinxupquote{Src/Src\_K}} contain GPU kernels.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Exec}} subdirectory contains two examples: \sphinxcode{\sphinxupquote{SingleVortex}} and
\sphinxcode{\sphinxupquote{UniformVelocity}}. Each subdirectory contains problem\sphinxhyphen{}specific source code
used for initialization using a Fortran subroutine (\sphinxcode{\sphinxupquote{Prob.f90}}) and
specifying the velocity fields used in this simulation
(\sphinxcode{\sphinxupquote{face\_velocity\_2d\_K.H}} and \sphinxcode{\sphinxupquote{face\_velocity\_3d\_K.H}} for the 2\sphinxhyphen{}D and 3\sphinxhyphen{}D
problem, respectively). Build the code here by editing the \sphinxcode{\sphinxupquote{GNUmakefile}}
and running \sphinxcode{\sphinxupquote{make}}.

\sphinxAtStartPar
The pseudocode for the main program is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Advection\PYGZus{}AmrLevel Pseudocode */}
\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{Amr} \PYG{n}{amr}\PYG{p}{;}
  \PYG{n}{amr}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{loop} \PYG{p}{\PYGZob{}}
    \PYG{n}{amr}\PYG{p}{.}\PYG{n}{coarseTimeStep}\PYG{p}{(}\PYG{p}{)}
      \PYG{c+cm}{/* compute dt */}
      \PYG{n}{timeStep}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{amr\PYGZus{}level}\PYG{p}{[}\PYG{n}{level}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advance}\PYG{p}{(}\PYG{p}{)}
        \PYG{c+cm}{/* call timeStep r times for next\PYGZhy{}finer level */}
        \PYG{n}{amr\PYGZus{}level}\PYG{p}{[}\PYG{n}{level}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{post\PYGZus{}timestep}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{// AMR synchronization}
      \PYG{n}{postCoarseTimeStep}\PYG{p}{(}\PYG{p}{)}
      \PYG{c+cm}{/* write plotfile and checkpoint */}
  \PYG{p}{\PYGZcb{}}
  \PYG{c+cm}{/* write final plotfile and checkpoint */}
\end{sphinxVerbatim}


\section{Particles}
\label{\detokenize{AmrLevel:particles}}
\sphinxAtStartPar
There is an option to turn on passively advected particles. In the
\sphinxcode{\sphinxupquote{GNUmakefile}}, add the line \sphinxcode{\sphinxupquote{USE\_PARTICLES = TRUE}} and build the code
(do a \sphinxcode{\sphinxupquote{make realclean first}}).
In the inputs file, add the line \sphinxcode{\sphinxupquote{adv.do\_tracers = 1}}.
When you run the code, within each plotfile directory there will be a
subdirectory called “Tracer”.

\sphinxAtStartPar
Copy the files from \sphinxcode{\sphinxupquote{amrex/Tools/Py\_util/amrex\_particles\_to\_vtp}} into
the run directory and type, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{python amrex\PYGZus{}binary\PYGZus{}particles\PYGZus{}to\PYGZus{}vtp.py plt00000 Tracer}
\end{sphinxVerbatim}

\sphinxAtStartPar
To generate a vtp file you can open with ParaView (Refer to the chapter on {\hyperref[\detokenize{Visualization_Chapter:chap-visualization}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualization}}}}).


\chapter{Fork\sphinxhyphen{}Join}
\label{\detokenize{ForkJoin:fork-join}}\label{\detokenize{ForkJoin::doc}}
\sphinxAtStartPar
An AMReX program consists of a set of MPI ranks cooperating together on
distributed data.
Typically, all of the ranks in a job compute in a bulk\sphinxhyphen{}synchronous,
data\sphinxhyphen{}parallel fashion, where every rank does the same sequence of
operations, each on different parts of the distributed data.

\sphinxAtStartPar
The AMReX Fork\sphinxhyphen{}Join functionality described here allows the user to divide the
job’s MPI ranks into subgroups (i.e. \sphinxtitleref{fork}) and assign each subgroup
an independent task to compute in parallel with each other.
After all of the forked child tasks complete, they synchronize
(i.e. \sphinxtitleref{join}), and the parent task continues execution as before.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{fork_join_tasks}.png}
\caption{Example of a fork\sphinxhyphen{}join operation where the parent task’s MPI processes (ranks) are
split into two independent child tasks that execute in parallel and
then join to resume execution of the parent task.}\label{\detokenize{ForkJoin:id1}}\end{figure}

\sphinxAtStartPar
The Fork\sphinxhyphen{}Join operation can also be invoked in a nested fashion,
creating a hierarchy of fork\sphinxhyphen{}join operations, where each fork further
subdivides the ranks of a task into child tasks.
This approach enables heterogeneous computation and reduces the strong
scaling penalty for operations with less inherent parallelism or with
large communication overheads.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.8]{{nested_fork_join_tasks}.png}
\caption{Example of nested fork\sphinxhyphen{}join operations where a child task is further
split into more subtasks.}\label{\detokenize{ForkJoin:id2}}\end{figure}

\sphinxAtStartPar
The fork\sphinxhyphen{}join operation is accomplished by:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
redistributing MultiFab data so that \sphinxstylestrong{all} of the data in each
registered MultiFab is visible to ranks within a subtask, and

\item {} 
\sphinxAtStartPar
dividing the root MPI communicator into sub\sphinxhyphen{}communicators so that
each subgroup of ranks in a tasks will only synchronize with each
other during subtask collectives (e.g. for \sphinxcode{\sphinxupquote{MPI\_Allreduce}}).

\end{enumerate}

\sphinxAtStartPar
When the program starts, all of the ranks in the MPI communicator are
in the root task.


\chapter{I/O (Plotfile, Checkpoint)}
\label{\detokenize{IO_Chapter:i-o-plotfile-checkpoint}}\label{\detokenize{IO_Chapter:chap-io}}\label{\detokenize{IO_Chapter::doc}}
\sphinxAtStartPar
In this chapter, we will discuss parallel I/O capabilities for mesh
data in AMReX. The section on {\hyperref[\detokenize{Particle:sec-particles-io}]{\sphinxcrossref{\DUrole{std,std-ref}{Particle IO}}}} will discuss I/O for
particle data.


\section{Plotfile}
\label{\detokenize{IO:plotfile}}\label{\detokenize{IO:sec-io}}\label{\detokenize{IO::doc}}
\sphinxAtStartPar
AMReX has its own native plotfile format. Many visualization tools are
available for AMReX plotfiles (see the chapter on {\hyperref[\detokenize{Visualization_Chapter:chap-visualization}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualization}}}}).
AMReX provides the following two functions for writing a generic AMReX plotfile.
Many AMReX application codes may have their own plotfile routines that store
additional information such as compiler options, git hashes of the
source codes and \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} runtime parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{WriteSingleLevelPlotfile} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{plotfilename}\PYG{p}{,}
                               \PYG{k}{const} \PYG{n}{MultiFab} \PYG{o}{\PYGZam{}}\PYG{n}{mf}\PYG{p}{,}
                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{varnames}\PYG{p}{,}
                               \PYG{k}{const} \PYG{n}{Geometry} \PYG{o}{\PYGZam{}}\PYG{n}{geom}\PYG{p}{,}
                               \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,}
                               \PYG{k+kt}{int} \PYG{n}{level\PYGZus{}step}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{void} \PYG{n+nf}{WriteMultiLevelPlotfile} \PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{o}{\PYGZam{}}\PYG{n}{plotfilename}\PYG{p}{,}
                              \PYG{k+kt}{int} \PYG{n}{nlevels}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{mf}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{varnames}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{geom}\PYG{p}{,}
                              \PYG{n}{Real} \PYG{n}{time}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{level\PYGZus{}steps}\PYG{p}{,}
                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{IntVect}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{ref\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{WriteSingleLevelPlotfile}}} is for single level runs and
\sphinxcode{\sphinxupquote{\DUrole{name}{WriteMultiLevelPlotfile}}} is for multiple levels. The name of the
plotfile is specified by the plotfilename argument. This is the
top level directory name for the plotfile. In AMReX convention, the
plotfile name consist of letters followed by numbers (e.g.,
plt00258). \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Concatenate}}} is a useful helper function for
making such strings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{istep} \PYG{o}{=} \PYG{l+m+mi}{258}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{pfname} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Concatenate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{istep}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// plt00258}

\PYG{c+c1}{// By default there are 5 digits, but we can change it to say 4.}
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{pfname2} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Concatenate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{istep}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// plt0258}

\PYG{n}{istep} \PYG{o}{=}\PYG{l+m+mi}{1234567}\PYG{p}{;}  \PYG{c+c1}{// Having more than 5 digits is OK.}
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{pfname3} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Concatenate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{istep}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// plt1234567}
\end{sphinxVerbatim}

\sphinxAtStartPar
The argument \sphinxcode{\sphinxupquote{\DUrole{name}{mf}}} above (\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} for single level and
\sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{keyword}{const} \DUrole{name}{MultiFab}\DUrole{operator}{*\textgreater{}}}} for multi\sphinxhyphen{}level) is the data to be written
to the disk. Note that many visualization tools expect this to be
cell\sphinxhyphen{}centered data. So for nodal data, we need to convert them to
cell\sphinxhyphen{}centered data through some kind of averaging. Also note that if
you have data at each AMR level in several MultiFabs, you need
to build a new MultiFab at each level to hold all the data on
that level. This involves local data copy in memory and is not
expected to significantly increase the total wall time for writing
plotfiles. For the multi\sphinxhyphen{}level version, the function expects
\sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{keyword}{const} \DUrole{name}{MultiFab}\DUrole{operator}{*\textgreater{}}}}, whereas the multi\sphinxhyphen{}level data are often
stored as \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{unique\_ptr}\DUrole{operator}{\textless{}}\DUrole{name}{MultiFab}\DUrole{operator}{\textgreater{}\textgreater{}}}}. AMReX has a
helper function for this and one can use it as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WriteMultiLevelPlotfile}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetVecOfConstPtrs}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The argument \sphinxcode{\sphinxupquote{\DUrole{name}{varnames}}} has the names for each component of the
MultiFab data. The size of the Vector should be equal to the
number of components. The argument \sphinxcode{\sphinxupquote{\DUrole{name}{geom}}} is for passing
\sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} objects that contain the physical domain
information. The argument \sphinxcode{\sphinxupquote{\DUrole{name}{time}}} is for the time associated with the
data. The argument \sphinxcode{\sphinxupquote{\DUrole{name}{level\_step}}} is for the current time step
associated with the data. For multi\sphinxhyphen{}level plotfiles, the argument
\sphinxcode{\sphinxupquote{\DUrole{name}{nlevels}}} is the total number of levels, and we also need to provide
the refinement ratio via an \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}}} of size nlevels\sphinxhyphen{}1.

\sphinxAtStartPar
We note that AMReX does not overwrite old plotfiles if the new
plotfile has the same name. The old plotfiles will be renamed to
new directories named like plt00350.old.46576787980.


\section{Async Output}
\label{\detokenize{IO:async-output}}
\sphinxAtStartPar
AMReX provides the ability to print MultiFabs, plotfiles and
particle data asynchronously.  Asynchronous output works by creating
a copy of the data at the time of the call, which is written to disk
by a persistent thread created during AMReX’s initialization.  This allows
the calculation to continue immediately, which can drastically reduce
walltime spent writing to disk.

\sphinxAtStartPar
If the number of output files is less than the number of MPI ranks,
AMReX’s async output requires MPI to be initialized with THREAD\_MULTIPLE
support. THREAD\_MULTIPLE support allows multiple unique threads to run unique
MPI calls simultaneously.  This support is required to allow AMReX applications
to perform MPI work while the Async Output concurrently pings ranks to signal
that they can safely begin writing to their assigned files.  However,
THREAD\_MULTIPLE can introduce additional overhead as each threads’ MPI operations
must be scheduled safely around each other. Therefore, AMReX uses a lower level
of support, SERIALIZED, by default and applications have to turn on THREAD\_MULTIPLE
support.

\sphinxAtStartPar
To turn on Async Output, use the input flag \sphinxcode{\sphinxupquote{amrex.async\_out=1}}.  The number
of output files can also be set, using \sphinxcode{\sphinxupquote{amrex.async\_out\_nfiles}}.  The default
number of files is \sphinxcode{\sphinxupquote{64}}. If the number of ranks is larger than the number of
files, THREAD\_MULTIPLE must be turned on by adding
\sphinxcode{\sphinxupquote{MPI\_THREAD\_MULTIPLE=TRUE}} to the GNUMakefile. Otherwise, AMReX
will throw an error.

\sphinxAtStartPar
Async Output works for a wide range of AMReX calls, including:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amrex::WriteSingleLevelPlotfile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amrex::WriteMultiLevelPlotfile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amrex::WriteMLMF()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{VisMF::AsyncWrite()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ParticleContainer::Checkpoint()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ParticleContainer::WritePlotFile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Amr::writePlotFile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Amr::writeSmallPlotFile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Amr::checkpoint()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{AmrLevel::writePlotFile()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{StateData::checkPoint()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FabSet::write()}}

\end{itemize}

\sphinxAtStartPar
Be aware: when using Async Output, a thread is spawned and exclusively used
to perform output throughout the runtime.  As such, you may oversubscribe
resources if you launch an AMReX application that assigns all available
hardware threads in another way, such as OpenMP.  If you see any degradation
when using Async Output and OpenMP, try using one less thread in
\sphinxcode{\sphinxupquote{OMP\_NUM\_THREADS}} to prevent oversubscription and get more consistent
results.


\section{Checkpoint File}
\label{\detokenize{IO:checkpoint-file}}
\sphinxAtStartPar
Checkpoint files are used for restarting simulations from where the
checkpoints are written. Each application code has its own set of
data needed for restart. AMReX provides I/O functions for basic
data structures like \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}. These
functions can be used to build codes for reading and writing
checkpoint files. Since each application code has its own
requirement, there is no standard AMReX checkpoint format.
However we have provided an example restart capability in the tutorial
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/AMR\_Tutorial.html\#advection-amrcore}{Advection AmrCore}.
Refer to the functions \sphinxcode{\sphinxupquote{\DUrole{name}{ReadCheckpointFile}\DUrole{punctuation}{()}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{WriteCheckpointFile}\DUrole{punctuation}{()}}} in this tutorial.

\sphinxAtStartPar
A checkpoint file is actually a directory with name, e.g.,
\sphinxcode{\sphinxupquote{chk00010}} containing a \sphinxcode{\sphinxupquote{Header}} (text) file, along with
subdirectories \sphinxcode{\sphinxupquote{Level\_0}}, \sphinxcode{\sphinxupquote{Level\_1}}, etc. containing the
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} data at each level of refinement.
The \sphinxcode{\sphinxupquote{Header}} file contains problem\sphinxhyphen{}specific data (such as the
finest level, simulation time, time step, etc.), along with a printout
of the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} at each level of refinement.

\sphinxAtStartPar
When starting a simulation from a checkpoint file, a typical sequence in the code
could be:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Read in the \sphinxcode{\sphinxupquote{Header}} file data (except for the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} data).

\item {} 
\sphinxAtStartPar
For each level of refinement, do the following in order:

\sphinxAtStartPar
\textendash{} Read in the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}

\sphinxAtStartPar
\textendash{} Build a \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}

\sphinxAtStartPar
\textendash{} Define any \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}}, etc. objects that are built upon the
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and the \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}

\sphinxAtStartPar
\textendash{} Read in the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} data

\end{itemize}

\sphinxAtStartPar
We do this one level at a time because when you create a distribution map,
it checks how much allocated \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} data already exists before assigning
grids to processors.

\sphinxAtStartPar
Typically a checkpoint file is a directory containing some text files
and sub\sphinxhyphen{}directories (e.g., \sphinxcode{\sphinxupquote{Level\_0}} and \sphinxcode{\sphinxupquote{Level\_1}})
containing various data. It is a good idea that we fist make these
directories ready for subsequently writing to the disk. For example,
to build directories \sphinxcode{\sphinxupquote{chk00010}}, \sphinxcode{\sphinxupquote{chk00010/Level\_0}}, and
\sphinxcode{\sphinxupquote{chk00010/Level\_1}}, you could write:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{checkpointname} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Concatenate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{chk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Print}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Writing checkpoint }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{checkpointname} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{nlevels} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{bool} \PYG{n}{callBarrier} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}

\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} prebuild a hierarchy of directories}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} dirName is built first.  if dirName exists, it is renamed.  then build}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} dirName/subDirPrefix\PYGZus{}0 .. dirName/subDirPrefix\PYGZus{}nlevels\PYGZhy{}1}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} if callBarrier is true, call ParallelDescriptor::Barrier()}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} after all directories are built}
\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ParallelDescriptor::IOProcessor() creates the directories}
\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PreBuildDirectorHierarchy}\PYG{p}{(}\PYG{n}{checkpointname}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Level\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nlevels}\PYG{p}{,} \PYG{n}{callBarrier}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A checkpoint file of AMReX application codes often has a clear text
Header file that only the I/O process writes to it using
\sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{ofstream}}}. The Header file contains problem\sphinxhyphen{}dependent
information such as
the time, the physical domain size, grids, etc. that are necessary for
restarting the simulation. To guarantee that precision is not lost
for storing floating point number like time in clear text file, the
file stream’s precision needs to be set properly. And a stream buffer
can also be used. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// write Header file}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IOProcessor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}

    \PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IO\PYGZus{}Buffer} \PYG{n+nf}{io\PYGZus{}buffer}\PYG{p}{(}\PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IO\PYGZus{}Buffer\PYGZus{}Size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream} \PYG{n}{HeaderFile}\PYG{p}{;}
    \PYG{n}{HeaderFile}\PYG{p}{.}\PYG{n}{rdbuf}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pubsetbuf}\PYG{p}{(}\PYG{n}{io\PYGZus{}buffer}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{io\PYGZus{}buffer}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n+nf}{HeaderFileName}\PYG{p}{(}\PYG{n}{checkpointname} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Header}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{HeaderFile}\PYG{p}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{HeaderFileName}\PYG{p}{.}\PYG{n}{c\PYGZus{}str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{o}{:}\PYG{o}{:}\PYG{n}{out}   \PYG{o}{|}
                                            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{o}{:}\PYG{o}{:}\PYG{n}{trunc} \PYG{o}{|}
                                            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ofstream}\PYG{o}{:}\PYG{o}{:}\PYG{n}{binary}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(} \PYG{o}{!} \PYG{n}{HeaderFile}\PYG{p}{.}\PYG{n}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FileOpenFailed}\PYG{p}{(}\PYG{n}{HeaderFileName}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{HeaderFile}\PYG{p}{.}\PYG{n}{precision}\PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// write out title line}
    \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Checkpoint file for AmrCoreAdv}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// write out finest\PYGZus{}level}
    \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{finest\PYGZus{}level} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// write out array of istep}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{istep}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{istep}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// write out array of dt}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{dt}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// write out array of t\PYGZus{}new}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{t\PYGZus{}new}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t\PYGZus{}new}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

    \PYG{c+c1}{// write the BoxArray at each level}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{boxArray}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{.}\PYG{n}{writeOn}\PYG{p}{(}\PYG{n}{HeaderFile}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{HeaderFile} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{VisMF}}} is a class that can be used to perform
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} I/O in parallel. How many processes are allowed to
perform I/O simultaneously can be set via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SetNOutFiles}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// up to 64 processes, which is also the default.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The optimal number is of course system dependent. The following code
shows how to write a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// write the MultiFab data to, e.g., chk00010/Level\PYGZus{}0/}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,}
                 \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MultiFabFileFullPrefix}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{checkpointname}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Level\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phi}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should also be noted that all the
data including those in ghost cells are written/read by
\sphinxcode{\sphinxupquote{\DUrole{name}{VisMF}\DUrole{operator}{::}\DUrole{name}{Write}\DUrole{operator}{/}\DUrole{name}{Read}}}.

\sphinxAtStartPar
For reading the Header file, AMReX can have the I/O process
read the file from the disk and broadcast it to others as
\sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{keyword,type}{char}\DUrole{operator}{\textgreater{}}}}. Then all processes can read the information with
\sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{istringstream}}}. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n+nf}{File}\PYG{p}{(}\PYG{n}{restart\PYGZus{}chkfile} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/Header}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{IO\PYGZus{}Buffer} \PYG{n+nf}{io\PYGZus{}buffer}\PYG{p}{(}\PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetIOBufferSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{n}{fileCharPtr}\PYG{p}{;}
\PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ReadAndBcastFile}\PYG{p}{(}\PYG{n}{File}\PYG{p}{,} \PYG{n}{fileCharPtr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n+nf}{fileCharPtrString}\PYG{p}{(}\PYG{n}{fileCharPtr}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istringstream} \PYG{n+nf}{is}\PYG{p}{(}\PYG{n}{fileCharPtrString}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istringstream}\PYG{o}{:}\PYG{o}{:}\PYG{n}{in}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{line}\PYG{p}{,} \PYG{n}{word}\PYG{p}{;}

\PYG{c+c1}{// read in title line}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// read in finest\PYGZus{}level}
\PYG{n}{is} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;}
\PYG{n}{GotoNextLine}\PYG{p}{(}\PYG{n}{is}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// read in array of istep}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istringstream} \PYG{n+nf}{lis}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lis} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{word}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{istep}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// read in array of dt}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istringstream} \PYG{n+nf}{lis}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lis} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{word}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// read in array of t\PYGZus{}new}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{getline}\PYG{p}{(}\PYG{n}{is}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{istringstream} \PYG{n+nf}{lis}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{while} \PYG{p}{(}\PYG{n}{lis} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{word}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{t\PYGZus{}new}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{stod}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following code how to read in a \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}, create a
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}, build \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}} data,
and read in a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} from a checkpoint file, on a level\sphinxhyphen{}by\sphinxhyphen{}level basis:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}

    \PYG{c+c1}{// read in level \PYGZsq{}lev\PYGZsq{} BoxArray from Header}
    \PYG{n}{BoxArray} \PYG{n}{ba}\PYG{p}{;}
    \PYG{n}{ba}\PYG{p}{.}\PYG{n}{readFrom}\PYG{p}{(}\PYG{n}{is}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{GotoNextLine}\PYG{p}{(}\PYG{n}{is}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// create a distribution mapping}
    \PYG{n}{DistributionMapping} \PYG{n}{dm} \PYG{p}{\PYGZob{}} \PYG{n}{ba}\PYG{p}{,} \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NProcs}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZcb{}}\PYG{p}{;}

    \PYG{c+c1}{// set BoxArray grids and DistributionMapping dmap in AMReX\PYGZus{}AmrMesh.H class}
    \PYG{n}{SetBoxArray}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{ba}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{SetDistributionMap}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// build MultiFab and FluxRegister data}
    \PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{nghost} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{phi\PYGZus{}old}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{nghost}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{nghost}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{lev} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{do\PYGZus{}reflux}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{flux\PYGZus{}reg}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}unique}\PYG{o}{\PYGZlt{}}\PYG{n}{FluxRegister}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refRatio}\PYG{p}{(}\PYG{n}{lev}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// read in the MultiFab data}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{finest\PYGZus{}level}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{VisMF}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Read}\PYG{p}{(}\PYG{n}{phi\PYGZus{}new}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,}
                \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MultiFabFileFullPrefix}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{restart\PYGZus{}chkfile}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Level\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phi}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be emphasized that calling \sphinxcode{\sphinxupquote{\DUrole{name}{VisMF}\DUrole{operator}{::}\DUrole{name}{Read}}} with an empty
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} (i.e., no memory allocated for floating point data)
will result in a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with a new \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}
that could be different from any other existing
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} objects and is not recommended.


\chapter{Linear Solvers}
\label{\detokenize{LinearSolvers_Chapter:linear-solvers}}\label{\detokenize{LinearSolvers_Chapter:chap-linearsolvers}}\label{\detokenize{LinearSolvers_Chapter::doc}}
\sphinxAtStartPar
AMReX supports both single\sphinxhyphen{}level solves and composite solves on multiple AMR levels,
with the scalar solution to the linear system defined on either cell centers or nodes.
AMReX also supports solution of linear systems with embedded boundaries.
(See chapter {\hyperref[\detokenize{EB_Chapter:chap-eb}]{\sphinxcrossref{\DUrole{std,std-ref}{Embedded Boundaries}}}} for more details on the embedded boundary representation of
complex geometry.)

\sphinxAtStartPar
The default solution technique is geometric multigrid, but AMReX includes native
BiCGStab solvers for a single level as well as interfaces to the hypre library.

\sphinxAtStartPar
In this Chapter we give an overview of the linear solvers in AMReX
that solve linear systems in the canonical form
\begin{equation}\label{equation:LinearSolvers_Chapter:eqn::abeclap}
\begin{split}(A \alpha - B \nabla \cdot \beta \nabla ) \phi = f,\end{split}
\end{equation}
\sphinxAtStartPar
where \(A\) and \(B\) are scalar constants,
\(\alpha\) and \(\beta\) are scalar fields,
\(\phi\) is the unknown,
and \(f\) is the right\sphinxhyphen{}hand side of the equation.  Note
that Poisson’s equation \(\nabla^2 \phi = f\) is a special case
of the canonical form.  The solution \(\phi\) is at either
cell centers or nodes.

\sphinxAtStartPar
For the cell\sphinxhyphen{}centered solver, \(\alpha\), \(\phi\) and \(f\)
are represented by cell\sphinxhyphen{}centered MultiFabs,
and \(\beta\) is represented by \sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} face type
MultiFabs, i.e.  there are separate MultiFabs for the \(\beta\)
coefficient in each coordinate direction.

\sphinxAtStartPar
For the nodal solver, \(A\) and \(\alpha\) are assumed to be zero,
\(\phi\) and \(f\) are nodal,
and \(\beta\) (which we later refer to as \(\sigma\)) is cell\sphinxhyphen{}centered.

\sphinxAtStartPar
In addition to these solvers, AMReX has support for tensor solves used
to calculate the viscous terms that appear in the compressible Navier\sphinxhyphen{}Stokes
equations.  In these solves, all components of the velocity field are solved
for simultaneously.  The tensor solve functionality is only available for
cell\sphinxhyphen{}centered velocity.

\sphinxAtStartPar
The tutorials in \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{Linear Solvers} show examples of
using the solvers.  The tutorial
\sphinxcode{\sphinxupquote{amrex/Tutorials/Basic/HeatEquation\_EX3\_C}} shows how to solve the
heat equation implicitly using the solver.  The tutorials also show
how to add linear solvers into the build system.


\section{MLMG and Linear Operator Classes}
\label{\detokenize{LinearSolvers:mlmg-and-linear-operator-classes}}\label{\detokenize{LinearSolvers::doc}}
\sphinxAtStartPar
Multi\sphinxhyphen{}Level Multi\sphinxhyphen{}Grid or \sphinxcode{\sphinxupquote{MLMG}} is a class for solving the linear
system using the geometric multigrid method.  The constructor of
\sphinxcode{\sphinxupquote{MLMG}} takes the reference to \sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}}}, an abstract base
class of various linear operator
classes, \sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{MLPoisson}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{MLNodeLaplacian}}}, etc.  We choose the type of linear operator
class according to the type the linear system to solve.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}} for cell\sphinxhyphen{}centered canonical form (equation \eqref{equation:LinearSolvers_Chapter:eqn::abeclap}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLPoisson}}} for cell\sphinxhyphen{}centered constant coefficient Poisson’s
equation \(\nabla^2 \phi = f\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLNodeLaplacian}}} for nodal variable coefficient Poisson’s
equation \(\nabla \cdot (\sigma \nabla \phi) = f\).

\end{itemize}

\sphinxAtStartPar
The constructors of these linear operator classes are in the form like
below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLABecLaplacian} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}geom}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BoxArray}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grids}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DistributionMapping}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dmap}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{LPInfo}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}info} \PYG{o}{=} \PYG{n}{LPInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                 \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{FabFactory}\PYG{o}{\PYGZlt{}}\PYG{n}{FArrayBox}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}factory} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It takes \sphinxcode{\sphinxupquote{\DUrole{name}{Vectors}}} of \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}.  The arguments are \sphinxcode{\sphinxupquote{\DUrole{name}{Vectors}}} because MLMG can
do multi\sphinxhyphen{}level composite solve.  If you are using it for single\sphinxhyphen{}level,
you can do

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Given Geometry geom, BoxArray grids, and DistributionMapping dmap on single level}
\PYG{n}{MLABecLaplacian} \PYG{n+nf}{mlabeclaplacian}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{geom}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{grids}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{dmap}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to let the compiler construct \sphinxcode{\sphinxupquote{\DUrole{name}{Vectors}}} for you.  Recall that the
classes \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}}, and
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} are defined in chapter {\hyperref[\detokenize{Basics_Chapter:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics}}}}.  There are
two new classes that are optional parameters.  \sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}}} is a
class for passing parameters.  \sphinxcode{\sphinxupquote{\DUrole{name}{FabFactory}}} is used in problems
with embedded boundaries (chapter {\hyperref[\detokenize{EB_Chapter:chap-eb}]{\sphinxcrossref{\DUrole{std,std-ref}{Embedded Boundaries}}}}).

\sphinxAtStartPar
After the linear operator is built, we need to set up boundary
conditions.  This will be discussed later in section
{\hyperref[\detokenize{LinearSolvers:sec-linearsolver-bc}]{\sphinxcrossref{\DUrole{std,std-ref}{Boundary Conditions}}}}.

\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}}, we next need to call member functions

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setScalars} \PYG{p}{(}\PYG{n}{Real} \PYG{n}{A}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{B}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{setACoeffs} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{amrlev}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{alpha}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{setBCoeffs} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{amrlev}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab} \PYG{k}{const}\PYG{o}{*}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{beta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to set up the coefficients for equation \eqref{equation:LinearSolvers_Chapter:eqn::abeclap}. This is unnecessary for
\sphinxcode{\sphinxupquote{\DUrole{name}{MLPoisson}}}, as there are no coefficients to set.  For \sphinxcode{\sphinxupquote{\DUrole{name}{MLNodeLaplacian}}},
one needs to call the member function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setSigma} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{amrlev}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{amrlev}}} parameter should be zero for single\sphinxhyphen{}level
solves.  For multi\sphinxhyphen{}level solves, each level needs to be provided with
\sphinxcode{\sphinxupquote{alpha}} and \sphinxcode{\sphinxupquote{beta}}, or \sphinxcode{\sphinxupquote{sigma}}.  For composite solves, \sphinxcode{\sphinxupquote{\DUrole{name}{amrlev}}} 0 will
mean the lowest level for the solver, which is not necessarily the lowest
level in the AMR hierarchy. This is so solves can be done on different sections
of the AMR hierarchy, e.g. on AMR levels 3 to 5.

\sphinxAtStartPar
After boundary conditions and coefficients are prescribed, the linear
operator is ready for an MLMG object like below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLMG} \PYG{n+nf}{mlmg}\PYG{p}{(}\PYG{n}{mlabeclaplacian}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Optional parameters can be set (see section {\hyperref[\detokenize{LinearSolvers:sec-linearsolver-pars}]{\sphinxcrossref{\DUrole{std,std-ref}{Parameters}}}}),
and then we can use the \sphinxcode{\sphinxupquote{MLMG}} member function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n+nf}{solve} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}sol}\PYG{p}{,}
            \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}rhs}\PYG{p}{,}
            \PYG{n}{Real} \PYG{n}{a\PYGZus{}tol\PYGZus{}rel}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{a\PYGZus{}tol\PYGZus{}abs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to solve the problem given an initial guess and a right\sphinxhyphen{}hand side.
Zero is a perfectly fine initial guess.  The two \sphinxcode{\sphinxupquote{\DUrole{name}{Reals}}} in the argument
list are the targeted relative and absolute error tolerances.
The solver will terminate when one of these targets is met.
Set the absolute tolerance to zero if one
does not have a good value for it.  The return value of \sphinxcode{\sphinxupquote{\DUrole{name}{solve}}}
is the max\sphinxhyphen{}norm error.

\sphinxAtStartPar
After the solver returns successfully, if needed, we can call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{compResidual} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}res}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}sol}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}rhs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to compute residual (i.e., \(f - L(\phi)\)) given the solution and
the right\sphinxhyphen{}hand side.  For cell\sphinxhyphen{}centered solvers, we can also call the
following functions to compute gradient \(\nabla \phi\) and fluxes
\(-B \nabla \phi\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{getGradSolution} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{*}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grad\PYGZus{}sol}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{getFluxes}       \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{*}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}fluxes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Boundary Conditions}
\label{\detokenize{LinearSolvers:boundary-conditions}}\label{\detokenize{LinearSolvers:sec-linearsolver-bc}}
\sphinxAtStartPar
We now discuss how to set up boundary conditions for linear operators.
In the following, physical domain boundaries refer to the boundaries
of the physical domain, whereas coarse/fine boundaries refer to the
boundaries between AMR levels. The following steps must be
followed in the exact order.

\sphinxAtStartPar
1) For any type of solver, we first need to set physical domain boundary types via the \sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}}} member
function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setDomainBC} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{BCType}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{lobc}\PYG{p}{,}  \PYG{c+c1}{// for lower ends}
                  \PYG{k}{const} \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{BCType}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{hibc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// for higher ends}
\end{sphinxVerbatim}

\sphinxAtStartPar
The supported BC types at the physical domain boundaries are
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LinOpBCType}\DUrole{operator}{::}\DUrole{name}{Periodic}}} for periodic boundary.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LinOpBCType}\DUrole{operator}{::}\DUrole{name}{Dirichlet}}} for Dirichlet boundary condition.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LinOpBCType}\DUrole{operator}{::}\DUrole{name}{Neumann}}} for homogeneous Neumann boundary condition.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LinOpBCType}\DUrole{operator}{::}\DUrole{name}{inhomogNeumann}}} for inhomogeneous Neumann boundary condition.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LinOpBCType}\DUrole{operator}{::}\DUrole{name}{reflect\_odd}}} for reflection with sign changed.

\end{itemize}

\sphinxAtStartPar
2) Cell\sphinxhyphen{}centered solvers only:
if we want to do a linear solve where the boundary conditions on the
coarsest AMR level of the solve come from a coarser level (e.g. the
base AMR level of the solve is \textgreater{} 0 and does not cover the entire domain),
we must explicitly provide the coarser data.  Boundary conditions from a
coarser level are always Dirichlet.

\sphinxAtStartPar
Note that this step, if needed, must be performed before the step below.
The \sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}}} member function for this step is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setCoarseFineBC} \PYG{p}{(}\PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*} \PYG{n}{crse}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{crse\PYGZus{}ratio}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{\DUrole{keyword}{const} \DUrole{name}{MultiFab}\DUrole{operator}{*} \DUrole{name}{crse}}} contains the Dirichlet boundary
values at the coarse resolution, and \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{crse\_ratio}}} (e.g., 2)
is the refinement ratio between the coarsest solver level and the AMR
level below it.  The MultiFab crse does not need to have ghost cells itself.
If the coarse grid bc’s for the solve are identically zero, \sphinxcode{\sphinxupquote{\DUrole{keyword}{nullptr}}}
can be passed instead of \sphinxcode{\sphinxupquote{\DUrole{name}{crse}}}.

\sphinxAtStartPar
3) Cell\sphinxhyphen{}centered solvers only:
before the solve one must always call the \sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}}} member function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setLevelBC} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{amrlev}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*} \PYG{n}{levelbcdata}\PYG{p}{,}
                         \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*} \PYG{n}{robinbc\PYGZus{}a}\PYG{p}{,}
                         \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*} \PYG{n}{robinbc\PYGZus{}b}\PYG{p}{,}
                         \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{*} \PYG{n}{robinbc\PYGZus{}f}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we want to supply an inhomogeneous Dirichlet, inhomogeneous Neumann, or
Robin boundary conditions at the domain boundaries, we must supply those values
in \sphinxcode{\sphinxupquote{MultiFab* levelbcdata}}, which must have at least one ghost cell.
Note that the argument \sphinxcode{\sphinxupquote{\DUrole{name}{amrlev}}} is relative to the solve, not
necessarily the full AMR hierarchy; amrlev = 0 refers to the coarsest
level of the solve.

\sphinxAtStartPar
If the boundary condition is Dirichlet the ghost cells outside the
domain boundary of \sphinxcode{\sphinxupquote{levelbcdata}} must hold the value of the solution
at the domain boundary;
if the boundary condition is Neumann those ghost cells must hold
the value of the gradient of the solution normal to the boundary
(e.g. it would hold dphi/dx on both the low and high faces in the x\sphinxhyphen{}direction).

\sphinxAtStartPar
If the boundary conditions contain no inhomogeneous Dirichlet or Neumann boundaries,
we can pass \sphinxcode{\sphinxupquote{\DUrole{keyword}{nullptr}}} instead of a MultiFab.

\sphinxAtStartPar
We can use the solution array itself to hold these values;
the values are copied to internal arrays and will not be over\sphinxhyphen{}written
when the solution array itself is being updated by the solver.
Note, however, that this call does not provide an initial guess for the solve.

\sphinxAtStartPar
It should be emphasized that the data in \sphinxcode{\sphinxupquote{levelbcdata}} for
Dirichlet or Neumann boundaries are assumed to be exactly on the face
of the physical domain; storing these values in the ghost cell of
a cell\sphinxhyphen{}centered array is a convenience of implementation.


\section{Parameters}
\label{\detokenize{LinearSolvers:parameters}}\label{\detokenize{LinearSolvers:sec-linearsolver-pars}}
\sphinxAtStartPar
There are many parameters that can be set.  Here we discuss some
commonly used ones.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}\DUrole{operator}{::}\DUrole{name}{setVerbose}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{setVerbose}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}} and
\sphinxcode{\sphinxupquote{\DUrole{name,label}{MLMG}\DUrole{punctuation}{:}\DUrole{name}{setBottomVerbose}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}} control the verbosity of the
linear operator, multigrid solver and the bottom solver, respectively.

\sphinxAtStartPar
The multigrid solver is an iterative solver.  The maximal number of
iterations can be changed with \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{setMaxIter}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}}.  We can
also do a fixed number of iterations with
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{setFixedIter}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}}.  By default, V\sphinxhyphen{}cycle is used.  We can
use \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{setMaxFmgIter}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}} to control how many full multigrid
cycles can be done before switching to V\sphinxhyphen{}cycle.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}\DUrole{operator}{::}\DUrole{name}{setMaxCoarseningLevel}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}} can be used to control the
maximal number of multigrid levels.  We usually should not call this
function.  However, we sometimes build the solver to simply apply the
operator (e.g., \(L(\phi)\)) without needing to solve the system.
We can do something as follows to avoid the cost of building coarsened
operators for the multigrid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLABecLaplacian} \PYG{n+nf}{mlabeclap}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{geom}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{grids}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{dmap}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{LPInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{setMaxCoarseningLevel}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// set up BC}
\PYG{c+c1}{// set up coefficients}
\PYG{n}{MLMG} \PYG{n+nf}{mlmg}\PYG{p}{(}\PYG{n}{mlabeclap}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// out = L(in)}
\PYG{n}{mlmg}\PYG{p}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{out}\PYG{p}{,} \PYG{n}{in}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// here both in and out are const Vector\PYGZlt{}MultiFab*\PYGZgt{}\PYGZam{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
At the bottom of the multigrid cycles, we use a \sphinxcode{\sphinxupquote{bottom solver}} which may be
different than the relaxation used at the other levels. The default bottom solver is the
biconjugate gradient stabilized method, but can easily be changed with the \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}}} member method

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setBottomSolver} \PYG{p}{(}\PYG{n}{BottomSolver} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Available choices are
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{bicgstab}}}: The default.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{cg}}}: The conjugate gradient method.  The
matrix must be symmetric.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{smoother}}}: Smoother such as Gauss\sphinxhyphen{}Seidel.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{bicgcg}}}: Start with bicgstab. Switch to cg
if bicgstab fails.  The matrix must be symmetric.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{cgbicg}}}: Start with cg. Switch to bicgstab
if cg fails.  The matrix must be symmetric.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{hypre}}}: One of the solvers available through hypre;
see the section below on External Solvers

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}\DUrole{operator}{::}\DUrole{name}{BottomSolver}\DUrole{operator}{::}\DUrole{name}{petsc}}}: Currently for cell\sphinxhyphen{}centered only.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}\DUrole{operator}{::}\DUrole{name}{setAgglomeration}\DUrole{punctuation}{(}\DUrole{keyword,type}{bool}\DUrole{punctuation}{)}}} (by default true) can be used
continue to coarsen the multigrid by copying what would have been the
bottom solver to a new \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with a new \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} with
fewer, larger grids, to allow for additional coarsening.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}\DUrole{operator}{::}\DUrole{name}{setConsolidation}\DUrole{punctuation}{(}\DUrole{keyword,type}{bool}\DUrole{punctuation}{)}}} (by default true) can be used
continue to transfer a multigrid problem to fewer MPI ranks.
There are more setting sucsh as \sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}\DUrole{operator}{::}\DUrole{name}{setConsolidationGridSize}\DUrole{punctuation}{(}\DUrole{keyword,type}{int}\DUrole{punctuation}{)}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{consolidation\_threshold}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{consolidation\_ratio}}}, and
\sphinxcode{\sphinxupquote{\DUrole{name}{consolidation\_strategy}}}, to give control over how this process works.

\end{itemize}


\section{Boundary Stencils for Cell\sphinxhyphen{}Centered Solvers}
\label{\detokenize{LinearSolvers:boundary-stencils-for-cell-centered-solvers}}
\sphinxAtStartPar
We have the option using the \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG}}} member method

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{setMaxOrder} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{maxorder}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
to set the order of the cell\sphinxhyphen{}centered linear operator stencil at physical boundaries
with Dirichlet boundary conditions and at coarse\sphinxhyphen{}fine boundaries.  In both of these
cases, the boundary value is not defined at the center of the ghost cell.
The order determines the number of interior cells that are used in the extrapolation
of the boundary value from the cell face to the center of the ghost cell, where
the extrapolated value is then used in the regular stencil.  For example,
\sphinxcode{\sphinxupquote{\DUrole{name}{maxorder} \DUrole{operator}{=} \DUrole{literal,number,integer}{2}}} uses the boundary value and the first interior value to extrapolate
to the ghost cell center; \sphinxcode{\sphinxupquote{\DUrole{name}{maxorder} \DUrole{operator}{=} \DUrole{literal,number,integer}{3}}} uses the boundary value and the first two interior values.


\section{Curvilinear Coordinates}
\label{\detokenize{LinearSolvers:curvilinear-coordinates}}
\sphinxAtStartPar
The linear solvers support curvilinear coordinates including 1D
spherical and 2d cylindrical \((r,z)\).  In those cases, the
divergence operator has extra metric terms.  If one does not want the
solver to include the metric terms because they have been handled in
other ways, one can call \sphinxcode{\sphinxupquote{\DUrole{name}{setMetricTerm}\DUrole{punctuation}{(}\DUrole{keyword,type}{bool}\DUrole{punctuation}{)}}} with \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{false}}}
on the \sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}}} object passed to the constructor of linear
operators.


\section{Embedded Boundaries}
\label{\detokenize{LinearSolvers:embedded-boundaries}}
\sphinxAtStartPar
AMReX supports multi\sphinxhyphen{}level solvers for use with embedded boundaries.
These include
1) cell\sphinxhyphen{}centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions on the EB faces.

\sphinxAtStartPar
To use a cell\sphinxhyphen{}centered solver with EB, one builds a linear operator
\sphinxcode{\sphinxupquote{\DUrole{name}{MLEBABecLap}}} with \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}} (instead of a \sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLEBABecLap} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}geom}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BoxArray}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grids}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DistributionMapping}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dmap}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{LPInfo}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}info}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}factory}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The usage of this EB\sphinxhyphen{}specific class is essentially the same as
\sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}}.

\sphinxAtStartPar
The default boundary condition on EB faces is homogeneous Neumann.

\sphinxAtStartPar
To set homogeneous Dirichlet boundary conditions, call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setEBHomogDirichlet}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{coeff}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.

\sphinxAtStartPar
To set inhomogeneous Dirichlet boundary conditions, call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setEBDirichlet}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{phi\PYGZus{}on\PYGZus{}eb}\PYG{p}{,} \PYG{n}{coeff}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where phi\_on\_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.

\sphinxAtStartPar
Currently there are options to define the face\sphinxhyphen{}based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.

\sphinxAtStartPar
The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setPhiOnCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The default is for the face\sphinxhyphen{}based coefficients to be defined at face centers;
to tell the that the face\sphinxhyphen{}based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setBCoeffs}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{MLMG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Location}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceCentroid}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{External Solvers}
\label{\detokenize{LinearSolvers:external-solvers}}
\sphinxAtStartPar
AMReX provides interfaces to the \sphinxhref{https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{hypre} preconditioners and solvers, including BoomerAMG, GMRES (all variants), PCG, and BICGStab as
solvers, and BoomerAMG and Euclid as preconditioners.  These can be called as
as bottom solvers for both cell\sphinxhyphen{}centered and node\sphinxhyphen{}based problems.

\sphinxAtStartPar
If it is built with Hypre support, AMReX initializes Hypre by default in
\sphinxtitleref{amrex::Initialize}.  If it is built with CUDA, AMReX will also set up Hypre
to run on device by default.  The user can choose to disable the Hypre
initialization by AMReX with \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} parameter
\sphinxcode{\sphinxupquote{amrex.init\_hypre={[}0|1{]}}}.

\sphinxAtStartPar
By default the AMReX linear solver code always tries to geometrically coarsen the
problem as much as possible.  However, as we have mentioned, we can
call \sphinxcode{\sphinxupquote{\DUrole{name}{setMaxCoarseningLevel}\DUrole{punctuation}{(}\DUrole{literal,number,integer}{0}\DUrole{punctuation}{)}}} on the \sphinxcode{\sphinxupquote{\DUrole{name}{LPInfo}}} object
passed to the constructor of a linear operator to disable the
coarsening completely.  In that case the bottom solver is solving the
residual correction form of the original problem. To build Hypre, follow the next steps:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}} \PYG{n}{git} \PYG{n}{clone} \PYG{n+nl}{https}\PYG{p}{:}\PYG{c+c1}{//github.com/hypre\PYGZhy{}space/hypre.git}
\PYG{l+m+mf}{2.}\PYG{o}{\PYGZhy{}} \PYG{n}{cd} \PYG{n}{hypre}\PYG{o}{/}\PYG{n}{src}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}} \PYG{p}{.}\PYG{o}{/}\PYG{n}{configure}
    \PYG{p}{(}\PYG{k}{if} \PYG{n}{you} \PYG{n}{want} \PYG{n}{to} \PYG{n}{build} \PYG{n}{hypre} \PYG{n}{with} \PYG{k+kt}{long} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{p}{,} \PYG{k}{do} \PYG{p}{.}\PYG{o}{/}\PYG{n}{configure} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{bigint} \PYG{p}{)}
\PYG{l+m+mf}{4.}\PYG{o}{\PYGZhy{}} \PYG{n}{make} \PYG{n}{install}
\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}} \PYG{n}{Create} \PYG{n}{an} \PYG{n}{environment} \PYG{n}{variable} \PYG{n}{with} \PYG{n}{the} \PYG{n}{HYPRE} \PYG{n}{directory} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{HYPRE\PYGZus{}DIR}\PYG{o}{=}\PYG{o}{/}\PYG{n}{hypre\PYGZus{}path}\PYG{o}{/}\PYG{n}{hypre}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{hypre}
\end{sphinxVerbatim}

\sphinxAtStartPar
To use hypre, one must include \sphinxcode{\sphinxupquote{amrex/Src/Extern/HYPRE}} in the build system.
For examples of using hypre, we refer the reader to
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{ABecLaplacian} or \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{Nodal Projection EB}.

\sphinxAtStartPar
The following parameter should be set to True if the problem to be solved has a singular matrix.
In this case, the solution is only defined to within a constant.  Setting this parameter to True
replaces one row in the matrix sent to hypre from AMReX by a row that sets the value at one cell to 0.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{adjust\_singular\_matrix}}}:   Default is False.

\end{itemize}

\sphinxAtStartPar
The following parameters can be set in the inputs file to control the choice of preconditioner and smoother:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{hypre\_solver}}}:   Default is BoomerAMG.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{hypre\_preconditioner}}}: Default is none;  otherwise the type must be specified.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{recompute\_preconditioner}}}: Default true.  Option to recompute the preconditioner.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{write\_matrix\_files}}}: Default false.   Option to write out matrix into text files.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{overwrite\_existing\_matrix\_files}}}: Default false.   Option to over\sphinxhyphen{}write existing matrix files.

\end{itemize}

\sphinxAtStartPar
The following parameters can be set in the inputs file to control the BoomerAMG solver specifically:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_verbose}}}: verbosity of BoomerAMG preconditioner. Default 0. See \sphinxtitleref{HYPRE\_BoomerAMGSetPrintLevel}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_logging}}}: Default 0. See \sphinxtitleref{HYPRE\_BoomerAMGSetLogging}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_coarsen\_type}}}: Default 6.  See \sphinxtitleref{HYPRE\_BoomerAMGSetCoarsenType}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_cycle\_type}}}: Default 1.  See \sphinxtitleref{HYPRE\_BoomerAMGSetCycleType}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_relax\_type}}}: Default 6.  See \sphinxtitleref{HYPRE\_BoomerAMGSetRelaxType}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_relax\_order}}}: Default 1.  See \sphinxtitleref{HYPRE\_BoomerAMGSetRelaxOrder}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_num\_sweeps}}}: Default 2.  See \sphinxtitleref{HYPRE\_BoomerAMGSetNumSweeps}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_max\_levels}}}: Default 20.  See \sphinxtitleref{HYPRE\_BoomerAMGSetMaxLevels}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_strong\_threshold}}}: Default 0.25 for 2D, 0.57 for 3D.  See \sphinxtitleref{HYPRE\_BoomerAMGSetStrongThreshold}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{hypre}\DUrole{punctuation}{.}\DUrole{name}{bamg\_interp\_type}}}:  Default 0.  See \sphinxtitleref{HYPRE\_BoomerAMGSetInterpType}

\end{itemize}

\sphinxAtStartPar
The user is referred to the
\sphinxhref{https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{hypre} Hypre Reference Manual for full details on the usage of the parameters described briefly above.

\sphinxAtStartPar
AMReX can also use \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} as a bottom solver for cell\sphinxhyphen{}centered
problems. To build PETSc, follow the next steps:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}} \PYG{n}{git} \PYG{n}{clone} \PYG{n+nl}{https}\PYG{p}{:}\PYG{c+c1}{//github.com/petsc/petsc.git}
\PYG{l+m+mf}{2.}\PYG{o}{\PYGZhy{}} \PYG{n}{cd} \PYG{n}{petsc}
\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}} \PYG{p}{.}\PYG{o}{/}\PYG{n}{configure} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{download}\PYG{o}{\PYGZhy{}}\PYG{n}{hypre}\PYG{o}{=}\PYG{n}{yes} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{prefix}\PYG{o}{=}\PYG{n}{build\PYGZus{}dir}
\PYG{l+m+mf}{4.}\PYG{o}{\PYGZhy{}} \PYG{n}{Follow} \PYG{n}{the} \PYG{n}{steps} \PYG{n}{given} \PYG{n}{by} \PYG{n}{petsc}
\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}} \PYG{n}{Create} \PYG{n}{an} \PYG{n}{environment} \PYG{n}{variable} \PYG{n}{with} \PYG{n}{the} \PYG{n}{PETSC} \PYG{n}{directory} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
    \PYG{n}{PETSC\PYGZus{}DIR}\PYG{o}{=}\PYG{o}{/}\PYG{n}{petsc\PYGZus{}path}\PYG{o}{/}\PYG{n}{petsc}\PYG{o}{/}\PYG{n}{build\PYGZus{}dir}
\end{sphinxVerbatim}

\sphinxAtStartPar
To use PETSc, one must include \sphinxcode{\sphinxupquote{amrex/Src/Extern/PETSc}}
in the build system.  For an example of using PETSc, we refer the
reader to the tutorial, \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{ABecLaplacian}.


\section{MAC Projection}
\label{\detokenize{LinearSolvers:mac-projection}}
\sphinxAtStartPar
Some codes define a velocity field \(U = (u,v,w)\) on faces, i.e.
\(u\) is defined on x\sphinxhyphen{}faces, \(v\) is defined on y\sphinxhyphen{}faces,
and \(w\) is defined on z\sphinxhyphen{}faces.   We refer to the exact projection
of this velocity field as a MAC projection, in which we solve
\begin{equation*}
\begin{split}D( \beta \nabla \phi) = D(U^*) - S\end{split}
\end{equation*}
\sphinxAtStartPar
for \(\phi\) and then set
\begin{equation*}
\begin{split}U = U^* - \beta \nabla \phi\end{split}
\end{equation*}
\sphinxAtStartPar
where \(U^*\) is a vector field (typically velocity) that we want to satisfy
\(D(U) = S\).  For incompressible flow,  \(S = 0\).

\sphinxAtStartPar
The MacProjection class can be defined and used to perform the MAC projection without explicitly
calling the solver directly.  In addition to solving the variable coefficient Poisson equation,
the MacProjector internally computes the divergence of the vector field, \(D(U^*)\),
to compute the right\sphinxhyphen{}hand\sphinxhyphen{}side, and after the solve, subtracts the weighted gradient term to
make the vector field result satisfy the divergence constraint.

\sphinxAtStartPar
In the simplest form of the call, \(S\) is assumed to be zero and does not need to be specified.
Typically, the user does not allocate the solution array, but it is also possible to create and pass
in the solution array and have \(\phi\) returned as well as \(U\).

\sphinxAtStartPar
Caveat:  Currently the MAC projection only works when the base level covers the full domain; it does
not yet have the interface to pass boundary conditions for a fine level that come from coarser data.

\sphinxAtStartPar
Also note that any Dirichlet or Neumann boundary conditions at domain boundaries
are assumed to be homogeneous.  The call to the \sphinxcode{\sphinxupquote{\DUrole{name}{MLLinOp}}} member function
\sphinxcode{\sphinxupquote{\DUrole{name}{setLevelBC}}} occurs inside the MacProjection class; one does not need to call that
explicitly when using the MacProjection class.

\sphinxAtStartPar
The code below is taken from the file
\sphinxcode{\sphinxupquote{Tutorials/LinearSolvers/MAC\_Projection\_EB/main.cpp}} in \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{MAC Projection EB} and demonstrates how to set up
the MACProjector object and use it to perform a MAC projection.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{EBFArrayBoxFactory} \PYG{n+nf}{factory}\PYG{p}{(}\PYG{n}{eb\PYGZus{}level}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{n}{ng\PYGZus{}ebs}\PYG{p}{,} \PYG{n}{ebs}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// allocate face\PYGZhy{}centered velocities and face\PYGZhy{}centered beta coefficient}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{idim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{idim} \PYG{o}{\PYGZlt{}} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{idim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{vel}\PYG{p}{[}\PYG{n}{idim}\PYG{p}{]}\PYG{p}{.}\PYG{n}{define} \PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TheDimensionVector}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}
                      \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{beta}\PYG{p}{[}\PYG{n}{idim}\PYG{p}{]}\PYG{p}{.}\PYG{n}{define}\PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TheDimensionVector}\PYG{p}{(}\PYG{n}{idim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}
                      \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{beta}\PYG{p}{[}\PYG{n}{idim}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// set beta to 1}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// If we want to use phi elsewhere, we must create an array in which to return the solution}
\PYG{c+c1}{// MultiFab phi\PYGZus{}inout(grids, dmap, 1, 1, MFInfo(), factory);}

\PYG{c+c1}{// If we want to supply a non\PYGZhy{}zero S we must allocate and fill it outside the solver}
\PYG{c+c1}{// MultiFab S(grids, dmap, 1, 0, MFInfo(), factory);}
\PYG{c+c1}{// Set S here ...}

\PYG{c+c1}{// set initial velocity to U=(1,0,0)}
\PYG{n}{AMREX\PYGZus{}D\PYGZus{}TERM}\PYG{p}{(}\PYG{n}{vel}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}\PYG{p}{,}
             \PYG{n}{vel}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}\PYG{p}{,}
             \PYG{n}{vel}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{LPInfo} \PYG{n}{lp\PYGZus{}info}\PYG{p}{;}

\PYG{c+c1}{// If we want to use hypre to solve the full problem we do not need to coarsen the GMG stencils}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{use\PYGZus{}hypre\PYGZus{}as\PYGZus{}full\PYGZus{}solver}\PYG{p}{)}
    \PYG{n}{lp\PYGZus{}info}\PYG{p}{.}\PYG{n}{setMaxCoarseningLevel}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{MacProjector} \PYG{n+nf}{macproj}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetArrOfPtrs}\PYG{p}{(}\PYG{n}{vel}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}       \PYG{c+c1}{// face\PYGZhy{}based velocity}
                     \PYG{p}{\PYGZob{}}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetArrOfConstPtrs}\PYG{p}{(}\PYG{n}{beta}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{c+c1}{// beta}
                     \PYG{p}{\PYGZob{}}\PYG{n}{geom}\PYG{p}{\PYGZcb{}}\PYG{p}{,}                           \PYG{c+c1}{// the geometry object}
                     \PYG{n}{lp\PYGZus{}info}\PYG{p}{)}\PYG{p}{;}                         \PYG{c+c1}{// structure for passing info to the operator}

\PYG{c+c1}{// Here we specify the desired divergence S}
\PYG{c+c1}{// MacProjector macproj(\PYGZob{}amrex::GetArrOfPtrs(vel)\PYGZcb{},       // face\PYGZhy{}based velocity}
\PYG{c+c1}{//                      \PYGZob{}amrex::GetArrOfConstPtrs(beta)\PYGZcb{}, // beta}
\PYG{c+c1}{//                      \PYGZob{}geom\PYGZcb{},                           // the geometry object}
\PYG{c+c1}{//                      lp\PYGZus{}info,                          // structure for passing info to the operator}
\PYG{c+c1}{//                      \PYGZob{}\PYGZam{}S\PYGZcb{});                            // defines the specified RHS divergence}

\PYG{c+c1}{// Set bottom\PYGZhy{}solver to use hypre instead of native BiCGStab}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{use\PYGZus{}hypre\PYGZus{}as\PYGZus{}full\PYGZus{}solver} \PYG{o}{|}\PYG{o}{|} \PYG{n}{use\PYGZus{}hypre\PYGZus{}as\PYGZus{}bottom\PYGZus{}solver}\PYG{p}{)}
   \PYG{n}{macproj}\PYG{p}{.}\PYG{n}{setBottomSolver}\PYG{p}{(}\PYG{n}{MLMG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BottomSolver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hypre}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set boundary conditions.}
\PYG{c+c1}{//  Here we use Neumann on the low x\PYGZhy{}face, Dirichlet on the high x\PYGZhy{}face,}
\PYG{c+c1}{//  and periodic in the other two directions}
\PYG{c+c1}{//  (the first argument is for the low end, the second is for the high end)}
\PYG{c+c1}{// Note that Dirichlet and Neumann boundary conditions are assumed to be homogeneous.}
\PYG{n}{macproj}\PYG{p}{.}\PYG{n}{setDomainBC}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Neumann}\PYG{p}{,}
                                  \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{,}
                                  \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                    \PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Dirichlet}\PYG{p}{,}
                                  \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{,}
                                  \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{macproj}\PYG{p}{.}\PYG{n}{setVerbose}\PYG{p}{(}\PYG{n}{mg\PYGZus{}verbose}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{macproj}\PYG{p}{.}\PYG{n}{setBottomVerbose}\PYG{p}{(}\PYG{n}{bottom\PYGZus{}verbose}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Define the relative tolerance}
\PYG{n}{Real} \PYG{n}{reltol} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{n}{e}\PYG{l+m+mi}{\PYGZhy{}8}\PYG{p}{;}

\PYG{c+c1}{// Define the absolute tolerance; note that this argument is optional}
\PYG{n}{Real} \PYG{n}{abstol} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{n}{e}\PYG{l+m+mi}{\PYGZhy{}15}\PYG{p}{;}

\PYG{c+c1}{// Solve for phi and subtract from the velocity to make it divergence\PYGZhy{}free}
\PYG{c+c1}{// Note that when we build with USE\PYGZus{}EB = TRUE, we must specify whether the velocities live}
\PYG{c+c1}{//  at face centers (MLMG::Location::FaceCenter) or face centroids (MLMG::Location::FaceCentroid)}
\PYG{n}{macproj}\PYG{p}{.}\PYG{n}{project}\PYG{p}{(}\PYG{n}{reltol}\PYG{p}{,}\PYG{n}{abstol}\PYG{p}{,}\PYG{n}{MLMG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Location}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceCenter}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// If we want to use phi elsewhere, we can pass in an array in which to return the solution}
\PYG{c+c1}{// macproj.project(\PYGZob{}\PYGZam{}phi\PYGZus{}inout\PYGZcb{},reltol,abstol,MLMG::Location::FaceCenter);}
\end{sphinxVerbatim}

\sphinxAtStartPar
See the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{MAC Projection EB} tutorial for the complete working example.


\section{Nodal Projection}
\label{\detokenize{LinearSolvers:nodal-projection}}
\sphinxAtStartPar
Some codes define a velocity field \(U = (u,v,w)\) with all
components co\sphinxhyphen{}located on cell centers.  The nodal solver in AMReX
can be used to compute an approximate projection of the cell\sphinxhyphen{}centered
velocity field, with pressure and velocity divergence defined on nodes.
When we use the nodal solver this way, and subtract only the cell average
of the gradient from the velocity, it is effectively an approximate projection.

\sphinxAtStartPar
As with the MAC projection, consider that we want to solve
\begin{equation*}
\begin{split}D( \beta \nabla \phi) = D(U^*) - S\end{split}
\end{equation*}
\sphinxAtStartPar
for \(\phi\) and then set
\begin{equation*}
\begin{split}U = U^* - \beta \nabla \phi\end{split}
\end{equation*}
\sphinxAtStartPar
where \(U^*\) is a vector field defined on cell centers and we want to satisfy
\(D(U) = S\).  For incompressible flow,  \(S = 0\).

\sphinxAtStartPar
Currently this nodal approximate projection does not exist in a separate
operator like the MAC projection; instead we demonstrate below the steps needed
to compute the approximate projection.  This means we must compute explicitly the
right\sphinxhyphen{}hand\sphinxhyphen{}side , including the the divergence of the vector field, \(D(U^*)\),
solve the variable coefficient Poisson equation, then subtract the weighted
gradient term to make the vector field result satisfy the divergence constraint.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//}
\PYG{c+c1}{// Given a cell\PYGZhy{}centered velocity (vel) field, a cell\PYGZhy{}centered}
\PYG{c+c1}{// scalar field (sigma) field, and a source term S (either node\PYGZhy{}}
\PYG{c+c1}{// or cell\PYGZhy{}centered )solve:}
\PYG{c+c1}{//}
\PYG{c+c1}{//   div( sigma * grad(phi) ) = div(vel) \PYGZhy{} S}
\PYG{c+c1}{//}
\PYG{c+c1}{// and then perform the projection:}
\PYG{c+c1}{//}
\PYG{c+c1}{//     vel = vel \PYGZhy{} sigma * grad(phi)}
\PYG{c+c1}{//}

\PYG{c+c1}{//}
\PYG{c+c1}{// Create the EB factory}
\PYG{c+c1}{//}
\PYG{n}{EBFArrayBoxFactory} \PYG{n+nf}{factory}\PYG{p}{(}\PYG{n}{eb\PYGZus{}level}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{n}{ng\PYGZus{}ebs}\PYG{p}{,} \PYG{n}{ebs}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{//  Create the cell\PYGZhy{}centered velocity field we want to project}
\PYG{c+c1}{//}
\PYG{n}{MultiFab} \PYG{n+nf}{vel}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set velocity field to (1,0,0) including ghost cells for this example}
\PYG{n}{vel}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vel}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Setup linear operator, AKA the nodal Laplacian}
\PYG{c+c1}{//}
\PYG{n}{LPInfo} \PYG{n}{lp\PYGZus{}info}\PYG{p}{;}

\PYG{c+c1}{// If we want to use hypre to solve the full problem we do not need to coarsen the GMG stencils}
\PYG{c+c1}{// if (use\PYGZus{}hypre\PYGZus{}as\PYGZus{}full\PYGZus{}solver)}
\PYG{c+c1}{//     lp\PYGZus{}info.setMaxCoarseningLevel(0);}

\PYG{n}{MLNodeLaplacian} \PYG{n+nf}{matrix}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{geom}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{grids}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{dmap}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{lp\PYGZus{}info}\PYG{p}{,}
                       \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{factory}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set boundary conditions.}
\PYG{c+c1}{// Here we use Neumann on the low x\PYGZhy{}face, Dirichlet on the high x\PYGZhy{}face,}
\PYG{c+c1}{// and periodic in the other two directions}
\PYG{c+c1}{// (the first argument is for the low end, the second is for the high end)}
\PYG{c+c1}{// Note that Dirichlet boundary conditions are assumed to be homogeneous (i.e. phi = 0)}
\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{setDomainBC}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Neumann}\PYG{p}{,}
                                 \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{,}
                                 \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                   \PYG{p}{\PYGZob{}}\PYG{n}{AMREX\PYGZus{}D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Dirichlet}\PYG{p}{,}
                                 \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{,}
                                 \PYG{n}{LinOpBCType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set matrix attributes to be used by MLMG solver}
\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{setGaussSeidel}\PYG{p}{(}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{setHarmonicAverage}\PYG{p}{(}\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Compute RHS}
\PYG{c+c1}{//}
\PYG{c+c1}{// NOTE: it\PYGZsq{}s up to the user to compute the RHS. as opposed}
\PYG{c+c1}{//       to the MAC projection case !!!}
\PYG{c+c1}{//}
\PYG{c+c1}{// NOTE: do this operation AFTER setting up the linear operator so}
\PYG{c+c1}{//       that compRHS method can be used}
\PYG{c+c1}{//}

\PYG{c+c1}{// RHS is nodal}
\PYG{k}{const} \PYG{n}{BoxArray} \PYG{o}{\PYGZam{}} \PYG{n}{nd\PYGZus{}grids} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convert}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{IntVect}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// nodal grids}

\PYG{c+c1}{// MultiFab to host RHS}
\PYG{n}{MultiFab} \PYG{n+nf}{rhs}\PYG{p}{(}\PYG{n}{nd\PYGZus{}grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Cell\PYGZhy{}centered contributions to RHS}
\PYG{n}{MultiFab} \PYG{n+nf}{S\PYGZus{}cc}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{S\PYGZus{}cc}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Set it to zero for this example}

\PYG{c+c1}{// Node\PYGZhy{}centered contributions to RHS}
\PYG{n}{MultiFab} \PYG{n+nf}{S\PYGZus{}nd}\PYG{p}{(}\PYG{n}{nd\PYGZus{}grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{S\PYGZus{}nd}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Set it to zero for this example}

\PYG{c+c1}{// Compute RHS \PYGZhy{}\PYGZhy{} vel must be cell\PYGZhy{}centered}
\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{compRHS}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{vel}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{S\PYGZus{}nd}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{S\PYGZus{}cc}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Create the cell\PYGZhy{}centered sigma field and set it to 1 for this example}
\PYG{c+c1}{//}
\PYG{n}{MultiFab} \PYG{n+nf}{sigma}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sigma}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set sigma}
\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{setSigma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Create node\PYGZhy{}centered phi}
\PYG{c+c1}{//}
\PYG{n}{MultiFab} \PYG{n+nf}{phi}\PYG{p}{(}\PYG{n}{nd\PYGZus{}grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{phi}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Setup MLMG solver}
\PYG{c+c1}{//}
\PYG{n}{MLMG} \PYG{n+nf}{nodal\PYGZus{}solver}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// We can specify the maximum number of iterations}
\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{setMaxIter}\PYG{p}{(}\PYG{n}{mg\PYGZus{}maxiter}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{setBottomMaxIter}\PYG{p}{(}\PYG{n}{mg\PYGZus{}bottom\PYGZus{}maxiter}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{setVerbose}\PYG{p}{(}\PYG{n}{mg\PYGZus{}verbose}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{setBottomVerbose}\PYG{p}{(}\PYG{n}{mg\PYGZus{}bottom\PYGZus{}verbose}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set bottom\PYGZhy{}solver to use hypre instead of native BiCGStab}
\PYG{c+c1}{//   ( we could also have set this to cg, bicgcg, cgbicg)}
\PYG{c+c1}{// if (use\PYGZus{}hypre\PYGZus{}as\PYGZus{}full\PYGZus{}solver || use\PYGZus{}hypre\PYGZus{}as\PYGZus{}bottom\PYGZus{}solver)}
\PYG{c+c1}{//     nodal\PYGZus{}solver.setBottomSolver(MLMG::BottomSolver::hypre);}

\PYG{c+c1}{// Define the relative tolerance}
\PYG{n}{Real} \PYG{n}{reltol} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{n}{e}\PYG{l+m+mi}{\PYGZhy{}8}\PYG{p}{;}

\PYG{c+c1}{// Define the absolute tolerance; note that this argument is optional}
\PYG{n}{Real} \PYG{n}{abstol} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{n}{e}\PYG{l+m+mi}{\PYGZhy{}15}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Solve div( sigma * grad(phi) ) = RHS}
\PYG{c+c1}{//}
\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{solve}\PYG{p}{(} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{phi}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{reltol}\PYG{p}{,} \PYG{n}{abstol}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Create cell\PYGZhy{}centered MultiFab to hold value of \PYGZhy{}sigma*grad(phi) at cell\PYGZhy{}centers}
\PYG{c+c1}{//}
\PYG{c+c1}{//}
\PYG{n}{MultiFab} \PYG{n+nf}{fluxes}\PYG{p}{(}\PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{factory}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fluxes}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Get fluxes from solver}
\PYG{n}{nodal\PYGZus{}solver}\PYG{p}{.}\PYG{n}{getFluxes}\PYG{p}{(} \PYG{p}{\PYGZob{}}\PYG{o}{\PYGZam{}}\PYG{n}{fluxes}\PYG{p}{\PYGZcb{}} \PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//}
\PYG{c+c1}{// Apply projection explicitly \PYGZhy{}\PYGZhy{}  vel = vel \PYGZhy{} sigma * grad(phi)}
\PYG{c+c1}{//}
\PYG{n}{MultiFab}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Add}\PYG{p}{(} \PYG{o}{*}\PYG{n}{vel}\PYG{p}{,} \PYG{o}{*}\PYG{n}{fluxes}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/LinearSolvers\_Tutorial.html}{Nodal Projection EB} tutorial for the complete working example.


\section{Tensor Solve}
\label{\detokenize{LinearSolvers:tensor-solve}}
\sphinxAtStartPar
Application codes that solve the Navier\sphinxhyphen{}Stokes equations need to evaluate
the viscous term;  solving for this term implicitly requires a multi\sphinxhyphen{}component
solve with cross terms.  Because this is a commonly used motif, we provide
a tensor solve for cell\sphinxhyphen{}centered velocity components.

\sphinxAtStartPar
Consider a velocity field \(U = (u,v,w)\) with all
components co\sphinxhyphen{}located on cell centers.  The viscous term can be written in vector form as
\begin{equation*}
\begin{split}\nabla \cdot (\eta \nabla U) + \nabla \cdot (\eta (\nabla U)^T ) + \nabla \cdot ( (\kappa - \frac{2}{3} \eta) (\nabla \cdot U) )\end{split}
\end{equation*}
\sphinxAtStartPar
and in 3\sphinxhyphen{}d Cartesian component form as
\begin{align*}\!\begin{aligned}
( (\eta u_x)_x + (\eta u_y)_y + (\eta u_z)_z ) + ( (\eta u_x)_x + (\eta v_x)_y + (\eta w_x)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_x\\
( (\eta v_x)_x + (\eta v_y)_y + (\eta v_z)_z ) + ( (\eta u_y)_x + (\eta v_y)_y + (\eta w_y)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_y\\
( (\eta w_x)_x + (\eta w_y)_y + (\eta w_z)_z ) + ( (\eta u_z)_x + (\eta v_z)_y + (\eta w_z)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_z\\
\end{aligned}\end{align*}
\sphinxAtStartPar
Here \(\eta\) is the dynamic viscosity and \(\kappa\) is the bulk viscosity.

\sphinxAtStartPar
We evaluate the following terms from the above using the \sphinxcode{\sphinxupquote{MLABecLaplacian}} and \sphinxcode{\sphinxupquote{MLEBABecLaplacian}} operators;
\begin{align*}\!\begin{aligned}
( (\frac{4}{3} \eta + \kappa) u_x)_x + (              \eta           u_y)_y + (\eta u_z)_z\\
(\eta           v_x)_x + ( (\frac{4}{3} \eta + \kappa) v_y)_y + (\eta v_z)_z\\
(\eta w_x)_x                        + (              \eta           w_y)_y + ( (\frac{4}{3} \eta + \kappa) w_z)_z\\
\end{aligned}\end{align*}
\sphinxAtStartPar
the following cross\sphinxhyphen{}terms are evaluated separately using the \sphinxcode{\sphinxupquote{MLTensorOp}} and \sphinxcode{\sphinxupquote{MLEBTensorOp}} operators.
\begin{align*}\!\begin{aligned}
( (\kappa - \frac{2}{3} \eta) (v_y + w_z) )_x + (\eta v_x)_y  + (\eta w_x)_z\\
(\eta u_y)_x + ( (\kappa - \frac{2}{3} \eta) (u_x + w_z) )_y  + (\eta w_y)_z\\
(\eta u_z)_x + (\eta v_z)_y - ( (\kappa - \frac{2}{3} \eta) (u_x + v_y) )_z\\
\end{aligned}\end{align*}
\sphinxAtStartPar
The code below is an example of how to set up the solver to compute the
viscous term \sphinxtitleref{divtau} explicitly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box} \PYG{n+nf}{domain}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{Domain}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set BCs for Poisson solver in bc\PYGZus{}lo, bc\PYGZus{}hi}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{c+c1}{//}
\PYG{c+c1}{// First define the operator \PYGZdq{}ebtensorop\PYGZdq{}}
\PYG{c+c1}{// Note we call LPInfo().setMaxCoarseningLevel(0) because we are only applying the operator,}
\PYG{c+c1}{//      not doing an implicit solve}
\PYG{c+c1}{//}
\PYG{c+c1}{//       (alpha * a \PYGZhy{} beta * (del dot b grad)) sol}
\PYG{c+c1}{//}
\PYG{c+c1}{// LPInfo                       info;}
\PYG{n}{MLEBTensorOp} \PYG{n}{ebtensorop}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{grids}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{,} \PYG{n}{LPInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{setMaxCoarseningLevel}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{GetVecOfConstPtrs}\PYG{p}{(}\PYG{n}{ebfactory}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// It is essential that we set MaxOrder of the solver to 2}
\PYG{c+c1}{// if we want to use the standard sol(i)\PYGZhy{}sol(i\PYGZhy{}1) approximation}
\PYG{c+c1}{// for the gradient at Dirichlet boundaries.}
\PYG{c+c1}{// The solver\PYGZsq{}s default order is 3 and this uses three points for the}
\PYG{c+c1}{// gradient at a Dirichlet boundary.}
\PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setMaxOrder}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// LinOpBCType Definitions are in amrex/Src/Boundary/AMReX\PYGZus{}LO\PYGZus{}BCTYPES.H}
\PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setDomainBC} \PYG{p}{(} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}lo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}lo}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}lo}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                         \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}hi}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}hi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{LinOpBCType}\PYG{p}{)}\PYG{n}{bc\PYGZus{}hi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}} \PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Return div (eta grad)) phi}
\PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setScalars}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{\PYGZhy{}1.0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MultiFab}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{;}
\PYG{n}{b}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{max\PYGZus{}level} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Compute the coefficients}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lev} \PYG{o}{\PYGZlt{}} \PYG{n}{nlev}\PYG{p}{;} \PYG{n}{lev}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// We average eta onto faces}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{dir} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{dir} \PYG{o}{\PYGZlt{}} \PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{p}{;} \PYG{n}{dir}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{BoxArray} \PYG{n}{edge\PYGZus{}ba} \PYG{o}{=} \PYG{n}{grids}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{edge\PYGZus{}ba}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{n}{dir}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{[}\PYG{n}{dir}\PYG{p}{]} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}unique}\PYG{o}{\PYGZlt{}}\PYG{n}{MultiFab}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{edge\PYGZus{}ba}\PYG{p}{,} \PYG{n}{dmap}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nghost}\PYG{p}{,} \PYG{n}{MFInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{*}\PYG{n}{ebfactory}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{average\PYGZus{}cellcenter\PYGZus{}to\PYGZus{}face}\PYG{p}{(} \PYG{n}{GetArrOfPtrs}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{o}{*}\PYG{n}{etan}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]} \PYG{p}{)}\PYG{p}{;}

    \PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setShearViscosity}  \PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{GetArrOfConstPtrs}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setEBShearViscosity}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{p}{(}\PYG{o}{*}\PYG{n}{eta}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ebtensorop}\PYG{p}{.}\PYG{n}{setLevelBC} \PYG{p}{(} \PYG{n}{lev}\PYG{p}{,} \PYG{n}{GetVecOfConstPtrs}\PYG{p}{(}\PYG{n}{vel}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{MLMG} \PYG{n}{solver}\PYG{p}{(}\PYG{n}{ebtensorop}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{solver}\PYG{p}{.}\PYG{n}{apply}\PYG{p}{(}\PYG{n}{GetVecOfPtrs}\PYG{p}{(}\PYG{n}{divtau}\PYG{p}{)}\PYG{p}{,} \PYG{n}{GetVecOfPtrs}\PYG{p}{(}\PYG{n}{vel}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Multi\sphinxhyphen{}Component Operators}
\label{\detokenize{LinearSolvers:multi-component-operators}}
\sphinxAtStartPar
This section discusses solving linear systems in which the solution variable \(\mathbf{\phi}\) has multiple components.
An example (implemented in the \sphinxcode{\sphinxupquote{MultiComponent}} tutorial) might be:
\begin{equation*}
\begin{split}D(\mathbf{\phi})_i = \sum_{i=1}^N \alpha_{ij} \nabla^2 \phi_j\end{split}
\end{equation*}
\sphinxAtStartPar
(Note: only operators of the form \(D:\mathbb{R}^n\to\mathbb{R}^n\) are currently allowed.)
\begin{itemize}
\item {} 
\sphinxAtStartPar
To implement a multi\sphinxhyphen{}component \sphinxstyleemphasis{cell\sphinxhyphen{}based} operator, inherit from the \sphinxcode{\sphinxupquote{MLCellLinOp}} class.
Override the \sphinxcode{\sphinxupquote{getNComp}} function to return the number of components (\sphinxcode{\sphinxupquote{N}})that the operator will use.
The solution and rhs fabs must also have at least one ghost node.
\sphinxcode{\sphinxupquote{Fapply}}, \sphinxcode{\sphinxupquote{Fsmooth}}, \sphinxcode{\sphinxupquote{Fflux}} must be implemented such that the solution and rhs fabs all have \sphinxcode{\sphinxupquote{N}} components.

\item {} 
\sphinxAtStartPar
Implementing a multi\sphinxhyphen{}component \sphinxstyleemphasis{node\sphinxhyphen{}based} operator is slightly different.
A MC nodal operator must specify that the reflux\sphinxhyphen{}free coarse/fine strategy is being used by the solver.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solver}\PYG{p}{.}\PYG{n}{setCFStrategy}\PYG{p}{(}\PYG{n}{MLMG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CFStrategy}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ghostnodes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The reflux\sphinxhyphen{}free method circumvents the need to implement a special \sphinxcode{\sphinxupquote{reflux}} at the coarse\sphinxhyphen{}fine boundary.
This is accomplished by using ghost nodes.
Each AMR level must have 2 layers of ghost nodes.
The second (outermost) layer of nodes is treated as constant by the relaxation, essentially acting as a Dirichlet boundary.
The first layer of nodes is evolved using the relaxation, in the same manner as the rest of the solution.
When the residual is restricted onto the coarse level (in \sphinxcode{\sphinxupquote{reflux}}) this allows the residual at the coarse\sphinxhyphen{}fine boundary to be interpolated using the first layer of ghost nodes.
\hyperref[\detokenize{LinearSolvers:fig-refluxfreecoarsefine}]{Fig.\@ \ref{\detokenize{LinearSolvers:fig-refluxfreecoarsefine}}} illustrates the how the coarse\sphinxhyphen{}fine update takes place.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=2cm]{{refluxfreecoarsefine}.png}
\caption{: Reflux\sphinxhyphen{}free coarse\sphinxhyphen{}fine boundary update.
Level 2 ghost nodes (small dark blue) are interpolated from coarse boundary.
Level 1 ghost nodes are updated during the relaxation along with all the other interior fine nodes.
Coarse nodes (large blue) on the coarse/fine boundary are updated by restricting with interior nodes
and the first level of ghost nodes.
Coarse nodes underneath level 2 ghost nodes are not updated.
The remaining coarse nodes are updates by restriction.}\label{\detokenize{LinearSolvers:id2}}\label{\detokenize{LinearSolvers:fig-refluxfreecoarsefine}}\end{figure}

\sphinxAtStartPar
The MC nodal operator can inherit from the \sphinxcode{\sphinxupquote{MCNodeLinOp}} class.
\sphinxcode{\sphinxupquote{Fapply}}, \sphinxcode{\sphinxupquote{Fsmooth}}, and \sphinxcode{\sphinxupquote{Fflux}} must update level 1 ghost nodes that are inside the domain.
\sphinxtitleref{interpolation} and \sphinxtitleref{restriction} can be implemented as usual.
\sphinxtitleref{reflux} is a straightforward restriction from fine to coarse, using level 1 ghost nodes for restriction as described above.

\sphinxAtStartPar
See \sphinxcode{\sphinxupquote{Tutorials/LinearSolvers/MultiComponent}} for a complete working example.

\end{itemize}


\chapter{Particles}
\label{\detokenize{Particle_Chapter:particles}}\label{\detokenize{Particle_Chapter:chap-particles}}\label{\detokenize{Particle_Chapter::doc}}
\sphinxAtStartPar
In addition to the tools for working with mesh data described in previous
chapters, AMReX also provides data structures and iterators for performing
data\sphinxhyphen{}parallel particle simulations. Our approach is particularly suited to
particles that interact with data defined on a (possibly adaptive)
block\sphinxhyphen{}structured hierarchy of meshes. Example applications include
Particle\sphinxhyphen{}in\sphinxhyphen{}Cell (PIC) simulations, Lagrangian tracers, or particles that exert
drag forces onto a fluid, such as in multi\sphinxhyphen{}phase flow calculations. The overall
goals of AMReX’s particle tools are to allow users flexibility in specifying
how the particle data is laid out in memory and to handle the parallel
communication of particle data. In the following sections, we
give an overview of AMReX’s particle classes and how to use them.


\section{The Particle}
\label{\detokenize{Particle:the-particle}}\label{\detokenize{Particle:sec-particles-particle}}\label{\detokenize{Particle::doc}}
\sphinxAtStartPar
The particle classes can be used by including the header AMReX\_Particles.H. The
most basic particle data structure is the particle itself:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Particle}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a templated data type, designed to allow flexibility in the number and
type of components that the particles carry. The first template parameter is the
number of extra \sphinxcode{\sphinxupquote{\DUrole{name}{Real}}} variables this particle will have (either single or
double precision \sphinxstepexplicit %
\begin{footnote}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
Particles default to double precision for their real data. To use single precision, compile your code with \sphinxcode{\sphinxupquote{USE\_SINGLE\_PRECISION\_PARTICLES=TRUE}}.
%
\end{footnote}), while the second is the number of extra integer
variables.  It is important to note that this is the number of \sphinxstyleemphasis{extra} real and
integer variables; a particle will always have at least \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_SPACEDIM}}} real
components that store the particle’s position and 2 integer components that
store the particle’s \sphinxcode{\sphinxupquote{\DUrole{name}{id}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{cpu}}} numbers. \sphinxstepexplicit %
\begin{footnote}[2]\phantomsection\label{\thesphinxscope.2}%
\sphinxAtStartFootnote
Note that \sphinxcode{\sphinxupquote{\DUrole{name}{cpu}}} stores the number of the process the particle was \sphinxstyleemphasis{generated} on, not the one it’s currently assigned to. This number is set on initialization and never changes, just like the particle \sphinxcode{\sphinxupquote{\DUrole{name}{id}}}. In essence, the particles have two integer id numbers, and only the combination of the two is unique. This was done to facilitate the creation of particle initial conditions in parallel.
%
\end{footnote}

\sphinxAtStartPar
The particle struct is designed to store these variables in a way that
minimizes padding, which in practice means that the \sphinxcode{\sphinxupquote{\DUrole{name}{Real}}} components
always come first, and the integer components second. Additionally, the
required particle variables are stored before the optional ones, for both the
real and the integer components. For example, say we want to define a particle
type that stores a mass, three velocity components, and two extra integer
flags. Our particle struct would be set up like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Particle}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and the order of the particle components in would be (assuming \sphinxcode{\sphinxupquote{\DUrole{name}{BL\_SPACEDIM}}} is 3):
\sphinxcode{\sphinxupquote{\DUrole{name}{x} \DUrole{name}{y} \DUrole{name}{z} \DUrole{name}{m} \DUrole{name}{vx} \DUrole{name}{vy} \DUrole{name}{vz} \DUrole{name}{id} \DUrole{name}{cpu} \DUrole{name}{flag1} \DUrole{name}{flag2}}}.  \sphinxstepexplicit %
\begin{footnote}[3]\phantomsection\label{\thesphinxscope.3}%
\sphinxAtStartFootnote
Note that for the extra particle components, which component refers to which
variable is an application\sphinxhyphen{}specific convention \sphinxhyphen{} the particles have 4 extra real comps, but which one is “mass” is up
to the user. We suggest using an \sphinxcode{\sphinxupquote{\DUrole{keyword}{enum}}} to keep these indices straight; please
see \sphinxcode{\sphinxupquote{amrex/Tutorials/Particles/ElectrostaticPIC/ElectrosticParticleContainer.H}} for an example of this.
%
\end{footnote}


\subsection{Setting Particle data}
\label{\detokenize{Particle:setting-particle-data}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{Particle}}} struct provides a number of methods for getting and setting
a particle’s data. For the required particle components, there are special,
named methods. For the “extra” real and integer data, you can use the
\sphinxcode{\sphinxupquote{\DUrole{name}{rdata}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{idata}}} methods, respectively.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Particle}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{p}\PYG{p}{;}

\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{3.0}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{id}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}  \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// p.rdata(0) is the first extra real component, not the}
\PYG{c+c1}{// first real component overall}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{5.0}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{5.0}\PYG{p}{;}

\PYG{c+c1}{// and likewise for p.idata(0);}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{idata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{17}\PYG{p}{;}
\PYG{n}{p}\PYG{p}{.}\PYG{n}{idata}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{\PYGZhy{}64}\PYG{p}{;}
\end{sphinxVerbatim}


\section{The ParticleContainer}
\label{\detokenize{Particle:the-particlecontainer}}\label{\detokenize{Particle:sec-particles-particlecontainer}}
\sphinxAtStartPar
One particle by itself is not very useful. To do real calculations, a
collection of particles needs to be defined, and the location of the particles
within the AMR hierarchy (and the corresponding MPI process) needs to be
tracked as the particle positions change. To do this, we provide the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{o}{\PYGZgt{}} \PYG{n}{mypc}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Arrays\sphinxhyphen{}of\sphinxhyphen{}Structs and Structs\sphinxhyphen{}of\sphinxhyphen{}Arrays}
\label{\detokenize{Particle:arrays-of-structs-and-structs-of-arrays}}
\sphinxAtStartPar
Like the \sphinxcode{\sphinxupquote{\DUrole{name}{Particle}}} class itself, the \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}}
class is templated. The first two template parameters have the same meaning as
before: they define the number of each type of variables that the particles in
this container will store. Particles added to the container are stored in the
Array\sphinxhyphen{}of\sphinxhyphen{}Structs (AoS) style. In addition, there are two more optional template
parameters that allow the user to specify additional particle variables that
will be stored in Struct\sphinxhyphen{}of\sphinxhyphen{}Array (SoA) form. The difference between
Array\sphinxhyphen{}of\sphinxhyphen{}Struct and Struct\sphinxhyphen{}of\sphinxhyphen{}Array data is in how the data is laid out in
memory. For the AoS data, all the variables associated with particle 1 are next
to each other in memory, followed by all the variables associated with particle
2, and so on. For variables stored in SoA style, all the particle data for a
given component is next to each other in memory, and each component is stored
in a separate array. For convenience, we (arbitrarily) refer to the components
in the particle struct as particle \sphinxstyleemphasis{data}, and components stored in the
Struct\sphinxhyphen{}of\sphinxhyphen{}Arrays as particle \sphinxstyleemphasis{attributes}. See the figure
{\hyperref[\detokenize{Particle:fig-particles-particle-arrays}]{\sphinxcrossref{\DUrole{std,std-ref}{below}}}} for an illustration.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{particle_arrays}.png}
\caption{An illustration of how the particle data for a single tile is arranged in
memory. This particle container has been defined with \sphinxcode{\sphinxupquote{\DUrole{name}{NStructReal} \DUrole{operator}{=}
\DUrole{literal,number,integer}{1}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{NStructInt} \DUrole{operator}{=} \DUrole{literal,number,integer}{2}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{NArrayReal} \DUrole{operator}{=} \DUrole{literal,number,integer}{2}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{NArrayInt} \DUrole{operator}{=} \DUrole{literal,number,integer}{2}}}.
In this case, each tile in the particle container has five arrays: one with
the particle struct data, two additional real arrays, and two additional
integer arrays.  In the tile shown, there are only 2 particles. We have
labelled the extra real data member of the particle struct to be
\sphinxcode{\sphinxupquote{\DUrole{name}{mass}}}, while the extra integer members of the particle struct are
labeled \sphinxcode{\sphinxupquote{\DUrole{name}{p}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{s}}}, for “phase” and “state”. The variables in
the real and integer arrays are labelled \sphinxcode{\sphinxupquote{\DUrole{name}{foo}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{bar}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{l}}},
and \sphinxcode{\sphinxupquote{\DUrole{name}{n}}}, respectively. We have assumed that the particles are double
precision.}\label{\detokenize{Particle:id7}}\label{\detokenize{Particle:fig-particles-particle-arrays}}\end{figure}

\end{center}

\sphinxAtStartPar
To see why the distinction between AoS and SoA data is important, consider the
following extreme case. Say you have particles that carry 100 different
components, but that most of the time, you only need to do calculations
involving 3 of them (say, the particle positions) at once. In this case,
storing all 100 particle variables in the particle struct is clearly
inefficient, since most of the time you are reading 97 extra variables into
cache that you will never use. By splitting up the particle variables into
stuff that gets used all the time (stored in the AoS) and stuff that only gets
used infrequently (stored in the SoA), you can in principle achieve much better
cache reuse. Of course, the usage pattern of your application likely won’t be
so clear\sphinxhyphen{}cut. Flexibility in how the particle data is stored also makes it
easier to interface between AMReX and already\sphinxhyphen{}existing Fortran subroutines.

\sphinxAtStartPar
Note that while “extra” particle data can be stored in either the SoA or AoS
style, the particle positions and id numbers are \sphinxstylestrong{always} stored in the
particle structs. This is because these particle variables are special and used
internally by AMReX to assign the particles to grids and to mark particles as
valid or invalid, respectively.


\subsection{Constructing ParticleContainers}
\label{\detokenize{Particle:constructing-particlecontainers}}
\sphinxAtStartPar
A particle container is always associated with a particular set of AMR grids
and a particular set of DistributionMaps that describes which MPI processes
those grids live on.  For example, if you only have one level, you can define a
\sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} to store particles on that level using the following
constructor:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ParticleContainer} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Geometry}            \PYG{o}{\PYGZam{}} \PYG{n}{geom}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{DistributionMapping} \PYG{o}{\PYGZam{}} \PYG{n}{dmap}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{BoxArray}            \PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or, if you have multiple levels, you can use following constructor instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ParticleContainer} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}}            \PYG{o}{\PYGZam{}} \PYG{n}{geom}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DistributionMapping}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{dmap}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BoxArray}\PYG{o}{\PYGZgt{}}            \PYG{o}{\PYGZam{}} \PYG{n}{ba}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}                 \PYG{o}{\PYGZam{}} \PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the set of grids used to define the \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} doesn’t have
to be the same set used to define the simulation’s mesh data. However, it is
often desirable to have the two hierarchies track each other. If you are using
an \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}} class in your simulation (see the Chapter on
{\hyperref[\detokenize{AmrCore_Chapter:chap-amrcore}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrCore Source Code}}}}), you can achieve this by using the
\sphinxcode{\sphinxupquote{\DUrole{name}{AmrParticleContainer}}} class. The constructor for this class takes a
pointer to your AmrCore derived class, instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AmrTracerParticleContainer} \PYG{p}{(}\PYG{n}{AmrCore}\PYG{o}{*} \PYG{n}{amr\PYGZus{}core}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, the \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{name}{BoxArray}\DUrole{operator}{\textgreater{}}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{name}{DistributionMap}\DUrole{operator}{\textgreater{}}}}
used by your \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} will be updated automatically to match
those in your \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} stores the particle data in a manner prescribed by
the set of AMR grids used to define it. If tiling is turned off, then every
grid has its own Array\sphinxhyphen{}of\sphinxhyphen{}Structs and Struct\sphinxhyphen{}of\sphinxhyphen{}Arrays. Which AMR grid a
particle is assigned to is determined by examining its position and binning it,
using the domain left edge as an offset.  By default, a particle is assigned to
the finest level that contains its position, although this behavior can be
tweaked if desired.  When tiling is enabled, then each \sphinxstyleemphasis{tile} gets its own
Struct\sphinxhyphen{}of\sphinxhyphen{}Arrays and Array\sphinxhyphen{}of\sphinxhyphen{}Structs instead. Note that this is different than
what happens with mesh data. With mesh data, the tiling is strictly logical;
the data is laid out in memory the same whether tiling is turned on or off.
With particle data, however, the particles are actually stored in different
arrays when tiling is enabled. As with mesh data, the particle tile size can be
tuned so that an entire tile’s worth of particles will fit into a cache line at
once.

\sphinxAtStartPar
Once the particles move, their data may no longer be in the right place in the
container. They can be reassigned by calling the \sphinxcode{\sphinxupquote{\DUrole{name}{Redistribute}\DUrole{punctuation}{()}}} method
of \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}}.  After calling this method, all the particles will
be moved to their proper places in the container, and all invalid particles
(particles with id set to \sphinxcode{\sphinxupquote{\DUrole{literal,number,integer}{\sphinxhyphen{}1}}}) will be removed. All the MPI communication
needed to do this happens automatically.

\sphinxAtStartPar
Application codes will likely want to create their own derived
ParticleContainer class that specializes the template parameters and adds
additional functionality, like setting the initial conditions, moving the
particles, etc. See the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Particles\_Tutorial.html}{particle tutorials} for examples of this.


\section{Initializing Particle Data}
\label{\detokenize{Particle:initializing-particle-data}}\label{\detokenize{Particle:sec-particles-initializing}}
\sphinxAtStartPar
In the following code snippet, we demonstrate how to set particle initial
conditions for both SoA and AoS data. We loop over all the tiles using
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}, and add as many particles as we want to each one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi} \PYG{o}{=} \PYG{n}{MakeMFIter}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{p}{\PYGZob{}}

    \PYG{c+c1}{// ``particles\PYGZsq{}\PYGZsq{} starts off empty}
    \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{GetParticles}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{[}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{.}\PYG{n}{index}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                        \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{LocalTileIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{ParticleType} \PYG{n}{p}\PYG{p}{;}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{id}\PYG{p}{(}\PYG{p}{)}   \PYG{o}{=} \PYG{n}{ParticleType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{NextID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{cpu}\PYG{p}{(}\PYG{p}{)}  \PYG{o}{=} \PYG{n}{ParallelDescriptor}\PYG{o}{:}\PYG{o}{:}\PYG{n}{MyProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{n}{etc}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

    \PYG{c+c1}{// AoS real data}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

    \PYG{c+c1}{// AoS int data}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{idata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{n}{p}\PYG{p}{.}\PYG{n}{idata}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

    \PYG{c+c1}{// Particle real attributes (SoA)}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{real\PYGZus{}attribs}\PYG{p}{;}
    \PYG{n}{real\PYGZus{}attribs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{n}{real\PYGZus{}attribs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

    \PYG{c+c1}{// Particle int attributes (SoA)}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}} \PYG{n}{int\PYGZus{}attribs}\PYG{p}{;}
    \PYG{n}{int\PYGZus{}attribs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{n}{int\PYGZus{}attribs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

    \PYG{n}{particles}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{particles}\PYG{p}{.}\PYG{n}{push\PYGZus{}back\PYGZus{}real}\PYG{p}{(}\PYG{n}{real\PYGZus{}attribs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{particles}\PYG{p}{.}\PYG{n}{push\PYGZus{}back\PYGZus{}int}\PYG{p}{(}\PYG{n}{int\PYGZus{}attribs}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// ... add more particles if desired ...}
  \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Often, it makes sense to have each process only generate particles that it
owns, so that the particles are already in the right place in the container.
In general, however, users may need to call \sphinxcode{\sphinxupquote{\DUrole{name}{Redistribute}\DUrole{punctuation}{()}}} after adding
particles, if the processes generate particles they don’t own (for example, if
the particle positions are perturbed from the cell centers and thus end up
outside their parent grid).


\section{Adding particle components at runtime}
\label{\detokenize{Particle:adding-particle-components-at-runtime}}\label{\detokenize{Particle:sec-particles-runtime}}
\sphinxAtStartPar
In addition to the components specified as template parameters, you can also
add additional \sphinxcode{\sphinxupquote{\DUrole{name}{Real}}} and \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}}} components at runtime. These components
will be stored in Struct\sphinxhyphen{}of\sphinxhyphen{}Array style. To add a runtime component, use the
\sphinxcode{\sphinxupquote{\DUrole{name}{AddRealComp}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{AddIntComp}}} methods of \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}}, like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{communicate\PYGZus{}this\PYGZus{}comp} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}runtime\PYGZus{}real}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{AddRealComp}\PYG{p}{(}\PYG{n}{communicate\PYGZus{}this\PYGZus{}comp}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{num\PYGZus{}runtime\PYGZus{}int}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{AddIntComp}\PYG{p}{(}\PYG{n}{communicate\PYGZus{}this\PYGZus{}comp}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Runtime\sphinxhyphen{}added components can be accessed like regular Struct\sphinxhyphen{}of\sphinxhyphen{}Array data.
The new components will be added at the end of the compile\sphinxhyphen{}time defined ones.

\sphinxAtStartPar
When you are using runtime components, it is crucial that when you are adding
particles to the container, you call the \sphinxcode{\sphinxupquote{\DUrole{name}{DefineAndReturnParticleTile}}} method
for each tile prior to adding any particles. This will make sure the space
for the new components has been allocated. For example, in the above section
on {\hyperref[\detokenize{Particle:sec-particles-initializing}]{\sphinxcrossref{\DUrole{std,std-ref}{initializing particle data}}}}, we accessed
the particle tile data using the \sphinxcode{\sphinxupquote{\DUrole{name}{GetParticles}}} method. If we runtime components
are used, \sphinxcode{\sphinxupquote{\DUrole{name}{DefineAndReturnParticleTile}}} should be used instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi} \PYG{o}{=} \PYG{n}{MakeMFIter}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// instead of this...}
    \PYG{c+c1}{// auto\PYGZam{} particles = GetParticles(lev)[std::make\PYGZus{}pair(mfi.index(),}
    \PYG{c+c1}{//                                     mfi.LocalTileIndex())];}

    \PYG{c+c1}{// we do this...}
    \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particle\PYGZus{}tile} \PYG{o}{=} \PYG{n}{DefineAndReturnParticleTile}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// add particles to particle\PYGZus{}tile as above...}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Iterating over Particles}
\label{\detokenize{Particle:iterating-over-particles}}\label{\detokenize{Particle:sec-particles-iterating}}
\sphinxAtStartPar
To iterate over the particles on a given level in your container, you can use
the \sphinxcode{\sphinxupquote{\DUrole{name}{ParIter}}} class, which comes in both const and non\sphinxhyphen{}const flavors. For
example, to iterate over all the AoS data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{MyParIter} \PYG{o}{=} \PYG{n}{ConstParIter}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{BL\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MyParIter} \PYG{n}{pti}\PYG{p}{(}\PYG{n}{pc}\PYG{p}{,} \PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{pti}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{GetArrayOfStructs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{p} \PYG{p}{:} \PYG{n}{particles}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// do stuff with p...}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The outer loop will execute once every grid (or tile, if tiling is enabled)
\sphinxstyleemphasis{that contains particles}; grids or tiles that don’t have any particles will be
skipped. You can also access the SoA data using the \(ParIter\) as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n}{MyParIter} \PYG{o}{=} \PYG{n}{ParIter}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MyParIter} \PYG{n}{pti}\PYG{p}{(}\PYG{n}{pc}\PYG{p}{,} \PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{pti}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particle\PYGZus{}attributes} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{GetStructOfArrays}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{RealVector}\PYG{o}{\PYGZam{}} \PYG{n}{real\PYGZus{}comp0} \PYG{o}{=} \PYG{n}{particle\PYGZus{}attributes}\PYG{p}{.}\PYG{n}{GetRealData}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{IntVector}\PYG{o}{\PYGZam{}}  \PYG{n}{int\PYGZus{}comp1}  \PYG{o}{=} \PYG{n}{particle\PYGZus{}attributes}\PYG{p}{.}\PYG{n}{GetIntData}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{numParticles}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// do stuff with your SoA data...}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Passing particle data into Fortran routines}
\label{\detokenize{Particle:passing-particle-data-into-fortran-routines}}\label{\detokenize{Particle:sec-particles-fortran}}
\sphinxAtStartPar
Because the AMReX particle struct is a Plain\sphinxhyphen{}Old\sphinxhyphen{}Data type, it is interoperable
with Fortran when the \sphinxcode{\sphinxupquote{\DUrole{keyword}{bind}\DUrole{punctuation}{(}\DUrole{name}{C}\DUrole{punctuation}{)}}} attribute is used. It is therefore
possible to pass a grid or tile worth of particles into fortran routines for
processing, instead of iterating over them in C++. You can also define a
Fortran derived type that is equivalent to C struct used for the particles. For
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only}\PYG{p}{:} \PYG{n}{amrex\PYGZus{}particle\PYGZus{}real}
\PYG{k}{use }\PYG{n+nb}{iso\PYGZus{}c\PYGZus{}binding} \PYG{p}{,}    \PYG{k}{only}\PYG{p}{:} \PYG{k+kt}{c\PYGZus{}int}

\PYG{k}{type}\PYG{p}{,} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}  \PYG{k+kd}{::} \PYG{n}{particle\PYGZus{}t}
   \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}particle\PYGZus{}real}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}particle\PYGZus{}real}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{vel}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}particle\PYGZus{}real}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{acc}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{k+kt}{integer}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}int}\PYG{p}{)}   \PYG{k+kd}{::} \PYG{n}{id}
   \PYG{k+kt}{integer}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}int}\PYG{p}{)}   \PYG{k+kd}{::} \PYG{n}{cpu}
\PYG{k}{end }\PYG{k}{type }\PYG{n}{particle\PYGZus{}t}
\end{sphinxVerbatim}

\sphinxAtStartPar
is equivalent to a particle struct you get with \sphinxcode{\sphinxupquote{\DUrole{name}{Particle}\DUrole{operator}{\textless{}}\DUrole{literal,number,integer}{6}\DUrole{punctuation}{,} \DUrole{literal,number,integer}{0}\DUrole{operator}{\textgreater{}}}}. Here,
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_particle\_real}}} is either single or doubled precision, depending
on whether \sphinxcode{\sphinxupquote{USE\_SINGLE\_PRECISION\_PARTICLES}} is \sphinxcode{\sphinxupquote{TRUE}} or not. We recommend
always using this type in Fortran routines that work on particle data to avoid
hard\sphinxhyphen{}to\sphinxhyphen{}debug incompatibilities between floating point types.


\section{Interacting with Mesh Data}
\label{\detokenize{Particle:interacting-with-mesh-data}}\label{\detokenize{Particle:sec-particles-interacting}}
\sphinxAtStartPar
It is common to want to have the mesh communicate information to the particles
and vice versa. For example, in Particle\sphinxhyphen{}in\sphinxhyphen{}Cell calculations, the particles
deposit their charges onto the mesh, and later, the electric fields computed on
the mesh are interpolated back to the particles. Below, we show examples of
both these sorts of operations.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ex}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{gm}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ey}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{gm}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ez}\PYG{p}{.}\PYG{n}{FillBoundary}\PYG{p}{(}\PYG{n}{gm}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MyParIter} \PYG{n}{pti}\PYG{p}{(}\PYG{n}{MyPC}\PYG{p}{,} \PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{pti}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{GetArrayOfStructs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{nstride} \PYG{o}{=} \PYG{n}{particles}\PYG{p}{.}\PYG{n}{dataShape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}
    \PYG{k}{const} \PYG{k+kt}{long} \PYG{n}{np}  \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{numParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{exfab} \PYG{o}{=} \PYG{n}{Ex}\PYG{p}{[}\PYG{n}{pti}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{eyfab} \PYG{o}{=} \PYG{n}{Ey}\PYG{p}{[}\PYG{n}{pti}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{ezfab} \PYG{o}{=} \PYG{n}{Ex}\PYG{p}{[}\PYG{n}{pti}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{interpolate\PYGZus{}cic}\PYG{p}{(}\PYG{n}{particles}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nstride}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,}
                    \PYG{n}{exfab}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{eyfab}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ezfab}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{box}\PYG{p}{.}\PYG{n}{loVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{box}\PYG{p}{.}\PYG{n}{hiVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{plo}\PYG{p}{,} \PYG{n}{dx}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ng}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{\DUrole{name}{interpolate\_cic}}} is a Fortran subroutine that actually performs
the interpolation on a single box. \sphinxcode{\sphinxupquote{\DUrole{name}{Ex}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{Ey}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{Ez}}} are
MultiFabs that contain the electric field data. These MultiFabs must be defined
with the correct number of ghost cells to perform the desired type of
interpolation, and we call \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} prior to the Fortran call so
that those ghost cells will be up\sphinxhyphen{}to\sphinxhyphen{}date.

\sphinxAtStartPar
In this example, we have assumed that the \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer} \DUrole{name}{MyPC}}} has
been defined on the same grids as the electric field MultiFabs, so that we use
the \sphinxcode{\sphinxupquote{\DUrole{name}{ParIter}}} to index into the MultiFabs to get the data associated with
current tile. If this is not the case, then an additional copy will need to be
performed. However, if the particles are distributed in an extremely uneven
fashion, it is possible that the load balancing improvements associated with
the two\sphinxhyphen{}grid approach are worth the cost of the extra copy.

\sphinxAtStartPar
The inverse operation, in which the particles communicate data \sphinxstyleemphasis{to} the mesh,
is quite similar:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rho}\PYG{p}{.}\PYG{n}{setVal}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{ng}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MyParIter} \PYG{n}{pti}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this}\PYG{p}{,} \PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{pti}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{box} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{validbox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{GetArrayOfStructs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{nstride} \PYG{o}{=} \PYG{n}{particles}\PYG{p}{.}\PYG{n}{dataShape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}
    \PYG{k}{const} \PYG{k+kt}{long} \PYG{n}{np}  \PYG{o}{=} \PYG{n}{pti}\PYG{p}{.}\PYG{n}{numParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{rhofab} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{n}{pti}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{deposit\PYGZus{}cic}\PYG{p}{(}\PYG{n}{particles}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nstride}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{n}{rhofab}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{box}\PYG{p}{.}\PYG{n}{loVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{box}\PYG{p}{.}\PYG{n}{hiVect}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{plo}\PYG{p}{,} \PYG{n}{dx}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{n}{rho}\PYG{p}{.}\PYG{n}{SumBoundary}\PYG{p}{(}\PYG{n}{gm}\PYG{p}{.}\PYG{n}{periodicity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
As before, we loop over all our particles, calling a Fortran routine that
deposits them on to the appropriate \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox} \DUrole{name}{rhofab}}}. The \sphinxcode{\sphinxupquote{\DUrole{name}{rhofab}}}
must have enough ghost cells to cover the support of all the particles
associated with them. Note that we call \sphinxcode{\sphinxupquote{\DUrole{name}{SumBoundary}}} instead of
\sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} after performing the deposition, to add up the charge in
the ghost cells surrounding each Fab into the corresponding valid cells.

\sphinxAtStartPar
For a complete example of an electrostatic PIC calculation that includes static
mesh refinement, please see the \sphinxtitleref{Electrostatic PIC tutorial}.


\section{Short Range Forces}
\label{\detokenize{Particle:short-range-forces}}\label{\detokenize{Particle:sec-particles-shortrange}}
\sphinxAtStartPar
In a PIC calculation, the particles don’t interact with each other directly;
they only see each other through the mesh. An alternative use case is particles
that exert short\sphinxhyphen{}range forces on each other. In this case, beyond some cut\sphinxhyphen{}off
distance, the particles don’t interact with each other and therefore don’t need
to be included in the force calculation. Our approach to these kind of
particles is to fill “neighbor buffers” on each tile that contain copies of the
particles on neighboring tiles that are within some number of cells \(N_g\)
of the tile boundaries. See \hyperref[\detokenize{Particle:fig-particles-neighbor-particles}]{Fig.\@ \ref{\detokenize{Particle:fig-particles-neighbor-particles}}}, below
for an illustration. By choosing the number of ghost cells to match the
interaction radius of the particles, you can capture all of the neighbors that
can possibly influence the particles in the valid region of the tile. The
forces on the particles on different tiles can then be computed independently
of each other using a variety of methods.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{neighbor_particles}.png}
\caption{: An illustration of filling neighbor particles for short\sphinxhyphen{}range force
calculations. Here, we have a domain consisting of one \(32 \times 32\)
grid, broken up into \(8 \times 8\) tiles. The number of ghost cells is
taken to be \(1\).  For the tile in green, particles on other tiles in
the entire shaded region will copied and packed into the green tile’s
neighbor buffer. These particles can then be included in the force
calculation. If the domain is periodic, particles in the grown region for
the blue tile that lie on the other side of the domain will also be copied,
and their positions will modified so that a naive distance calculation
between valid particles and neighbors will be correct.}\label{\detokenize{Particle:id8}}\label{\detokenize{Particle:fig-particles-neighbor-particles}}\end{figure}

\end{center}

\sphinxAtStartPar
For a \sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}} that does this neighbor finding, please see
\sphinxcode{\sphinxupquote{\DUrole{name}{NeighborParticleContainer}}} in
\sphinxcode{\sphinxupquote{amrex/Src/Particles/AMReX\_NeighborParticleContainer.H.}} The
\sphinxcode{\sphinxupquote{\DUrole{name}{NeighborParticleContainer}}} has additional methods called \sphinxcode{\sphinxupquote{\DUrole{name}{fillNeighbors}\DUrole{punctuation}{()}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{clearNeighbors}\DUrole{punctuation}{()}}} that fill the \sphinxcode{\sphinxupquote{\DUrole{name}{neighbors}}} data structure with
copies of the proper particles. A tutorial that uses these features is
available at \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Particles\_Tutorial.html\#neighborlist}{NeighborList}. In this tutorial the function
\sphinxcode{\sphinxupquote{\DUrole{keyword,type}{void} \DUrole{name,label}{MDParticleContainer}\DUrole{punctuation}{:}\DUrole{name}{computeForces}\DUrole{punctuation}{()}}}
computes the forces on a given tile via direct summation over the real
and neighbor particles, as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{MDParticleContainer::computeForces}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{BL\PYGZus{}PROFILE}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MDParticleContainer::computeForces}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{lev} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Geometry}\PYG{o}{\PYGZam{}} \PYG{n}{geom} \PYG{o}{=} \PYG{n}{Geom}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{plev}  \PYG{o}{=} \PYG{n}{GetParticles}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi} \PYG{o}{=} \PYG{n}{MakeMFIter}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{gid} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{index}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{tid} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{LocalTileIndex}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{auto} \PYG{n}{index} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{make\PYGZus{}pair}\PYG{p}{(}\PYG{n}{gid}\PYG{p}{,} \PYG{n}{tid}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{ptile} \PYG{o}{=} \PYG{n}{plev}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{aos}   \PYG{o}{=} \PYG{n}{ptile}\PYG{p}{.}\PYG{n}{GetArrayOfStructs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{np} \PYG{o}{=} \PYG{n}{aos}\PYG{p}{.}\PYG{n}{numParticles}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{auto} \PYG{n}{nbor\PYGZus{}data} \PYG{o}{=} \PYG{n}{m\PYGZus{}neighbor\PYGZus{}list}\PYG{p}{[}\PYG{n}{lev}\PYG{p}{]}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ParticleType}\PYG{o}{*} \PYG{n}{pstruct} \PYG{o}{=} \PYG{n}{aos}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

       \PYG{c+c1}{// now we loop over the neighbor list and compute the forces}
        \PYG{n}{AMREX\PYGZus{}FOR\PYGZus{}1D} \PYG{p}{(} \PYG{n}{np}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{ParticleType}\PYG{o}{\PYGZam{}} \PYG{n}{p1} \PYG{o}{=} \PYG{n}{pstruct}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ax}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
            \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ay}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
            \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{az}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}

            \PYG{k}{for} \PYG{p}{(}\PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n+nl}{p2} \PYG{p}{:} \PYG{n}{nbor\PYGZus{}data}\PYG{p}{.}\PYG{n}{getNeighbors}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{Real} \PYG{n}{dx} \PYG{o}{=} \PYG{n}{p1}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{Real} \PYG{n}{dy} \PYG{o}{=} \PYG{n}{p1}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{Real} \PYG{n}{dz} \PYG{o}{=} \PYG{n}{p1}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

                \PYG{n}{Real} \PYG{n}{r2} \PYG{o}{=} \PYG{n}{dx}\PYG{o}{*}\PYG{n}{dx} \PYG{o}{+} \PYG{n}{dy}\PYG{o}{*}\PYG{n}{dy} \PYG{o}{+} \PYG{n}{dz}\PYG{o}{*}\PYG{n}{dz}\PYG{p}{;}
                \PYG{n}{r2} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{max}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{,} \PYG{n}{Params}\PYG{o}{:}\PYG{o}{:}\PYG{n}{min\PYGZus{}r}\PYG{o}{*}\PYG{n}{Params}\PYG{o}{:}\PYG{o}{:}\PYG{n}{min\PYGZus{}r}\PYG{p}{)}\PYG{p}{;}

                \PYG{k}{if} \PYG{p}{(}\PYG{n}{r2} \PYG{o}{\PYGZgt{}} \PYG{n}{Params}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cutoff}\PYG{o}{*}\PYG{n}{Params}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cutoff}\PYG{p}{)} \PYG{k}{return}\PYG{p}{;}

                \PYG{n}{Real} \PYG{n}{r} \PYG{o}{=} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;}

                \PYG{n}{Real} \PYG{n}{coef} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{n}{Params}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cutoff} \PYG{o}{/} \PYG{n}{r}\PYG{p}{)} \PYG{o}{/} \PYG{n}{r2}\PYG{p}{;}
                \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ax}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coef} \PYG{o}{*} \PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ay}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coef} \PYG{o}{*} \PYG{n}{dy}\PYG{p}{;}
                \PYG{n}{p1}\PYG{p}{.}\PYG{n}{rdata}\PYG{p}{(}\PYG{n}{PIdx}\PYG{o}{:}\PYG{o}{:}\PYG{n}{az}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coef} \PYG{o}{*} \PYG{n}{dz}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Doing a direct \(N^2\) summation over the
particles on a tile is avoided by binning the particles by cell and building a neighbor
list.  The data structure used to represent
the neighbor lists is illustrated in \hyperref[\detokenize{Particle:fig-particles-neighbor-list}]{Fig.\@ \ref{\detokenize{Particle:fig-particles-neighbor-list}}}.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{neighbor_list}.png}
\caption{: An illustration of the neighbor list data structure used by AMReX. The
list for each tile is represented by an array of integers. The first number
in the array is the number of real (i.e., not in the neighbor buffers)
collision partners for the first particle on this tile, while the second is
the number of collision partners from nearby tiles in the neighbor buffer.
Based on the number of collision partners, the next several entries are the
indices of the collision partners in the real and neighbor particle arrays,
respectively. This pattern continues for all the particles on this tile.}\label{\detokenize{Particle:id9}}\label{\detokenize{Particle:fig-particles-neighbor-list}}\end{figure}

\end{center}

\sphinxAtStartPar
This array can then be used to compute the forces on all the particles in one
scan. Users can define their own \sphinxcode{\sphinxupquote{\DUrole{name}{NeighborParticleContainer}}} subclasses
that have their own collision criteria by overloading the virtual
\sphinxcode{\sphinxupquote{\DUrole{name}{check\_pair}}} function.


\section{Particle IO}
\label{\detokenize{Particle:particle-io}}\label{\detokenize{Particle:sec-particles-io}}
\sphinxAtStartPar
AMReX provides routines for writing particle data to disk for analysis,
visualization, and for checkpoint / restart. The most important methods are the
\sphinxcode{\sphinxupquote{\DUrole{name}{WritePlotFile}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{Checkpoint}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{Restart}}} methods of
\sphinxcode{\sphinxupquote{\DUrole{name}{ParticleContainer}}}, which all use a parallel\sphinxhyphen{}aware binary file format for
reading and writing particle data on a grid\sphinxhyphen{}by\sphinxhyphen{}grid basis. These methods are
designed to complement the functions in AMReX\_PlotFileUtil.H for performing
mesh data IO. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{WriteMultiLevelPlotfile}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt00000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{output\PYGZus{}levs}\PYG{p}{,} \PYG{n}{GetVecOfConstPtrs}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}\PYG{p}{,}
                        \PYG{n}{varnames}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{level\PYGZus{}steps}\PYG{p}{,} \PYG{n}{outputRR}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{.}\PYG{n}{Checkpoint}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plt00000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{particle0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will create a plot file called “plt00000” and write the mesh data in \sphinxcode{\sphinxupquote{\DUrole{name}{output}}} to it, and then write the particle data in a subdirectory called “particle0”. There is also the \sphinxcode{\sphinxupquote{\DUrole{name}{WriteAsciiFile}}} method, which writes the particles in a human\sphinxhyphen{}readable text format. This is mainly useful for testing and debugging.

\sphinxAtStartPar
The binary file format is currently readable by \sphinxcode{\sphinxupquote{\DUrole{name}{yt}}}. In additional, there is a Python conversion script in
\sphinxcode{\sphinxupquote{amrex/Tools/Py\_util/amrex\_particles\_to\_vtp}} that can convert both the ASCII and the binary particle files to a
format readable by Paraview. See the chapter on {\hyperref[\detokenize{Visualization_Chapter:chap-visualization}]{\sphinxcrossref{\DUrole{std,std-ref}{Visualization}}}} for more information on visualizing AMReX datasets, including those with particles.


\section{Inputs parameters}
\label{\detokenize{Particle:inputs-parameters}}\phantomsection\label{\detokenize{Particle:sec-particles-parameters}}
\sphinxAtStartPar
There are several runtime parameters users can set in their \sphinxcode{\sphinxupquote{\DUrole{name}{inputs}}} files that control the
behavior of the AMReX particle classes. These are summarized below. They should be preceded by
“particles” in your inputs deck.

\sphinxAtStartPar
The first set of parameters concerns the tiling capability of the ParticleContainer. If you are seeing poor performance
with OpenMP, the first thing to look at is whether there are enough tiles available for each thread to work on.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
do\_tiling
&
\sphinxAtStartPar
Whether to use tiling for particles. Should be on when using OpenMP,
and off when running on GPUs.
&
\sphinxAtStartPar
Bool
&
\sphinxAtStartPar
False
\\
\hline
\sphinxAtStartPar
tile\_size
&
\sphinxAtStartPar
If tiling is on, the maximum tile\_size to in each direction
&
\sphinxAtStartPar
Ints
&
\sphinxAtStartPar
1024000,8,8
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The next set concerns runtime parameters that control the particle IO. Parallel file systems tend not to like it when
too many MPI tasks touch the disk at once. Additionally, performance can degrade if all MPI tasks try writing to the
same file, or if too many small files are created. In general, the “correct” values of these parameters will depend on the
size of your problem (i.e., number of boxes, number of MPI tasks), as well as the system you are using. If you are experiencing
problems with particle IO, you could try varying some / all of these parameters.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
particles\_nfiles
&
\sphinxAtStartPar
How many files to use when writing particle data to plt directories
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
1024
\\
\hline
\sphinxAtStartPar
nreaders
&
\sphinxAtStartPar
How many MPI tasks to use as readers when initializing particles
from binary files.
&
\sphinxAtStartPar
Ints
&
\sphinxAtStartPar
64
\\
\hline
\sphinxAtStartPar
nparts\_per\_read
&
\sphinxAtStartPar
How many particles each task should read from said files before
calling Redistribute
&
\sphinxAtStartPar
Ints
&
\sphinxAtStartPar
100000
\\
\hline
\sphinxAtStartPar
datadigits\_read
&
\sphinxAtStartPar
This for backwards compatibility, don’t use unless you need to read
and old (pre mid 2017) AMReX dataset.
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
5
\\
\hline
\sphinxAtStartPar
use\_prepost
&
\sphinxAtStartPar
This is an optimization for large particle datasets that groups MPI
calls needed during the IO together. Try it seeing poor IO speeds
on large problems.
&
\sphinxAtStartPar
Bool
&
\sphinxAtStartPar
False
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The following runtime parameters affect the behavior of virtual particles in Nyx.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
aggregation\_type
&
\sphinxAtStartPar
How to create virtual particles from finer levels. The options are:

\sphinxAtStartPar
“None” \sphinxhyphen{} don’t do any aggregation.
“Cell” \sphinxhyphen{} when creating virtuals, combine all particles that are
in the same cell.
&
\sphinxAtStartPar
String
&
\sphinxAtStartPar
“None”
\\
\hline
\sphinxAtStartPar
aggregation\_buffer
&
\sphinxAtStartPar
If aggregation on, the number of cells around the coarse/fine
boundary in which no aggregation should be performed.
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Finally, the \sphinxtitleref{amrex.use\_gpu\_aware\_mpi} switch can also affect the behavior of the particle communication routines when
running on GPU platforms like Summit. We recommend leaving it off.


\chapter{Fortran Interface}
\label{\detokenize{Fortran_Chapter:fortran-interface}}\label{\detokenize{Fortran_Chapter:chap-fortran}}\label{\detokenize{Fortran_Chapter::doc}}
\sphinxAtStartPar
The core of AMReX is written in C++. For Fortran users who want to write all of
their programs in Fortran, AMReX provides Fortran interfaces around most of
functionalities except for the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrLevel}}} class (see the chapter on
{\hyperref[\detokenize{AmrLevel_Chapter:chap-amrlevel}]{\sphinxcrossref{\DUrole{std,std-ref}{Amr Source Code}}}}) and particles (see the chapter on {\hyperref[\detokenize{Particle_Chapter:chap-particles}]{\sphinxcrossref{\DUrole{std,std-ref}{Particles}}}}).
We should not confuse the Fortran interface in this chapter with the Fortran
kernel functions called inside \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops in codes (see the section
on {\hyperref[\detokenize{Basics:sec-basics-fortran}]{\sphinxcrossref{\DUrole{std,std-ref}{Fortran and C++ Kernels}}}}). For the latter, Fortran is used in some sense as
a domain\sphinxhyphen{}specific language with native multi\sphinxhyphen{}dimensional arrays, whereas here
Fortran is used to drive the whole application code. In order to better
understand AMReX, Fortran interface users should read the rest of the documentation
except for the Chapters on {\hyperref[\detokenize{AmrLevel_Chapter:chap-amrlevel}]{\sphinxcrossref{\DUrole{std,std-ref}{Amr Source Code}}}} \& {\hyperref[\detokenize{Particle_Chapter:chap-particles}]{\sphinxcrossref{\DUrole{std,std-ref}{Particles}}}}.


\section{Getting Started}
\label{\detokenize{Fortran:getting-started}}\label{\detokenize{Fortran::doc}}
\sphinxAtStartPar
We have discussed AMReX’s build systems in the chapter on
{\hyperref[\detokenize{BuildingAMReX_Chapter:chap-buildingamrex}]{\sphinxcrossref{\DUrole{std,std-ref}{Building AMReX}}}}.  To build with GNU Make, we need to include the
Fortran interface source tree into the make system. The source codes for the
Fortran interface are in \sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces}} and there are several
sub\sphinxhyphen{}directories. The “Base” directory includes sources for the basic
functionality, the “AmrCore” directory wraps around the \sphinxcode{\sphinxupquote{\DUrole{name}{AmrCore}}} class
(see the chapter on {\hyperref[\detokenize{AmrCore_Chapter:chap-amrcore}]{\sphinxcrossref{\DUrole{std,std-ref}{AmrCore Source Code}}}}), and the “Octree” directory adds
support for octree type of AMR grids. Each directory has a “Make.package” file
that can be included in make files (see \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Basic\_Tutorial.html\#helloworld}{HelloWorld\_F} and
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/AMR\_Tutorial.html\#advection-f}{Advection\_F} in the tutorials for examples). The libamrex approach includes the
Fortran interface by default.

\sphinxAtStartPar
A simple example can be found at \sphinxcode{\sphinxupquote{amrex\sphinxhyphen{}tutorials/Basic/HelloWorld\_F/}}. The source code
is shown below in its entirety.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{program }\PYG{n}{main}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}base\PYGZus{}module}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{call }\PYG{n}{amrex\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{amrex\PYGZus{}parallel\PYGZus{}ioprocessor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
\PYG{k}{     }\PYG{k}{print} \PYG{o}{*}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}Hello world!\PYGZdq{}}
  \PYG{k}{end }\PYG{k}{if}
\PYG{k}{  }\PYG{k}{call }\PYG{n}{amrex\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{program }\PYG{n}{main}
\end{sphinxVerbatim}

\sphinxAtStartPar
To access the AMReX Fortran interfaces, we can use these three
modules, \sphinxcode{\sphinxupquote{amrex\_base\_module}} for the basics functionalities
(Section 2 {\hyperref[\detokenize{Fortran:the-basics}]{\sphinxcrossref{The Basics}}}), \sphinxcode{\sphinxupquote{amrex\_amrcore\_module}} for AMR
support (Section 3 {\hyperref[\detokenize{Fortran:amr-core-infrastructure}]{\sphinxcrossref{Amr Core Infrastructure}}}) and \sphinxcode{\sphinxupquote{amrex\_octree\_module}}
for octree style AMR (Section 4 {\hyperref[\detokenize{Fortran:octree}]{\sphinxcrossref{Octree}}}).


\section{The Basics}
\label{\detokenize{Fortran:the-basics}}\label{\detokenize{Fortran:sec-fi-basics}}
\sphinxAtStartPar
Module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_base\_module}}} is a collection of various Fortran modules
providing interfaces to most of the basics of AMReX C++ library (see the
chapter on {\hyperref[\detokenize{Basics_Chapter:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics}}}}). These modules shown in this section can be used
without being explicitly included because they are included by
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_base\_module}}}.

\sphinxAtStartPar
The spatial dimension is an integer parameter \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_spacedim}}}.  We
can also use the \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_SPACEDIM}}} macro in preprocessed Fortran codes
(e.g., .F90 files) just like in the C++ codes. Unlike in C++, the convention
for AMReX Fortran interface is that coordinate direction index starts at 1.

\sphinxAtStartPar
There is an integer parameter \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_real}}}, a Fortran kind parameter
for \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{real}}}. Fortran \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{real}\DUrole{punctuation}{(}\DUrole{name}{amrex\_real}\DUrole{punctuation}{)}}} corresponds to
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Real}}} in C++, which is either double or single precision depending
the setting of precision.

\sphinxAtStartPar
The module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_parallel\_module}}} (
\sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces/Base/AMReX\_parallel\_mod.F90}}) includes wrappers to the
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelDescriptor}}} namespace, which is in turn a wrapper to the parallel
communication library used by AMReX (e.g. MPI).

\sphinxAtStartPar
The module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_parmparse\_module}}} (
\sphinxcode{\sphinxupquote{amrex/Src/Base/AMReX\_parmparse\_mod.F90}}) provides interface to
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} (see the section on {\hyperref[\detokenize{Basics:sec-basics-parmparse}]{\sphinxcrossref{\DUrole{std,std-ref}{ParmParse}}}}). Here are some
examples.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}parmparse}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{pp}
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{n\PYGZus{}cell}\PYG{p}{,} \PYG{n}{max\PYGZus{}grid\PYGZus{}size}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}parmparse\PYGZus{}build}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{pp}\PYG{p}{\PYGZpc{}}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}n\PYGZus{}cell\PYGZdq{}}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{p}{)}
\PYG{n}{max\PYGZus{}grid\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{32} \PYG{c}{! default size}
\PYG{k}{call }\PYG{n}{pp}\PYG{p}{\PYGZpc{}}\PYG{n}{query}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}max\PYGZus{}grid\PYGZus{}size\PYGZdq{}}\PYG{p}{,} \PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}parmpase\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{)} \PYG{c}{! optional if compiler supports finalization}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finalization is a Fortran 2003 feature that some compilers may not support. For
those compilers, we must explicitly destroy the objects, otherwise there will
be memory leaks. This applies to many other derived types.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_box}}} is a derived type in \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_box\_module}}}
\sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces/Base/AMReX\_box\_mod.F90}}. It has three members, \sphinxcode{\sphinxupquote{\DUrole{name}{lo}}}
(lower corner), \sphinxcode{\sphinxupquote{\DUrole{name}{hi}}} (upper corner) and \sphinxcode{\sphinxupquote{\DUrole{name}{nodal}}} (logical flag
for index type).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_geometry}}} is a wrapper for the \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} class
containing information for the physical domain. Below is an example
of building it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{n\PYGZus{}cell}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}box}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{domain}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}geometry}\PYG{p}{)} \PYG{p}{:} \PYG{n}{geom}
\PYG{c}{! n\PYGZus{}cell = ...}
\PYG{c}{! Define a single box covering the domain}
\PYG{n}{domain} \PYG{o}{=} \PYG{n}{amrex\PYGZus{}box}\PYG{p}{(}\PYG{p}{(}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{/}\PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{! This defines a amrex\PYGZus{}geometry object.}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}geometry\PYGZus{}build}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{n}{domain}\PYG{p}{)}
\PYG{c}{!}
\PYG{c}{! ...}
\PYG{c}{!}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}geometry\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_boxarray}}} ( \sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces/Base/AMReX\_boxarray\_mod.F90}}) is a
wrapper for the \sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} class, and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_distromap}}} (
\sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces/Base/AMReX\_distromap\_mod.F90}}) is a wrapper for the
\sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}} class. Here is an example of building a
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxArray}}} and a \sphinxcode{\sphinxupquote{\DUrole{name}{DistributionMapping}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{n\PYGZus{}cell}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}box}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{domain}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}boxarray}\PYG{p}{)} \PYG{p}{:} \PYG{n}{ba}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}distromap}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{dm}
\PYG{c}{! n\PYGZus{}cell = ...}
\PYG{c}{! Define a single box covering the domain}
\PYG{n}{domain} \PYG{o}{=} \PYG{n}{amrex\PYGZus{}box}\PYG{p}{(}\PYG{p}{(}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{/}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{/}\PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}cell}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{! Initialize the boxarray \PYGZdq{}ba\PYGZdq{} from the single box \PYGZdq{}bx\PYGZdq{}}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}boxarray\PYGZus{}build}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{,} \PYG{n}{domain}\PYG{p}{)}
\PYG{c}{! Break up boxarray \PYGZdq{}ba\PYGZdq{} into chunks no larger than \PYGZdq{}max\PYGZus{}grid\PYGZus{}size\PYGZdq{}}
\PYG{k}{call }\PYG{n}{ba}\PYG{p}{\PYGZpc{}}\PYG{n}{maxSize}\PYG{p}{(}\PYG{n}{max\PYGZus{}grid\PYGZus{}size}\PYG{p}{)}
\PYG{c}{! Build a DistributionMapping for the boxarray}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}distromap\PYGZus{}build}\PYG{p}{(}\PYG{n}{dm}\PYG{p}{,} \PYG{n}{ba}\PYG{p}{)}
\PYG{c}{!}
\PYG{c}{! ...}
\PYG{c}{!}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}distromap\PYGZus{}distromap}\PYG{p}{(}\PYG{n}{dm}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}boxarray\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Given \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_boxarray}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_distromap}}}, we can build
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}}, a wrapper for the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} class, as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{nghost}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}boxarray}\PYG{p}{)} \PYG{p}{:} \PYG{n}{ba}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}distromap}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{dm}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{ndmf}
\PYG{c}{! Build amrex\PYGZus{}boxarray and amrex\PYGZus{}distromap}
\PYG{c}{! ncomp = ...}
\PYG{c}{! nghost = ...}
\PYG{c}{! ...}
\PYG{c}{! Build amrex\PYGZus{}multifab with ncomp component and nghost ghost cells}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,} \PYG{n}{nghost}\PYG{p}{)}
\PYG{c}{! Build a nodal multifab}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}build}\PYG{p}{(}\PYG{n}{ndmf}\PYG{p}{,}\PYG{n}{ba}\PYG{p}{,}\PYG{n}{dm}\PYG{p}{,}\PYG{n}{ncomp}\PYG{p}{,}\PYG{n}{nghost}\PYG{p}{,}\PYG{p}{(}\PYG{o}{/}\PYG{p}{.}\PYG{n}{true}\PYG{p}{.}\PYG{p}{,}\PYG{p}{.}\PYG{n}{true}\PYG{p}{.}\PYG{p}{,}\PYG{p}{.}\PYG{n}{true}\PYG{p}{.}\PYG{o}{/}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{!}
\PYG{c}{! ...}
\PYG{c}{!}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{ndmf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are many type\sphinxhyphen{}bound procedures for \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}}. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ncomp}   \PYG{c}{! Return the number of components}
\PYG{n}{nghost}  \PYG{c}{! Return the number of ghost cells}
\PYG{n}{setval}  \PYG{c}{! Set the data to the given value}
\PYG{n}{copy}    \PYG{c}{! Copy data from given amrex\PYGZus{}multifab to this amrex\PYGZus{}multifab}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the copy function here only works on copying data from another
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}} built with the same \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_distromap}}}, like
the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{Copy}}} function in C++.  \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}} also has
two parallel communication procedures, \sphinxcode{\sphinxupquote{\DUrole{name}{fill\_boundary}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{parallel\_copy}}}. Their and interface and usage are very similar to
functions \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{ParallelCopy}}} for \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} in
C++.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}geometry}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{geom}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mfsrc}
\PYG{c}{! ...}
\PYG{k}{call }\PYG{n}{mf}\PYG{p}{\PYGZpc{}}\PYG{n}{fill\PYGZus{}boundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{)}       \PYG{c}{! Fill all components}
\PYG{k}{call }\PYG{n}{mf}\PYG{p}{\PYGZpc{}}\PYG{n}{fill\PYGZus{}boundary}\PYG{p}{(}\PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c}{! Fill 3 components starting with component 1}

\PYG{k}{call }\PYG{n}{mf}\PYG{p}{\PYGZpc{}}\PYG{n}{parallel\PYGZus{}copy}\PYG{p}{(}\PYG{n}{mfsrc}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{)} \PYG{c}{! Parallel copy from another multifab}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be emphasized that the component index for \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}}
starts with 1 following Fortran convention. This is different from the C++ part
of AMReX.

\sphinxAtStartPar
AMReX provides a Fortran interface to \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} for iterating over the
data in \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}}. The Fortran type for this is
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mfiter}}}. Here is an example of using \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mfiter}}} to
loop over \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}} with tiling and launch a kernel function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}box}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{bx}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{contiguous}\PYG{p}{,} \PYG{k}{dimension}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{po}\PYG{p}{,} \PYG{n}{pn}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{old\PYGZus{}phi}\PYG{p}{,} \PYG{n}{new\PYGZus{}phi}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}mfiter}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{mfi}
\PYG{c}{! Define old\PYGZus{}phi and new\PYGZus{}phi ...}
\PYG{c}{! In this example they are built with the same boxarray and distromap.}
\PYG{c}{! And they have the same number of ghost cells and 1 component.}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}mfiter\PYGZus{}build}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{,} \PYG{n}{old\PYGZus{}phi}\PYG{p}{,} \PYG{n}{tiling}\PYG{o}{=}\PYG{p}{.}\PYG{n}{true}\PYG{p}{.}\PYG{p}{)}
\PYG{k}{do }\PYG{k}{while} \PYG{p}{(}\PYG{n}{mfi}\PYG{p}{\PYGZpc{}}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{\PYGZpc{}}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{po} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{old\PYGZus{}phi}\PYG{p}{\PYGZpc{}}\PYG{n}{dataptr}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}
  \PYG{n}{pn} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{new\PYGZus{}phi}\PYG{p}{\PYGZpc{}}\PYG{n}{dataptr}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}
  \PYG{n}{plo} \PYG{o}{=} \PYG{n+nb}{lbound}\PYG{p}{(}\PYG{n}{po}\PYG{p}{)}
  \PYG{n}{phi} \PYG{o}{=} \PYG{n+nb}{ubound}\PYG{p}{(}\PYG{n}{po}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{update\PYGZus{}phi}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{\PYGZpc{}}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{bx}\PYG{p}{\PYGZam{}}\PYG{n}{hi}\PYG{p}{,} \PYG{n}{po}\PYG{p}{,} \PYG{n}{pn}\PYG{p}{,} \PYG{n}{plo}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{do}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}mfiter\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here procedure \sphinxcode{\sphinxupquote{\DUrole{name}{update\_phi}}} is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{update\PYGZus{}phi} \PYG{p}{(}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{,} \PYG{n}{pold}\PYG{p}{,} \PYG{n}{pnew}\PYG{p}{,} \PYG{n}{plo}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}
 \PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}   \PYG{p}{)} \PYG{n}{pold}\PYG{p}{(}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,}\PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)} \PYG{n}{pnew}\PYG{p}{(}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{plo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}\PYG{n}{phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
  \PYG{c}{! ...}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{update\PYGZus{}phi}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that amrex\_multifab’s procedure \sphinxcode{\sphinxupquote{\DUrole{name}{dataptr}}} takes
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mfiter}}} and returns a 4\sphinxhyphen{}dimensional Fortran pointer. For
performance, we should declare the pointer as \sphinxcode{\sphinxupquote{\DUrole{keyword}{contiguous}}}. In C++,
the similar operation returns a reference to \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}.  However,
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} and Fortran pointer have a similar capability of containing
array bound information. We can call \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{lbound}}} and \sphinxcode{\sphinxupquote{\DUrole{name,builtin}{ubound}}} on
the pointer to return its lower and upper bounds. The first three dimensions of
the bounds are spatial and the fourth is for the number of component.

\sphinxAtStartPar
Many of the derived Fortran types in (e.g., \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_boxarray}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_distromap}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_mfiter}}},
and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_geometry}}}) contain a \sphinxcode{\sphinxupquote{\DUrole{keyword}{type}\DUrole{punctuation}{(}\DUrole{keyword,type}{c\_ptr}\DUrole{punctuation}{)}}} that points a
C++ object. They also contain a \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{logical}}} type indicating whether or
not this object owns the underlying object (i.e., responsible for deleting the
object). Due to the semantics of Fortran, one should not return these types
with functions. Instead we should pass them as arguments to procedures
(preferably with \sphinxcode{\sphinxupquote{\DUrole{keyword}{intent}}} specified). These five types all have
assignment(=) operator that performs a shallow copy. After the assignment, the
original objects still owns the data and the copy is just an alias. For
example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mf2}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf2}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{c}{! At this point, both mf1 and mf2 are data owners}
\PYG{n}{mf2} \PYG{o}{=} \PYG{n}{mf1}   \PYG{c}{! This will destroy the original data in mf2.}
            \PYG{c}{! Then mf2 becomes a shallow copy of mf1.}
            \PYG{c}{! mf1 is still the owner of the data.}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{)}
\PYG{c}{! mf2 no longer contains a valid pointer because mf1 has been destroyed.}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mf2}\PYG{p}{)}  \PYG{c}{! But we still need to destroy it.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we need to transfer the ownership, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_boxarray}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_distromap}}} provide type\sphinxhyphen{}bound
\sphinxcode{\sphinxupquote{\DUrole{name}{move}}} procedure. We can use it as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mf2}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}build}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{mf2}\PYG{p}{\PYGZpc{}}\PYG{n}{move}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{)}   \PYG{c}{! mf2 is now the data owner and mf1 is not.}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mf1}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}multifab\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{mf2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_multifab}}} also has a type\sphinxhyphen{}bound \sphinxcode{\sphinxupquote{\DUrole{name}{swap}}} procedure for
exchanging the data.

\sphinxAtStartPar
AMReX also provides \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_plotfile\_module}}} for writing plotfiles. The
interface is similar to the C++ versions.


\section{Amr Core Infrastructure}
\label{\detokenize{Fortran:amr-core-infrastructure}}\label{\detokenize{Fortran:sec-fi-amrcore}}
\sphinxAtStartPar
The module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_amr\_module}}} provides interfaces to AMR core
infrastructure. With AMR, the main program might look like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{program }\PYG{n}{main}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}amr\PYGZus{}module}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{call }\PYG{n}{amrex\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}amrcore\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{my\PYGZus{}amr\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}       \PYG{c}{! user\PYGZsq{}s own code, not part of AMReX}
  \PYG{c}{! ...}
  \PYG{k}{call }\PYG{n}{my\PYGZus{}amr\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}   \PYG{c}{! user\PYGZsq{}s own code, not part of AMReX}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}amrcore\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{program }\PYG{n}{main}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we need to call \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_amrcore\_init}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_amrcore\_finalize}}}. And usually we need to call application code
specific procedures to provide some “hooks” needed by AMReX.  In C++, this is
achieved by using virtual functions. In Fortran, we need to call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}init\PYGZus{}virtual\PYGZus{}functions} \PYG{p}{(}\PYG{n}{mk\PYGZus{}lev\PYGZus{}scrtch}\PYG{p}{,} \PYG{n}{mk\PYGZus{}lev\PYGZus{}crse}\PYG{p}{,} \PYG{p}{\PYGZam{}}
                                         \PYG{n}{mk\PYGZus{}lev\PYGZus{}re}\PYG{p}{,} \PYG{n}{clr\PYGZus{}lev}\PYG{p}{,} \PYG{n}{err\PYGZus{}est}\PYG{p}{)}

  \PYG{c}{! Make a new level from scratch using provided boxarray and distromap}
  \PYG{c}{! Only used during initialization.}
  \PYG{k}{procedure}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}make\PYGZus{}level\PYGZus{}proc}\PYG{p}{)}  \PYG{k+kd}{::} \PYG{n}{mk\PYGZus{}lev\PYGZus{}scrtch}
  \PYG{c}{! Make a new level using provided boxarray and distromap, and fill}
  \PYG{c}{! with interpolated coarse level data.}
  \PYG{k}{procedure}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}make\PYGZus{}level\PYGZus{}proc}\PYG{p}{)}  \PYG{k+kd}{::} \PYG{n}{mk\PYGZus{}lev\PYGZus{}crse}
  \PYG{c}{! Remake an existing level using provided boxarray and distromap,}
  \PYG{c}{! and fill with existing fine and coarse data.}
  \PYG{k}{procedure}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}make\PYGZus{}level\PYGZus{}proc}\PYG{p}{)}  \PYG{k+kd}{::} \PYG{n}{mk\PYGZus{}lev\PYGZus{}re}
  \PYG{c}{! Delete level data}
  \PYG{k}{procedure}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}clear\PYGZus{}level\PYGZus{}proc}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{clr\PYGZus{}lev}
  \PYG{c}{! Tag cells for refinement}
  \PYG{k}{procedure}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}error\PYGZus{}est\PYGZus{}proc}\PYG{p}{)}   \PYG{k+kd}{::} \PYG{n}{err\PYGZus{}est}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}init\PYGZus{}virtual\PYGZus{}functions}
\end{sphinxVerbatim}

\sphinxAtStartPar
We need to provide five functions and these functions have three types of
interfaces:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}make\PYGZus{}level\PYGZus{}proc} \PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n+nb}{time}\PYG{p}{,} \PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{import}
\PYG{k}{  }\PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{lev}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n+nb}{time}
\PYG{n+nb}{  }\PYG{k}{type}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{ba}\PYG{p}{,} \PYG{n}{dm}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}make\PYGZus{}level\PYGZus{}proc}

\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}clear\PYGZus{}level\PYGZus{}proc} \PYG{p}{(}\PYG{n}{lev}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{import}
\PYG{k}{  }\PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{lev}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}clear\PYGZus{}level\PYGZus{}proc}

\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}error\PYGZus{}est\PYGZus{}proc} \PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{tags}\PYG{p}{,} \PYG{n+nb}{time}\PYG{p}{,} \PYG{n}{tagval}\PYG{p}{,} \PYG{n}{clearval}\PYG{p}{)} \PYG{k}{bind}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
  \PYG{k}{import}
\PYG{k}{  }\PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{lev}
  \PYG{k}{type}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{tags}
  \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n+nb}{time}
\PYG{n+nb}{  }\PYG{k+kt}{character}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}char}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value} \PYG{k+kd}{::} \PYG{n}{tagval}\PYG{p}{,} \PYG{n}{clearval}
\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{amrex\PYGZus{}error\PYGZus{}est\PYGZus{}proc}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tutorials/Amr/Advection\_F/Source/my\_amr\_mod.F90}} shows an
example of the setup process. The user provided
\sphinxcode{\sphinxupquote{\DUrole{keyword}{procedure}\DUrole{punctuation}{(}\DUrole{name}{amrex\_error\_est\_proc}\DUrole{punctuation}{)}}} has a tags argument that
is of type \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{c\_ptr}}} and its value is a pointer to a
\sphinxcode{\sphinxupquote{\DUrole{name}{TagBoxArray}}} object. We need to convert this into a Fortran
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_tagboxarray}}} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}tagboxarray}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{tag}
\PYG{n}{tag} \PYG{o}{=} \PYG{n}{tags}
\end{sphinxVerbatim}

\sphinxAtStartPar
The module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_fillpatch\_module}}} provides interface to
C++ functions \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchSinglelevel}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FillPatchTwoLevels}}}. To use
it, the application code needs to provide procedures for interpolation and
filling physical boundaries.  See
\sphinxcode{\sphinxupquote{Tutorials/Amr/Advection\_F/Source/fillpatch\_mod.F90}} for an example.

\sphinxAtStartPar
Module \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_fluxregister\_module}}} provides interface to
\sphinxcode{\sphinxupquote{\DUrole{name}{FluxRegister}}} (see the section on {\hyperref[\detokenize{AmrCore:sec-amrcore-fluxreg}]{\sphinxcrossref{\DUrole{std,std-ref}{Using FluxRegisters}}}}). Its usage
is demonstrated in the tutorial at \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/AMR\_Tutorial.html\#advection-f}{Advection\_F}.


\section{Octree}
\label{\detokenize{Fortran:octree}}\label{\detokenize{Fortran:sec-fi-octree}}
\sphinxAtStartPar
In AMReX, the union of fine level grids is properly contained within the union
of coarse level grids. There are no required direct parent\sphinxhyphen{}child connections
between levels. Therefore, grids in AMReX in general cannot be represented by
trees. Nevertheless, octree type grids are supported via Fortran interface,
because grids are more general than octree grids. A tutorial example using
amrex\_octree\_module ( \sphinxcode{\sphinxupquote{amrex/Src/F\_Interfaces/Octree/AMReX\_octree\_mod.f90}}) is
available at \sphinxcode{\sphinxupquote{amrex\sphinxhyphen{}tutorials/Amr/Advection\_octree\_F/}}. Procedures
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_octree\_init}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_octree\_finalize}}} must be
called as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{program }\PYG{n}{main}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}amrcore\PYGZus{}module}
  \PYG{k}{use }\PYG{n}{amrex\PYGZus{}octree\PYGZus{}module}
  \PYG{k}{implicit }\PYG{k}{none}
\PYG{k}{  }\PYG{k}{call }\PYG{n}{amrex\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}octree\PYGZus{}int}\PYG{p}{(}\PYG{p}{)}  \PYG{c}{! This should be called before amrex\PYGZus{}amrcore\PYGZus{}init.}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}amrcore\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{my\PYGZus{}amr\PYGZus{}init}\PYG{p}{(}\PYG{p}{)}       \PYG{c}{! user\PYGZsq{}s own code, not part of AMReX}
  \PYG{c}{! ...}
  \PYG{k}{call }\PYG{n}{my\PYGZus{}amr\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}   \PYG{c}{! user\PYGZsq{}s own code, not part of AMReX}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}amrcore\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}octree\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
  \PYG{k}{call }\PYG{n}{amrex\PYGZus{}finalize}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{end }\PYG{k}{program }\PYG{n}{main}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, the grid size is \(8^3\), and this can be changed via
\sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} parameter \sphinxcode{\sphinxupquote{amr.max\_grid\_size}}. The module
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_octree\_module}}} provides \sphinxcode{\sphinxupquote{\DUrole{name}{amrex\_octree\_iter}}} that can
be used to iterate over leaves of octree. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}octree\PYGZus{}iter}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{oti}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{multifab}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{phi\PYGZus{}new}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}   \PYG{c}{! one multifab for each level}
\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{ilev}\PYG{p}{,} \PYG{n}{igrd}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}box}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{bx}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{contiguous}\PYG{p}{,} \PYG{k}{pointer}\PYG{p}{,} \PYG{k}{dimension}\PYG{p}{(}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{pout}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}octree\PYGZus{}iter\PYGZus{}build}\PYG{p}{(}\PYG{n}{oti}\PYG{p}{)}
\PYG{k}{do }\PYG{k}{while}\PYG{p}{(}\PYG{n}{oti}\PYG{p}{\PYGZpc{}}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
   \PYG{n}{ilev} \PYG{o}{=} \PYG{n}{oti}\PYG{p}{\PYGZpc{}}\PYG{n}{level}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{igrd} \PYG{o}{=} \PYG{n}{oti}\PYG{p}{\PYGZpc{}}\PYG{n}{grid\PYGZus{}index}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{bx}   \PYG{o}{=} \PYG{n}{oti}\PYG{p}{\PYGZpc{}}\PYG{n}{box}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{pout} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{phi\PYGZus{}new}\PYG{p}{(}\PYG{n}{ilev}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{dataptr}\PYG{p}{(}\PYG{n}{igrd}\PYG{p}{)}
   \PYG{c}{! ...}
\PYG{k}{end }\PYG{k}{do}
\PYG{k}{call }\PYG{n}{amrex\PYGZus{}octree\PYGZus{}iter\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{oti}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Embedded Boundaries}
\label{\detokenize{EB_Chapter:embedded-boundaries}}\label{\detokenize{EB_Chapter:chap-eb}}\label{\detokenize{EB_Chapter::doc}}

\section{Overview of Embedded Boundary Description}
\label{\detokenize{EB:overview-of-embedded-boundary-description}}\label{\detokenize{EB:sec-eb-eboverview}}\label{\detokenize{EB::doc}}
\sphinxAtStartPar
For computations with complex geometries, AMReX provides data structures and
algorithms to employ an embedded boundary (EB) approach to PDE discretizations.
In this approach, the underlying computational mesh is uniform and
block\sphinxhyphen{}structured, but the boundary of the irregular\sphinxhyphen{}shaped computational domain
conceptually cuts through this mesh. Each cell in the mesh becomes labeled as
regular, cut or covered, and the finite\sphinxhyphen{}volume based discretization methods
traditionally used in AMReX applications can be modified to incorporate these
cell shapes. See \hyperref[\detokenize{EB:fig-ebexample}]{Fig.\@ \ref{\detokenize{EB:fig-ebexample}}} for an illustration.

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{EB_example}.png}
\caption{: In the embedded boundary approach to discretizing PDEs, the (uniform)
rectangular mesh is cut by the irregular shape of the computational domain.
The cells in the mesh are label as regular, cut or covered.}\label{\detokenize{EB:id1}}\label{\detokenize{EB:fig-ebexample}}\end{figure}

\end{center}

\sphinxAtStartPar
Because this is a relatively simple grid generation technique, computational
meshes for rather complex geometries can be generated quickly and robustly.
However, the technique can produce arbitrarily small cut cells in the domain.
In practice such small cells can have significant impact on the robustness and
stability of traditional finite volume methods. In this chapter we overview a
class of approaches to deal with this “small cell” problem in a robust and
efficient way, and discuss the tools and data that AMReX provides in order to
implement them.

\sphinxAtStartPar
Note that in a completely general implementation of the EB approach, there
would be no restrictions on the shape or complexity of the EB surface.  With
this generality comes the possibility that the process of “cutting” the cells
results in a single \((i,j,k)\) cell being broken into multiple cell
fragments.  The current release of AMReX does not support multi\sphinxhyphen{}valued cells,
thus there is a practical restriction on the complexity of domains (and
numerical algorithms) supported.

\sphinxAtStartPar
This chapter discusses the EB tools, data structures and algorithms currently
supported by AMReX to enable the construction of discretizations of
conservation law systems. The discussion will focus on general requirements
associated with building fluxes and taking divergences of them to advance such
systems. We also give examples of how to initialize the geometry data
structures and access them to build the numerical difference
operators.  Finally we present EB support of linear solvers.


\section{Initializing the Geometric Database}
\label{\detokenize{EB:initializing-the-geometric-database}}\label{\detokenize{EB:sec-eb-ebinit}}
\sphinxAtStartPar
In AMReX geometric information is stored in a distributed database
class that must be initialized at the start of the calculation. The
procedure for this goes as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Define an implicit function of position which describes the surface of the
embedded object. Specifically, the function class must have a public member
function that takes a position and returns a negative value if that position
is inside the fluid, a positive value in the body, and identically zero at the
embedded boundary.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n+nf}{operator}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Make a \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{GeometryShop}}} object using the implicit function.

\item {} 
\sphinxAtStartPar
Build an \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} with the \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{GeometryShop}}} object and a
\sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} object that contains the information about the domain and the
mesh.

\end{itemize}

\sphinxAtStartPar
Here is a simple example of initialize the database for an embedded sphere.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{center}\PYG{p}{\PYGZob{}}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//Center of the sphere}
\PYG{k+kt}{bool} \PYG{n}{inside} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}  \PYG{c+c1}{// Is the fluid inside the sphere?}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SphereIF} \PYG{n+nf}{sphere}\PYG{p}{(}\PYG{n}{radius}\PYG{p}{,} \PYG{n}{center}\PYG{p}{,} \PYG{n}{inside}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{auto} \PYG{n}{shop} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeShop}\PYG{p}{(}\PYG{n}{sphere}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Geometry} \PYG{n+nf}{geom}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Build}\PYG{p}{(}\PYG{n}{shop}\PYG{p}{,} \PYG{n}{geom}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Implicit Function}
\label{\detokenize{EB:implicit-function}}\label{\detokenize{EB:sec-eb-ebinit-if}}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Src/EB/}}, there are a number of predefined implicit function classes
for basic shapes. One can use these directly or as template for their own
classes.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{AllRegularIF}}}:  No embedded boundaries at all.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BoxIF}}}: Box.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{CylinderIF}}}: Cylinder.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{EllipsoidIF}}}: Ellipsoid.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{PlaneIF}}}: Half\sphinxhyphen{}space plane.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{SphereIF}}}: Sphere.

\end{itemize}

\sphinxAtStartPar
AMReX also provides a number of transformation operations to apply to an object.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{makeComplement}}}: Complement of an object. E.g. a sphere with fluid on
outside becomes a sphere with fluid inside.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{makeIntersection}}}: Intersection of two or more objects.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{makeUnion}}}: Union of two or more objects.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{Translate}}}: Translates an object.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{scale}}}: Scales an object.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{rotate}}}: Rotates an object.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{lathe}}}: Creates a surface of revolution by rotating a 2D object around an axis.

\end{itemize}

\sphinxAtStartPar
Here are some examples of using these functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SphereIF} \PYG{n+nf}{sphere1}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{SphereIF} \PYG{n+nf}{sphere2}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{BoxIF} \PYG{n+nf}{box}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CylinderIF} \PYG{n+nf}{cylinder}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{PlaneIF} \PYG{n+nf}{plane}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// union of two spheres}
\PYG{k}{auto} \PYG{n}{twospheres} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeUnion}\PYG{p}{(}\PYG{n}{sphere1}\PYG{p}{,} \PYG{n}{sphere2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// intersection of a rotated box, a plane and the union of two spheres}
\PYG{k}{auto} \PYG{n}{box\PYGZus{}plane} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeIntersection}\PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{box}\PYG{p}{,}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,}
                                       \PYG{n}{plane}\PYG{p}{,}
                                       \PYG{n}{twospheres}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// scale a cylinder by a factor of 2 in x and y directions, and 3 in z\PYGZhy{}direction.}
\PYG{k}{auto} \PYG{n}{scylinder} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{scale}\PYG{p}{(}\PYG{n}{cylinder}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{3.}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{EB2::GeometryShop}}}
\label{\detokenize{EB:eb2-geometryshop}}
\sphinxAtStartPar
Given an implicit function object, say \sphinxcode{\sphinxupquote{\DUrole{name}{f}}}, we can make a
\sphinxcode{\sphinxupquote{\DUrole{name}{GeometryShop}}} object with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto} \PYG{n}{shop} \PYG{o}{=} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{makeShop}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{EB2::IndexSpace}}}
\label{\detokenize{EB:eb2-indexspace}}
\sphinxAtStartPar
We build \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} with a template function

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n+nc}{G}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{EB2}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Build} \PYG{p}{(}\PYG{k}{const} \PYG{n}{G}\PYG{o}{\PYGZam{}} \PYG{n}{gshop}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Geometry}\PYG{o}{\PYGZam{}} \PYG{n}{geom}\PYG{p}{,}
                 \PYG{k+kt}{int} \PYG{n}{required\PYGZus{}coarsening\PYGZus{}level}\PYG{p}{,}
                 \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}coarsening\PYGZus{}level}\PYG{p}{,}
                 \PYG{k+kt}{int} \PYG{n}{ngrow} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the template parameter is a \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{GeometryShop}}}. \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} (see
section {\hyperref[\detokenize{Basics:sec-basics-geom}]{\sphinxcrossref{\DUrole{std,std-ref}{RealBox and Geometry}}}}) describes the rectangular problem domain and the
mesh on the finest AMR level. Coarse level EB data is generated from coarsening
the original fine data. The \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int} \DUrole{name}{required\_coarsening\_level}}} parameter
specifies the number of coarsening levels required. This is usually set to
\(N-1\), where \(N\) is the total number of AMR levels. The \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}
\DUrole{name}{max\_coarsening\_levels}}} parameter specifies the number of coarsening levels AMReX
should try to have. This is usually set to a big number, say 20 if multigrid
solvers are used. This essentially tells the build to coarsen as much as it can.
If there are no multigrid solvers, the parameter should be set to the same as
\sphinxcode{\sphinxupquote{\DUrole{name}{required\_coarsening\_level}}}. It should be noted that coarsening could
create multi\sphinxhyphen{}valued cells even if the fine level does not have any multi\sphinxhyphen{}valued
cells. This occurs when the embedded boundary cuts a cell in such a way that
there is fluid on multiple sides of the boundary within that cell. Because
multi\sphinxhyphen{}valued cells are not supported, it will cause a runtime error if the
required coarsening level generates multi\sphinxhyphen{}valued cells. The optional \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}
\DUrole{name}{ngrow}}} parameter specifies the number of ghost cells outside the domain on
required levels. For levels coarser than the required level, no EB data are
generated for ghost cells outside the domain.

\sphinxAtStartPar
The newly built \sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} is pushed on to a stack. Static function
\sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}\DUrole{operator}{::}\DUrole{name}{top}\DUrole{punctuation}{()}}} returns a \sphinxcode{\sphinxupquote{\DUrole{keyword}{const} \DUrole{operator}{\&}}} to the new
\sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} object. We usually only need to build one
\sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} object. However, if your application needs multiple
\sphinxcode{\sphinxupquote{\DUrole{name}{EB2}\DUrole{operator}{::}\DUrole{name}{IndexSpace}}} objects, you can save the pointers for later use. For
simplicity, we assume there is only one \sphinxtitleref{EB2::IndexSpace} object for the rest of
this chapter.


\section{EBFArrayBoxFactory}
\label{\detokenize{EB:ebfarrayboxfactory}}
\sphinxAtStartPar
After the EB database is initialized, the next thing we build is
\sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}}. This object provides access to the EB database in the
format of basic AMReX objects such as \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}. We can construct it with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{EBFArrayBoxFactory} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Geometry}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}geom}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ba}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dm}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ngrow}\PYG{p}{,}
                    \PYG{n}{EBSupport} \PYG{n}{a\PYGZus{}support}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unique\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory}\PYG{o}{\PYGZgt{}}
\PYG{n}{makeEBFabFactory} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Geometry}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}geom}\PYG{p}{,}
                  \PYG{k}{const} \PYG{n}{BoxArray}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ba}\PYG{p}{,}
                  \PYG{k}{const} \PYG{n}{DistributionMapping}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dm}\PYG{p}{,}
                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ngrow}\PYG{p}{,}
                  \PYG{n}{EBSupport} \PYG{n}{a\PYGZus{}support}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Argument \sphinxcode{\sphinxupquote{\DUrole{name}{Vector}\DUrole{operator}{\textless{}}\DUrole{keyword,type}{int}\DUrole{operator}{\textgreater{}} \DUrole{keyword}{const}\DUrole{operator}{\&} \DUrole{name}{a\_ngrow}}} specifies the number of
ghost cells we need for EB data at various \sphinxcode{\sphinxupquote{\DUrole{name}{EBSupport}}} levels,
and argument \sphinxcode{\sphinxupquote{\DUrole{name}{EBSupport} \DUrole{name}{a\_support}}} specifies the level of support
needed.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name,label}{EBSupport}\DUrole{punctuation}{:}\DUrole{name}{basic}}}:  basic flags for cell types

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name,label}{EBSupport}\DUrole{punctuation}{:}\DUrole{name}{volume}}}: basic plus volume fraction and centroid

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name,label}{EBSupport}\DUrole{punctuation}{:}\DUrole{name}{full}}}: volume plus area fraction, boundary centroid
and face centroid

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}} is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{FabFactory}\DUrole{operator}{\textless{}}\DUrole{name}{FArrayBox}\DUrole{operator}{\textgreater{}}}}.
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} constructors have an optional argument \sphinxcode{\sphinxupquote{\DUrole{keyword}{const}
\DUrole{name}{FabFactory}\DUrole{operator}{\textless{}}\DUrole{name}{FArrayBox}\DUrole{operator}{\textgreater{}\&}}}.  We can use \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}} to
build \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s that carry EB data.  Member function of
\sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{FabFactory}\PYG{o}{\PYGZlt{}}\PYG{n}{FAB}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{Factory} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
can then be used to return a reference to the \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}} used for
building the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}. Using \sphinxcode{\sphinxupquote{\DUrole{keyword}{dynamic\_cast}}}, we can test whether a
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} is built with an \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto} \PYG{n}{factory} \PYG{o}{=} \PYG{k}{dynamic\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{.}\PYG{n}{Factory}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{factory}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// this is EBFArrayBoxFactory}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// regular FabFactory\PYGZlt{}FArrayBox\PYGZgt{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{EB Data}
\label{\detokenize{EB:eb-data}}
\sphinxAtStartPar
Through member functions of \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}}, we have access to the
following data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// see section on EBCellFlagFab}
\PYG{k}{const} \PYG{n}{FabArray}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFlagFab}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{getMultiEBCellFlagFab} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// volume fraction}
\PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n+nf}{getVolFrac} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// volume centroid}
\PYG{k}{const} \PYG{n}{MultiCutFab}\PYG{o}{\PYGZam{}} \PYG{n+nf}{getCentroid} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// embedded boundary centroid}
\PYG{k}{const} \PYG{n}{MultiCutFab}\PYG{o}{\PYGZam{}} \PYG{n+nf}{getBndryCent} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// area fractions}
\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{MultiCutFab}\PYG{o}{*}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{getAreaFrac} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{c+c1}{// face centroid}
\PYG{n}{Array}\PYG{o}{\PYGZlt{}}\PYG{k}{const} \PYG{n}{MultiCutFab}\PYG{o}{*}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{getFaceCent} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Volume fraction is in a single\sphinxhyphen{}component \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, and it is zero for
covered cells, one for regular cells, and in between for cut cells. Centroid is
in a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}} with \sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} components with each component
of the data is in the range of \([-0.5,0.5]\). The centroid is based on each
cell’s local coordinates with respect to the embedded boundary. A
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}} is very similar to a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}. Its data can be
accessed with subscript operator

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const} \PYG{n}{CutFab}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{p}{[}\PYG{p}{]} \PYG{p}{(}\PYG{k}{const} \PYG{n}{MFIter}\PYG{o}{\PYGZam{}} \PYG{n}{mfi}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{\DUrole{name}{CutFab}}} is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} and can be passed to Fortran
just like \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}. The difference between \sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} is that to save memory \sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}} only has data on boxes
that contain cut cells. It is an error to call \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}} if that box
does not have cut cells. Thus the call must be in a \sphinxcode{\sphinxupquote{\DUrole{keyword}{if}}} test block (see
section {\hyperref[\detokenize{EB:sec-eb-flag}]{\sphinxcrossref{\DUrole{std,std-ref}{EBCellFlagFab}}}}). Boundary centroid is also a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}} with
\sphinxcode{\sphinxupquote{AMREX\_SPACEDIM}} components, and it uses each cell’s local coordinates. Area
fractions and face centroids are returned in \sphinxcode{\sphinxupquote{\DUrole{name}{Array}}} of \sphinxcode{\sphinxupquote{\DUrole{name}{MultiCutFab}}}
pointers. For each direction, area fraction is for the face of that direction.
As for face centroids, there are two components for each direction and the
ordering is always the same as the original ordering of the coordinates. For
example, for \(y\) face, the component 0 is for \(x\) coordinate and 1
for \(z\). The coordinates are in each face’s local frame normalized to the
range of \([-0.5,0.5]\).


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{EBCellFlagFab}}}
\label{\detokenize{EB:ebcellflagfab}}\label{\detokenize{EB:sec-eb-flag}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{EBCellFlagFab}}} contains information on cell types.  We can use
it to determine if a box contains cut cells.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{auto} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{flags} \PYG{o}{=} \PYG{n}{factory}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getMultiEBCellFlagFab}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{MultiCutFab} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{centroid} \PYG{o}{=} \PYG{n}{factory}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{FabType} \PYG{n}{t} \PYG{o}{=} \PYG{n}{flags}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{.}\PYG{n}{getType}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{FabType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{regular} \PYG{o}{=}\PYG{o}{=} \PYG{n}{t}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// This box is regular}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{FabType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{covered} \PYG{o}{=}\PYG{o}{=} \PYG{n}{t}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// This box is covered}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{FabType}\PYG{o}{:}\PYG{o}{:}\PYG{n}{singlevalued} \PYG{o}{=}\PYG{o}{=} \PYG{n}{t}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// This box has cut cells}
        \PYG{c+c1}{// Getting cutfab is safe}
        \PYG{k}{const} \PYG{k}{auto}\PYG{o}{\PYGZam{}} \PYG{n}{centroid\PYGZus{}fab} \PYG{o}{=} \PYG{n}{centroid}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{EBCellFlagFab}}} is derived from \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}. Its data are stored in an
array of 32\sphinxhyphen{}bit integers, and can be used in C++ or passed to Fortran just like
an \sphinxcode{\sphinxupquote{\DUrole{name}{IArrayBox}}} (section {\hyperref[\detokenize{Basics:sec-basics-fab}]{\sphinxcrossref{\DUrole{std,std-ref}{BaseFab, FArrayBox, IArrayBox, and Array4}}}}). AMReX provides a Fortran
module called \sphinxcode{\sphinxupquote{amrex\_ebcellflag\_module}}. This module contains procedures for
testing cell types and getting neighbor information. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}ebcellflag\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{is\PYGZus{}regular\PYGZus{}cell}\PYG{p}{,} \PYG{n}{is\PYGZus{}single\PYGZus{}valued\PYGZus{}cell}\PYG{p}{,} \PYG{n}{is\PYGZus{}covered\PYGZus{}cell}

\PYG{k+kt}{integer}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{flags}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}

\PYG{k+kt}{integer} \PYG{k+kd}{::} \PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}

\PYG{k}{do }\PYG{n}{k} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{k}{do }\PYG{n}{j} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{is\PYGZus{}covered\PYGZus{}cell}\PYG{p}{(}\PYG{n}{flags}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
                \PYG{c}{! this is a completely covered cells}
            \PYG{k}{else }\PYG{k}{if} \PYG{p}{(}\PYG{n}{is\PYGZus{}regular\PYGZus{}cell}\PYG{p}{(}\PYG{n}{flags}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
                \PYG{c}{! this is a regular cell}
            \PYG{k}{else }\PYG{k}{if} \PYG{p}{(}\PYG{n}{is\PYGZus{}single\PYGZus{}valued\PYGZus{}cell}\PYG{p}{(}\PYG{n}{flags}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
                \PYG{c}{! this is a cut cell}
            \PYG{k}{end }\PYG{k}{if}
\PYG{k}{        }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{    }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{end }\PYG{k}{do}
\end{sphinxVerbatim}


\section{Linear Solvers}
\label{\detokenize{EB:linear-solvers}}
\sphinxAtStartPar
Linear solvers for the canonical form (equation \eqref{equation:LinearSolvers_Chapter:eqn::abeclap})
have been discussed in chapter {\hyperref[\detokenize{LinearSolvers_Chapter:chap-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear Solvers}}}}.

\sphinxAtStartPar
AMReX supports multi\sphinxhyphen{}level
1) cell\sphinxhyphen{}centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions on the EB faces.

\sphinxAtStartPar
To use a cell\sphinxhyphen{}centered solver with EB, one builds a linear operator
\sphinxcode{\sphinxupquote{\DUrole{name}{MLEBABecLap}}} with \sphinxcode{\sphinxupquote{\DUrole{name}{EBFArrayBoxFactory}}} (instead of a \sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLEBABecLap} \PYG{p}{(}\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Geometry}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}geom}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{BoxArray}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grids}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{DistributionMapping}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dmap}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{LPInfo}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}info}\PYG{p}{,}
             \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFArrayBoxFactory} \PYG{k}{const}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}factory}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The usage of this EB\sphinxhyphen{}specific class is essentially the same as
\sphinxcode{\sphinxupquote{\DUrole{name}{MLABecLaplacian}}}.

\sphinxAtStartPar
The default boundary condition on EB faces is homogeneous Neumann.

\sphinxAtStartPar
To set homogeneous Dirichlet boundary conditions, call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setEBHomogDirichlet}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{coeff}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.

\sphinxAtStartPar
To set inhomogeneous Dirichlet boundary conditions, call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setEBDirichlet}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{phi\PYGZus{}on\PYGZus{}eb}\PYG{p}{,} \PYG{n}{coeff}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where phi\_on\_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.

\sphinxAtStartPar
Currently there are options to define the face\sphinxhyphen{}based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.

\sphinxAtStartPar
The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setPhiOnCentroid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The default is for the face\sphinxhyphen{}based coefficients to be defined at face centers;
to tell the that the face\sphinxhyphen{}based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ml\PYGZus{}ebabeclap}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{setBCoeffs}\PYG{p}{(}\PYG{n}{lev}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{MLMG}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Location}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FaceCentroid}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Tutorials}
\label{\detokenize{EB:tutorials}}
\sphinxAtStartPar
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/EB\_Tutorial.html}{EB/CNS} is an AMR code for solving compressible
Navier\sphinxhyphen{}Stokes equations with the embedded boundary approach.

\sphinxAtStartPar
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/EB\_Tutorial.html}{EB/Poisson} is a single\sphinxhyphen{}level code that is a proxy for
solving the electrostatic Poisson equation for a grounded sphere with a point
charge inside.

\sphinxAtStartPar
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/EB\_Tutorial.html}{EB/MacProj} is a single\sphinxhyphen{}level code that computes a divergence\sphinxhyphen{}free
flow field around a sphere.  A MAC projection is performed on an initial velocity
field of (1,0,0).


\chapter{GPU}
\label{\detokenize{GPU_Chapter:gpu}}\label{\detokenize{GPU_Chapter:chap-gpu}}\label{\detokenize{GPU_Chapter::doc}}
\sphinxAtStartPar
In this chapter, we will present the GPU support in AMReX.  AMReX targets
NVIDIA, AMD and Intel GPUs using their native vendor language and therefore
requires CUDA, HIP/ROCm and DPC++/SYCL, for NVIDIA, AMD and Intel GPUs, respectively.
Users can also use OpenMP and/or OpenACC in their applications.

\sphinxAtStartPar
AMReX supports NVIDIA GPUs with compute capability \textgreater{}= 6 and CUDA \textgreater{}= 10
as well as CUDA 9.1.  While HIP and DPC++ compilers are in development in
preparation for Frontier and Aurora, AMReX only supports the latest
publicly released versions of those compilers on the Iris and Tulip testbeds.

\sphinxAtStartPar
For complete details of CUDA, HIP, DPC++, OpenMP and OpenACC
languages, see their respective documentations.

\sphinxAtStartPar
Be aware, this documentation is currently focused on CUDA.  HIP and DPC++ documentation
is forthcoming.

\sphinxAtStartPar
A number of tutorials can be found at \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/GPU\_Tutorial.html}{Tutorials/GPU}.


\section{Overview of AMReX GPU Strategy}
\label{\detokenize{GPU:overview-of-amrex-gpu-strategy}}\label{\detokenize{GPU:sec-gpu-overview}}\label{\detokenize{GPU::doc}}
\sphinxAtStartPar
AMReX’s GPU strategy focuses on providing performant GPU support
with minimal changes and maximum flexibility.  This allows
application teams to get running on GPUs quickly while allowing
long term performance tuning and programming model selection.  AMReX
uses the native programming language for GPUs: CUDA for NVIDIA, HIP
for AMD and DPC++ for Intel. This will be designated with \sphinxcode{\sphinxupquote{CUDA/HIP/DPC++}}
throughout the documentation.  However, application teams can also use
OpenACC or OpenMP in their individual codes.

\sphinxAtStartPar
At this time, AMReX does not support cross\sphinxhyphen{}native language compliation
(HIP for non\sphinxhyphen{}AMD systems and DPC++ for non Intel systems).  It may work with
a given version, but AMReX does not track or guarantee such functionality.

\sphinxAtStartPar
When running AMReX on a CPU system, the parallelization strategy is a
combination of MPI and OpenMP using tiling, as detailed in
{\hyperref[\detokenize{Basics:sec-basics-mfiter-tiling}]{\sphinxcrossref{\DUrole{std,std-ref}{MFIter with Tiling}}}}. However, tiling is ineffective on GPUs
due to the overhead associated with kernel launching.  Instead,
efficient use of the GPU’s resources is the primary concern.  Improving
resource efficiency allows a larger percentage of GPU threads to work
simultaneously, increasing effective parallelism and decreasing the time
to solution.

\sphinxAtStartPar
When running on CPUs, AMReX uses an \sphinxcode{\sphinxupquote{MPI+X}} strategy where the \sphinxcode{\sphinxupquote{X}}
threads are used to perform parallelization techniques, like tiling.
The most common \sphinxcode{\sphinxupquote{X}} is \sphinxcode{\sphinxupquote{OpenMP}}.  On GPUs, AMReX requires \sphinxcode{\sphinxupquote{CUDA/HIP/DPC++}}
and can be further combined with other parallel GPU languages, including
\sphinxcode{\sphinxupquote{OpenACC}} and \sphinxcode{\sphinxupquote{OpenMP}}, to control the offloading of subroutines
to the GPU.  This \sphinxcode{\sphinxupquote{MPI+CUDA+X}} GPU strategy has been developed
to give users the maximum flexibility to find the best combination of
portability, readability and performance for their applications.

\sphinxAtStartPar
Presented here is an overview of important features of AMReX’s GPU strategy.
Additional information that is required for creating GPU applications is
detailed throughout the rest of this chapter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Each MPI rank offloads its work to a single GPU. \sphinxcode{\sphinxupquote{(MPI ranks == Number of GPUs)}}

\item {} 
\sphinxAtStartPar
Calculations that can be offloaded efficiently to GPUs use GPU threads
to parallelize over a valid box at a time.  This is done by launching over
a large number GPU threads that only work on a few cells each. This work
distribution is illustrated in \hyperref[\detokenize{GPU:fig-gpu-threads}]{Table \ref{\detokenize{GPU:fig-gpu-threads}}}.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Comparison of OpenMP and GPU work distribution. Pictures provided by Mike Zingale and the CASTRO team.}\label{\detokenize{GPU:id1}}\label{\detokenize{GPU:fig-gpu-threads}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{gpu_2}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{gpu_3}.png}
\\
\hline
\sphinxAtStartPar
OpenMP tiled box.
OpenMP threads break down the valid box
into two large boxes (blue and orange).
The lo and hi of one tiled box are marked.
&
\sphinxAtStartPar
GPU threaded box.
Each GPU thread works on a few cells of the
valid box. This example uses one cell per
thread, each thread using a box with lo = hi.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
C++ macros and GPU extended lambdas are used to provide performance
portability while making the code as understandable as possible to
science\sphinxhyphen{}focused code teams.

\item {} 
\sphinxAtStartPar
AMReX utilizes GPU managed memory to automatically handle memory
movement for mesh and particle data.  Simple data structures, such
as \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}}s can be passed by value and complex data structures, such as
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}es, have specialized AMReX classes to handle the
data movement for the user.  Tests have shown CUDA managed memory
to be efficient and reliable, especially when applications remove
any unnecessary data accesses.

\item {} 
\sphinxAtStartPar
Application teams should strive to keep mesh and particle data structures
on the GPU for as long as possible, minimizing movement back to the CPU.
This strategy lends itself to AMReX applications readily; the mesh and
particle data can stay on the GPU for most subroutines except for
of redistribution, communication and I/O operations.

\item {} 
\sphinxAtStartPar
AMReX’s GPU strategy is focused on launching GPU kernels inside AMReX’s
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{ParIter}}} loops.  By performing GPU work within
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{ParIter}}} loops, GPU work is isolated to independent
data sets on well\sphinxhyphen{}established AMReX data objects, providing consistency and safety
that also matches AMReX’s coding methodology.  Similar tools are also available for
launching work outside of AMReX loops.

\item {} 
\sphinxAtStartPar
AMReX further parallelizes GPU applications by utilizing streams.
Streams guarantee execution order of kernels within the same stream, while
allowing different streams to run simultaneously. AMReX places each iteration
of \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops on separate streams, allowing each independent
iteration to be run simultaneously and sequentially, while maximizing GPU usage.

\sphinxAtStartPar
The AMReX implementation of streams is illustrated in \hyperref[\detokenize{GPU:fig-gpu-streams}]{Fig.\@ \ref{\detokenize{GPU:fig-gpu-streams}}}.
The CPU runs the first iteration of the MFIter loop (blue), which contains three
GPU kernels.  The kernels begin immediately in GPU Stream 1 and run in the same
order they were added. The second (red) and third (green) iterations are similarly
launched in Streams 2 and 3. The fourth (orange) and fifth (purple) iterations
require more GPU resources than remain, so they have to wait until resources are
freed before beginning. Meanwhile, after all the loop iterations are launched, the
CPU reaches a synchronize in the MFIter’s destructor and waits for all GPU launches
to complete before continuing.

\item {} 
\sphinxAtStartPar
The Fortran interface of AMReX does not currently have GPU support.  AMReX recommends
porting Fortran code to C++ when coding for GPUs.

\end{itemize}

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Streams}.png}
\caption{Timeline illustration of GPU streams. Illustrates the case of an
MFIter loop of five iterations with three GPU kernels each being
ran with three GPU streams.}\label{\detokenize{GPU:id2}}\label{\detokenize{GPU:fig-gpu-streams}}\end{figure}

\end{center}


\section{Building GPU Support}
\label{\detokenize{GPU:building-gpu-support}}\label{\detokenize{GPU:sec-gpu-build}}

\subsection{Building with GNU Make}
\label{\detokenize{GPU:building-with-gnu-make}}
\sphinxAtStartPar
To build AMReX with GPU support, add \sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}}, \sphinxcode{\sphinxupquote{USE\_HIP=TRUE}} or
\sphinxcode{\sphinxupquote{USE\_DPCPP=TRUE}} to the \sphinxcode{\sphinxupquote{GNUmakefile}} or as a command line argument.

\sphinxAtStartPar
AMReX does not require OpenACC, but application codes
can use them if they are supported by the compiler.  For OpenACC support, add
\sphinxcode{\sphinxupquote{USE\_ACC=TRUE}}.  PGI, Cray and GNU compilers support OpenACC.  Thus,
for OpenACC, you must use \sphinxcode{\sphinxupquote{COMP=pgi}}, \sphinxcode{\sphinxupquote{COMP=cray}} or \sphinxcode{\sphinxupquote{COMP=gnu}}.

\sphinxAtStartPar
Currently, only IBM is supported with OpenMP offloading. To use OpenMP
offloading, make with \sphinxcode{\sphinxupquote{USE\_OMP\_OFFLOAD=TRUE}}.

\sphinxAtStartPar
Compiling AMReX with CUDA requires compiling the code through NVIDIA’s
CUDA compiler driver in addition to the standard compiler.  This driver
is called \sphinxcode{\sphinxupquote{nvcc}} and it requires a host compiler to work through.
The default host compiler for NVCC is GCC even if \sphinxcode{\sphinxupquote{COMP}} is set to
a different compiler.  One can change this by setting \sphinxcode{\sphinxupquote{NVCC\_HOST\_COMP}}.
For example, \sphinxcode{\sphinxupquote{COMP=pgi}} alone will compile C/C++ codes with NVCC/GCC
and Fortran codes with PGI, and link with PGI.  Using \sphinxcode{\sphinxupquote{COMP=pgi}} and
\sphinxcode{\sphinxupquote{NVCC\_HOST\_COMP=pgi}} will compile C/C++ codes with PGI and NVCC/PGI.

\sphinxAtStartPar
You can use \sphinxcode{\sphinxupquote{Tutorials/Basic/HelloWorld\_C}} to test your programming
environment.  For example, building with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{make COMP=gnu USE\PYGZus{}CUDA=TRUE}
\end{sphinxVerbatim}

\sphinxAtStartPar
should produce an executable named \sphinxcode{\sphinxupquote{main3d.gnu.DEBUG.CUDA.ex}}.  You
can run it and that will generate results like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }./main3d.gnu.DEBUG.CUDA.ex
\PYG{g+go}{Initializing CUDA...}
\PYG{g+go}{CUDA initialized with 1 GPU}
\PYG{g+go}{AMReX (19.06\PYGZhy{}404\PYGZhy{}g0455b168b69c\PYGZhy{}dirty) initialized}
\PYG{g+go}{Hello world from AMReX version 19.06\PYGZhy{}404\PYGZhy{}g0455b168b69c\PYGZhy{}dirty}
\PYG{g+go}{Total GPU global memory (MB): 6069}
\PYG{g+go}{Free  GPU global memory (MB): 5896}
\PYG{g+go}{[The         Arena] space (MB): 4552}
\PYG{g+go}{[The Managed Arena] space (MB): 8}
\PYG{g+go}{[The  Pinned Arena] space (MB): 8}
\PYG{g+go}{AMReX (19.06\PYGZhy{}404\PYGZhy{}g0455b168b69c\PYGZhy{}dirty) finalized}
\end{sphinxVerbatim}


\subsection{Building with CMake}
\label{\detokenize{GPU:building-with-cmake}}

\subsubsection{Enabling CUDA support}
\label{\detokenize{GPU:enabling-cuda-support}}
\sphinxAtStartPar
To build AMReX with CUDA support in CMake, add \sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_GPU\_BACKEND=CUDA}} to the
\sphinxcode{\sphinxupquote{cmake}} invocation. For a full list of CUDA\sphinxhyphen{}specific configuration options,
check the {\hyperref[\detokenize{GPU:tab-cmakecudavar}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} below.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AMReX CUDA\sphinxhyphen{}specific build options}\label{\detokenize{GPU:id3}}\label{\detokenize{GPU:tab-cmakecudavar}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{4}{\X{1}{4}|}}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Possible values
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_ARCH
&
\sphinxAtStartPar
CUDA target architecture
&
\sphinxAtStartPar
Auto
&
\sphinxAtStartPar
User\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_FASTMATH
&
\sphinxAtStartPar
Enable CUDA fastmath library
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_BACKTRACE
&
\sphinxAtStartPar
Host function symbol names (e.g. cuda\sphinxhyphen{}memcheck)
&
\sphinxAtStartPar
Auto
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_COMPILATION\_TIMER
&
\sphinxAtStartPar
CSV table with time for each compilation phase
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_DEBUG
&
\sphinxAtStartPar
Device debug information (optimizations: off)
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_ERROR\_CAPTURE\_THIS
&
\sphinxAtStartPar
Error if a CUDA lambda captures a class’ this
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline\begin{description}
\item[{AMReX\_CUDA\_ERROR\_CROSS}] \leavevmode
\sphinxAtStartPar
\_EXECUTION\_SPACE\_CALL

\end{description}
&\begin{description}
\item[{Error if a host function is called from a host}] \leavevmode
\sphinxAtStartPar
device function

\end{description}
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_KEEP\_FILES
&
\sphinxAtStartPar
Keep intermediately files (folder: nvcc\_tmp)
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_LTO
&
\sphinxAtStartPar
Enable CUDA link\sphinxhyphen{}time\sphinxhyphen{}optimization
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_MAX\_THREADS
&
\sphinxAtStartPar
Max number of CUDA threads per block
&
\sphinxAtStartPar
256
&
\sphinxAtStartPar
User\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_MAXREGCOUNT
&
\sphinxAtStartPar
Limits the number of CUDA registers available
&
\sphinxAtStartPar
255
&
\sphinxAtStartPar
User\sphinxhyphen{}defined
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_PTX\_VERBOSE
&
\sphinxAtStartPar
Verbose code generation statistics in ptxas
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_SHOW\_CODELINES
&
\sphinxAtStartPar
Source information in PTX (optimizations: on)
&
\sphinxAtStartPar
Auto
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_SHOW\_LINENUMBERS
&
\sphinxAtStartPar
Line\sphinxhyphen{}number information (optimizations: on)
&
\sphinxAtStartPar
Auto
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_CUDA\_WARN\_CAPTURE\_THIS
&
\sphinxAtStartPar
Warn if a CUDA lambda captures a class’ this
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
The target architecture to build for can be specified via the configuration option
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_CUDA\_ARCH=\textless{}target\sphinxhyphen{}architecture\textgreater{}}}, where \sphinxcode{\sphinxupquote{\textless{}target\sphinxhyphen{}architecture\textgreater{}}} can be either
the name of the NVIDIA GPU generation, i.e. \sphinxcode{\sphinxupquote{Turing}}, \sphinxcode{\sphinxupquote{Volta}}, \sphinxcode{\sphinxupquote{Ampere}}, \sphinxcode{\sphinxupquote{...}} , or its
\sphinxhref{https://developer.nvidia.com/cuda-gpus}{compute capability}, i.e. \sphinxcode{\sphinxupquote{10.0}}, \sphinxcode{\sphinxupquote{9.0}},  \sphinxcode{\sphinxupquote{...}} .
For example, on Cori GPUs you can specify the architecture as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cmake [options] \PYGZhy{}DAMReX\PYGZus{}GPU\PYGZus{}BACKEND=CUDA \PYGZhy{}DAMReX\PYGZus{}CUDA\PYGZus{}ARCH=Volta /path/to/amrex/source}
\end{sphinxVerbatim}

\sphinxAtStartPar
If no architecture is specified, CMake will default to the architecture defined in the
\sphinxstyleemphasis{environment variable} \sphinxcode{\sphinxupquote{AMREX\_CUDA\_ARCH}} (note: all caps).
If the latter is not defined, CMake will try to determine which GPU architecture is supported by the system.
If more than one is found, CMake will build for all of them.
If autodetection fails, a list of “common” architectures is assumed.
\sphinxhref{https://cmake.org/cmake/help/latest/module/FindCUDA.html\#commands}{Multiple CUDA architectures} can also be set manually as semicolon\sphinxhyphen{}separated list, e.g. \sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_CUDA\_ARCH=7.0;8.0}}.
Building for multiple CUDA architectures will generally result in a larger library and longer build times.

\sphinxAtStartPar
\sphinxstylestrong{Note that AMReX supports NVIDIA GPU architectures with compute capability 6.0 or higher and
CUDA Toolkit version 9.0 or higher.}

\sphinxAtStartPar
In order to import the CUDA\sphinxhyphen{}enabled AMReX library into your CMake project, you need to include
the following code into the appropriate CMakeLists.txt file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }Find CUDA\PYGZhy{}enabled AMReX installation
\PYG{g+go}{find\PYGZus{}package(AMReX REQUIRED CUDA)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If instead of using an external installation of AMReX you prefer to include AMReX as a subproject
in your CMake setup, we strongly encourage you to use the \sphinxcode{\sphinxupquote{AMReX\_SetupCUDA}} module as shown below
if the CMake version is less than 3.20:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }Enable CUDA \PYG{k}{in} your CMake project
\PYG{g+go}{enable\PYGZus{}language(CUDA)}

\PYG{g+gp}{\PYGZsh{} }Include the AMReX\PYGZhy{}provided CUDA setup module \PYGZhy{}\PYGZhy{} OBSOLETE with CMake \PYGZgt{}\PYG{o}{=} \PYG{l+m}{3}.20
\PYG{g+go}{if(CMAKE\PYGZus{}VERSION VERSION\PYGZus{}LESS 3.20)}
\PYG{g+go}{    include(AMReX\PYGZus{}SetupCUDA)}
\PYG{g+go}{endif()}

\PYG{g+gp}{\PYGZsh{} }Include AMReX \PYG{n+nb}{source} directory ONLY AFTER the two steps above
\PYG{g+go}{add\PYGZus{}subdirectory(/path/to/amrex/source/dir)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To ensure consistency between CUDA\sphinxhyphen{}enabled AMReX and any CMake target that links against it,
we provide the helper function \sphinxcode{\sphinxupquote{setup\_target\_for\_cuda\_compilation()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{} }Set all sources \PYG{k}{for} my\PYGZus{}target
\PYG{g+go}{target\PYGZus{}sources(my\PYGZus{}target source1 source2 source3 ...)}

\PYG{g+gp}{\PYGZsh{} }Setup my\PYGZus{}target to be compiled with CUDA and be linked against CUDA\PYGZhy{}enabled AMReX
\PYG{g+gp}{\PYGZsh{} }MUST be \PYG{k}{done} AFTER all sources have been assigned to my\PYGZus{}target
\PYG{g+go}{setup\PYGZus{}target\PYGZus{}for\PYGZus{}cuda\PYGZus{}compilation(my\PYGZus{}target)}

\PYG{g+gp}{\PYGZsh{} }Link against amrex
\PYG{g+go}{target\PYGZus{}link\PYGZus{}libraries(my\PYGZus{}target AMReX::amrex)}
\end{sphinxVerbatim}


\subsubsection{Enabling HIP support (experimental)}
\label{\detokenize{GPU:enabling-hip-support-experimental}}
\sphinxAtStartPar
To build AMReX with HIP support in CMake, add
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_GPU\_BACKEND=HIP \sphinxhyphen{}DAMReX\_AMD\_ARCH=\textless{}target\sphinxhyphen{}arch\textgreater{} \sphinxhyphen{}DCMAKE\_CXX\_COMPILER=\textless{}your\sphinxhyphen{}hip\sphinxhyphen{}compiler\textgreater{}}}
to the \sphinxcode{\sphinxupquote{cmake}} invocation.
If you don’t need Fortran features (\sphinxcode{\sphinxupquote{AMReX\_FORTRAN=OFF}}), it is recommended to use AMD’s \sphinxcode{\sphinxupquote{clang++}} as the HIP compiler.
(Please see these issues for reference in rocm/HIP \textless{}= 4.2.0
\sphinxhref{https://github.com/ROCm-Developer-Tools/HIP/issues/2275}{{[}1{]}}
\sphinxhref{https://github.com/AMReX-Codes/amrex/pull/2031}{{[}2{]}}.)

\sphinxAtStartPar
In AMReX CMake, the HIP compiler is treated as a special C++ compiler and therefore
the standard CMake variables used to customize the compilation process for C++,
for example \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}}, can be used for HIP as well.

\sphinxAtStartPar
Since CMake does not support autodetection of HIP compilers/target architectures
yet, \sphinxcode{\sphinxupquote{CMAKE\_CXX\_COMPILER}} must be set to a valid HIP compiler, i.e. \sphinxcode{\sphinxupquote{clang++}} or \sphinxcode{\sphinxupquote{hipcc}} or \sphinxcode{\sphinxupquote{nvcc}},
and \sphinxcode{\sphinxupquote{AMReX\_AMD\_ARCH}} to the target architecture you are building for.
Thus \sphinxstylestrong{AMReX\_AMD\_ARCH and CMAKE\_CXX\_COMPILER are required user\sphinxhyphen{}inputs when AMReX\_GPU\_BACKEND=HIP}.
We again read also an \sphinxstyleemphasis{environment variable}: \sphinxcode{\sphinxupquote{AMREX\_AMD\_ARCH}} (note: all caps) and the C++ compiler can be hinted as always, e.g. with \sphinxcode{\sphinxupquote{export CXX=\$(which clang++)}}.
Below is an example configuration for HIP on Tulip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cmake \PYGZhy{}S . \PYGZhy{}B build \PYGZhy{}DAMReX\PYGZus{}GPU\PYGZus{}BACKEND=HIP \PYGZhy{}DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER=\PYGZdl{}(which clang++) \PYGZhy{}DAMReX\PYGZus{}AMD\PYGZus{}ARCH=\PYGZdq{}gfx906;gfx908\PYGZdq{}  \PYGZsh{} [other options]}
\PYG{g+go}{cmake \PYGZhy{}\PYGZhy{}build build \PYGZhy{}j 6}
\end{sphinxVerbatim}


\subsubsection{Enabling SYCL support (experimental)}
\label{\detokenize{GPU:enabling-sycl-support-experimental}}
\sphinxAtStartPar
To build AMReX with SYCL support in CMake, add
\sphinxcode{\sphinxupquote{\sphinxhyphen{}DAMReX\_GPU\_BACKEND=SYCL \sphinxhyphen{}DCMAKE\_CXX\_COMPILER=\textless{}your\sphinxhyphen{}sycl\sphinxhyphen{}compiler\textgreater{}}}
to the \sphinxcode{\sphinxupquote{cmake}} invocation.
For a full list of SYCL\sphinxhyphen{}specific configuration options,
check the {\hyperref[\detokenize{GPU:tab-cmakesyclvar}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} below.

\sphinxAtStartPar
In AMReX CMake, the SYCL compiler is treated as a special C++ compiler and therefore
the standard CMake variables used to customize the compilation process for C++,
for example \sphinxcode{\sphinxupquote{CMAKE\_CXX\_FLAGS}}, can be used for DPCPP as well.

\sphinxAtStartPar
Since CMake does not support autodetection of SYCL compilers yet,
\sphinxcode{\sphinxupquote{CMAKE\_CXX\_COMPILER}} must be set to a valid SYCL compiler. i.e. \sphinxcode{\sphinxupquote{dpcpp}}.
Thus \sphinxstylestrong{CMAKE\_CXX\_COMPILER is a required user\sphinxhyphen{}input when AMReX\_GPU\_BACKEND=SYCL}.
At this time, \sphinxstylestrong{the only supported SYCL compiler is dpcpp}.
Below is an example configuration for SYCL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cmake \PYGZhy{}DAMReX\PYGZus{}GPU\PYGZus{}BACKEND=SYCL \PYGZhy{}DCMAKE\PYGZus{}CXX\PYGZus{}COMPILER=\PYGZdl{}(which dpcpp)  [other options] /path/to/amrex/source}
\end{sphinxVerbatim}

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AMReX SYCL\sphinxhyphen{}specific build options}\label{\detokenize{GPU:id4}}\label{\detokenize{GPU:tab-cmakesyclvar}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Possible values
\\
\hline
\sphinxAtStartPar
AMReX\_DPCPP\_AOT
&
\sphinxAtStartPar
Enable DPCPP ahead\sphinxhyphen{}of\sphinxhyphen{}time compilation
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_DPCPP\_SPLIT\_KERNEL
&
\sphinxAtStartPar
Enable DPCPP kernel splitting
&
\sphinxAtStartPar
YES
&
\sphinxAtStartPar
YES, NO
\\
\hline
\sphinxAtStartPar
AMReX\_DPCPP\_ONEDPL
&
\sphinxAtStartPar
Enable DPCPP’s oneDPL algorithms
&
\sphinxAtStartPar
NO
&
\sphinxAtStartPar
YES, NO
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}


\section{Gpu Namespace and Macros}
\label{\detokenize{GPU:gpu-namespace-and-macros}}\label{\detokenize{GPU:sec-gpu-namespace}}
\sphinxAtStartPar
Most GPU related classes and functions are in \sphinxcode{\sphinxupquote{namespace Gpu}},
which is inside \sphinxcode{\sphinxupquote{namespace amrex}}. For example, the GPU configuration
class \sphinxcode{\sphinxupquote{Device}} can be referenced to at \sphinxcode{\sphinxupquote{amrex::Gpu::Device}}.

\sphinxAtStartPar
For portability, AMReX defines some macros for CUDA function qualifiers
and they should be preferred to allow execution with \sphinxcode{\sphinxupquote{USE\_CUDA=FALSE}}.
These include:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AMREX\PYGZus{}GPU\PYGZus{}HOST        \PYGZus{}\PYGZus{}host\PYGZus{}\PYGZus{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AMREX\PYGZus{}GPU\PYGZus{}DEVICE      \PYGZus{}\PYGZus{}device\PYGZus{}\PYGZus{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AMREX\PYGZus{}GPU\PYGZus{}GLOBAL      \PYGZus{}\PYGZus{}global\PYGZus{}\PYGZus{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AMREX\PYGZus{}GPU\PYGZus{}HOST\PYGZus{}DEVICE \PYGZus{}\PYGZus{}host\PYGZus{}\PYGZus{} \PYGZus{}\PYGZus{}device\PYGZus{}\PYGZus{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that when AMReX is not built with \sphinxcode{\sphinxupquote{CUDA/HIP/DPC++}},
these macros expand to empty space.

\sphinxAtStartPar
When AMReX is compiled with \sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}}, the preprocessor
macros \sphinxcode{\sphinxupquote{AMREX\_USE\_CUDA}} and \sphinxcode{\sphinxupquote{AMREX\_USE\_GPU}} are defined for
conditional programming.  When AMReX is compiled with
\sphinxcode{\sphinxupquote{USE\_ACC=TRUE}}, \sphinxcode{\sphinxupquote{AMREX\_USE\_ACC}} is defined.  When AMReX is
compiled with \sphinxcode{\sphinxupquote{USE\_OMP\_OFFLOAD=TRUE}}, \sphinxcode{\sphinxupquote{AMREX\_USE\_OMP\_OFFLOAD}} is
defined.

\sphinxAtStartPar
In addition to AMReX’s preprocessor macros, CUDA provides the
\sphinxcode{\sphinxupquote{\_\_CUDA\_ARCH\_\_}} macro which is only defined when in device code.
\sphinxcode{\sphinxupquote{\_\_CUDA\_ARCH\_\_}} should be used when a \sphinxcode{\sphinxupquote{\_\_host\_\_ \_\_device\_\_}}
function requires separate code for the CPU and GPU implementations.


\section{Memory Allocation}
\label{\detokenize{GPU:memory-allocation}}\label{\detokenize{GPU:sec-gpu-memory}}
\sphinxAtStartPar
To provide portability and improve memory allocation performance,
AMReX provides a number of memory pools.  When compiled without
CUDA, all \sphinxcode{\sphinxupquote{\DUrole{name}{Arena}}}s use standard \sphinxcode{\sphinxupquote{\DUrole{keyword}{new}}} and \sphinxcode{\sphinxupquote{\DUrole{keyword}{delete}}}
operators. With CUDA, the \sphinxcode{\sphinxupquote{\DUrole{name}{Arena}}}s each allocate with a
specific type of GPU memory:

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Memory Arenas}\label{\detokenize{GPU:id5}}\label{\detokenize{GPU:tab-gpu-arena}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Arena
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Memory Type
\\
\hline
\sphinxAtStartPar
The\_Arena()
&
\sphinxAtStartPar
managed or device memory
\\
\hline
\sphinxAtStartPar
The\_Managed\_Arena()
&
\sphinxAtStartPar
managed memory
\\
\hline
\sphinxAtStartPar
The\_Pinned\_Arena()
&
\sphinxAtStartPar
pinned memory
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
The Arena object returned by these calls provides access
to two functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{alloc} \PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{sz}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n+nf}{free} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{The\_Arena}\DUrole{punctuation}{()}}} is used for memory allocation of data in
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}.  By default, it allocates managed memory.  This can be changed with
a boolean runtime parameter \sphinxcode{\sphinxupquote{amrex.the\_arena\_is\_managed}}.
Therefore the data in a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} is placed in
managed memory by default and is accessible from both CPU host and GPU device.
This allows application codes to develop their GPU capability
gradually. The behavior of \sphinxcode{\sphinxupquote{\DUrole{name}{The\_Managed\_Arena}\DUrole{punctuation}{()}}} likewise depends on the
\sphinxcode{\sphinxupquote{amrex.the\_arena\_is\_managed}} parameter. If \sphinxcode{\sphinxupquote{amrex.the\_arena\_is\_managed=0}},
\sphinxcode{\sphinxupquote{\DUrole{name}{The\_Managed\_Arena}\DUrole{punctuation}{()}}} is a separate pool of managed memory. If
\sphinxcode{\sphinxupquote{amrex.the\_arena\_is\_managed=1}}, \sphinxcode{\sphinxupquote{\DUrole{name}{The\_Managed\_Arena}\DUrole{punctuation}{()}}} is simply aliased
to \sphinxcode{\sphinxupquote{\DUrole{name}{The\_Arena}\DUrole{punctuation}{()}}} to reduce memory fragmentation.

\sphinxAtStartPar
If you want to print out the current memory usage
of the Arenas, you can call \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Arena}\DUrole{operator}{::}\DUrole{name}{PrintUsage}\DUrole{punctuation}{()}}}.
When AMReX is built with SUNDIALS turned on, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{sundials}\DUrole{operator}{::}\DUrole{name}{The\_SUNMemory\_Helper}\DUrole{punctuation}{()}}}
can be provided to SUNDIALS data structures so that they use the appropriate
Arena object when allocating memory. For example, it can be provided to the
SUNDIALS CUDA vector:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{n}{x} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNewWithMemHelp\PYGZus{}Cuda}\PYG{p}{(}\PYG{n}{size}\PYG{p}{,} \PYG{n}{use\PYGZus{}managed\PYGZus{}memory}\PYG{p}{,} \PYG{o}{*}\PYG{n}{The\PYGZus{}SUNMemory\PYGZus{}Helper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{GPU Safe Classes and Functions}
\label{\detokenize{GPU:gpu-safe-classes-and-functions}}\label{\detokenize{GPU:sec-gpu-classes}}
\sphinxAtStartPar
AMReX GPU work takes place inside of MFIter and particle loops.
Therefore, there are two ways classes and functions have been modified
to interact with the GPU:

\sphinxAtStartPar
1. A number of functions used within these loops are labelled using
\sphinxcode{\sphinxupquote{AMREX\_GPU\_HOST\_DEVICE}} and can be called on the device. This includes member
functions, such as \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}\DUrole{operator}{::}\DUrole{name}{type}\DUrole{punctuation}{()}}}, as well as non\sphinxhyphen{}member functions,
such as \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{min}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{max}}}. In specialized cases,
classes are labeled such that the object can be constructed, destructed
and its functions can be implemented on the device, including \sphinxcode{\sphinxupquote{IntVect}}.

\sphinxAtStartPar
2. Functions that contain MFIter or particle loops have been rewritten
to contain device launches. For example, the \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}}
function cannot be called from device code, but calling it from
CPU will launch GPU kernels if AMReX is compiled with GPU support.

\sphinxAtStartPar
Necessary and convenient AMReX functions and objects have been given a device
version and/or device access.

\sphinxAtStartPar
In this section, we discuss some examples of AMReX device classes and functions
that are important for programming GPUs.


\subsection{GpuArray, Array1D, Array2D, and Array3D}
\label{\detokenize{GPU:gpuarray-array1d-array2d-and-array3d}}
\sphinxAtStartPar
As we have mentioned in {\hyperref[\detokenize{Basics:sec-basics-vecandarr}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector, Array, GpuArray, Array1D, Array2D, and Array3D}}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{std}\DUrole{operator}{::}\DUrole{name}{array}}}
cannot be used in device code, whereas \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}},
\sphinxcode{\sphinxupquote{\DUrole{name}{Array1D}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{Array2D}}}, and \sphinxcode{\sphinxupquote{\DUrole{name}{Array3D}}} are trivial types
that work on both host and device. They can be used whenever a fixed size array
needs to be passed to the GPU or created on GPU.  A variety of
functions in AMReX return \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}} and they can be
lambda\sphinxhyphen{}captured to GPU code. For example,
\sphinxcode{\sphinxupquote{\DUrole{name}{GeometryData}\DUrole{operator}{::}\DUrole{name}{CellSizeArray}\DUrole{punctuation}{()}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{GeometryData}\DUrole{operator}{::}\DUrole{name}{InvCellSizeArray}\DUrole{punctuation}{()}}}
and \sphinxcode{\sphinxupquote{\DUrole{name}{Box}\DUrole{operator}{::}\DUrole{name}{length3d}\DUrole{punctuation}{()}}} all return \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}}s.


\subsection{AsyncArray}
\label{\detokenize{GPU:asyncarray}}\label{\detokenize{GPU:sec-gpu-classes-asyncarray}}
\sphinxAtStartPar
Where the \sphinxcode{\sphinxupquote{\DUrole{name}{GpuArray}}} is a statically\sphinxhyphen{}sized array designed to be
passed by value onto the device, \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} is a
dynamically\sphinxhyphen{}sized array container designed to work between the CPU and
GPU. \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} stores a CPU pointer and a GPU pointer and
coordinates the movement of an array of objects between the two.  It
can take initial values from the host and move them to the device.  It
can copy the data from device back to host.  It can also be used as
scratch space on device.

\sphinxAtStartPar
The call to delete the memory is added to the GPU stream as a callback
function in the destructor of \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}}. This guarantees the
memory allocated in \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} continues to exist after the
\sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} object is deleted when going out of scope until
after all GPU kernels in the stream are completed without forcing the
code to synchronize. The resulting \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} class is
“async\sphinxhyphen{}safe”, meaning it can be safely used in asynchronous code
regions that contain both CPU work and GPU launches, including
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} is also portable. When built without \sphinxcode{\sphinxupquote{USE\_CUDA}}, the
object only stores and handles the CPU version of the data.

\sphinxAtStartPar
An example using \sphinxcode{\sphinxupquote{\DUrole{name}{AsyncArray}}} is given below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n}{h\PYGZus{}s} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}
\PYG{n}{AsyncArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{aa\PYGZus{}s}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{h\PYGZus{}s}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Build AsyncArray of size 1}
\PYG{n}{Real}\PYG{o}{*} \PYG{n}{d\PYGZus{}s} \PYG{o}{=} \PYG{n}{aa\PYGZus{}s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{// Get associated device pointer}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{h\PYGZus{}v} \PYG{o}{=} \PYG{n}{a\PYGZus{}cpu\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{AsyncArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{aa\PYGZus{}v1}\PYG{p}{(}\PYG{n}{h\PYGZus{}v}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{h\PYGZus{}v}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Real}\PYG{o}{*} \PYG{n}{d\PYGZus{}v1} \PYG{o}{=} \PYG{n}{aa\PYGZus{}v1}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// A device copy of the data}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{n} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
    \PYG{n}{AsyncArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{aa\PYGZus{}v2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Allocate temporary space on device}
    \PYG{n}{Real}\PYG{o}{*} \PYG{n}{d\PYGZus{}v2} \PYG{o}{=} \PYG{n}{aa\PYGZus{}v2}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// A device pointer to uninitialized data}

    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// gpu kernels using the data pointed by d\PYGZus{}v1 and atomically}
        \PYG{c+c1}{// updating the data pointed by d\PYGZus{}s.}
        \PYG{c+c1}{// d\PYGZus{}v2 can be used as scratch space and for pass data}
        \PYG{c+c1}{// between kernels.}

    \PYG{c+c1}{// If needed, we can copy the data back to host using}
    \PYG{c+c1}{// AsyncArray::copyToHost(host\PYGZus{}pointer, number\PYGZus{}of\PYGZus{}elements);}

    \PYG{c+c1}{// At the end of each loop the compiler inserts a call to the}
    \PYG{c+c1}{// destructor of aa\PYGZus{}v* on cpu.  Objects aa\PYGZus{}v* are deleted, but}
    \PYG{c+c1}{// their associated memory pointed by d\PYGZus{}v* is not deleted}
    \PYG{c+c1}{// immediately until the gpu kernels in this loop finish.}
\PYG{p}{\PYGZcb{}}

\PYG{n}{aa\PYGZus{}s}\PYG{p}{.}\PYG{n}{copyToHost}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{h\PYGZus{}s}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Copy the value back to host}
\end{sphinxVerbatim}


\subsection{Gpu Vectors}
\label{\detokenize{GPU:gpu-vectors}}
\sphinxAtStartPar
AMReX also provides a number of dynamic vectors for use with GPU kernels.
These are configured to use the different AMReX memory Arenas, as
summarized below. By using the memory Arenas, we can avoid expensive
allocations and deallocations when (for example) resizing vectors.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Memory Arenas Associated with each Gpu Vector}\label{\detokenize{GPU:id6}}\label{\detokenize{GPU:tab-gpu-gpuvectors}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Vector
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Arena
\\
\hline
\sphinxAtStartPar
DeviceVector
&
\sphinxAtStartPar
The\_Arena()
\\
\hline
\sphinxAtStartPar
HostVector
&
\sphinxAtStartPar
The\_Pinned\_Arena()
\\
\hline
\sphinxAtStartPar
ManagedVector
&
\sphinxAtStartPar
The\_Managed\_Arena()
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
These classes behave identically to an
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Vector}}}, (see {\hyperref[\detokenize{Basics:sec-basics-vecandarr}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector, Array, GpuArray, Array1D, Array2D, and Array3D}}}}), except that they
can only hold “plain\sphinxhyphen{}old\sphinxhyphen{}data” objects (e.g. Reals, integers, amrex Particles,
etc… ). If you want a resizable vector that doesn’t use a memory Arena,
simply use \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Vector}}}.

\sphinxAtStartPar
Note that, even if the data in the vector is  managed and available on GPUs,
the member functions of e.g. \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{ManagedVector}}} are not.
To use the data on the GPU, it is necessary to pass the underlying data pointer
in to the GPU kernels. The managed data pointer can be accessed using the \sphinxcode{\sphinxupquote{\DUrole{name}{data}\DUrole{punctuation}{()}}}
member function.

\sphinxAtStartPar
Be aware: resizing of dynamically allocated memory on the GPU is unsupported.
All resizing of the vector should be done on the CPU, in a manner that avoids
race conditions with concurrent GPU kernels.

\sphinxAtStartPar
Also note: \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{ManagedVector}}} is not async\sphinxhyphen{}safe.  It cannot be safely
constructed inside of an MFIter loop with GPU kernels and great care should
be used when accessing \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{ManagedVector}}} data on GPUs to avoid race
conditions.


\subsection{amrex::min and amrex::max}
\label{\detokenize{GPU:amrex-min-and-amrex-max}}
\sphinxAtStartPar
GPU versions of \sphinxcode{\sphinxupquote{std::min}} and \sphinxcode{\sphinxupquote{std::max}} are not provided in CUDA.
So, AMReX provides a templated \sphinxcode{\sphinxupquote{\DUrole{name}{min}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{max}}} with host and
device versions to allow functionality on GPUs. Invoke the explicitly
namespaced \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{min}\DUrole{punctuation}{(}\DUrole{name}{A}\DUrole{punctuation}{,} \DUrole{name}{B}\DUrole{punctuation}{)}}} or \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{max}\DUrole{punctuation}{(}\DUrole{name}{x}\DUrole{punctuation}{,} \DUrole{name}{y}\DUrole{punctuation}{)}}} to use the
GPU safe implementations. These functions are variadic, so they can take
any number of arguments and can be invoked with any standard data type.


\subsection{MultiFab Reductions}
\label{\detokenize{GPU:multifab-reductions}}
\sphinxAtStartPar
AMReX provides functions for performing standard reduction operations on
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFabs}}}, including \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{sum}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}\DUrole{operator}{::}\DUrole{name}{max}}}.
When \sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}}, these functions automatically implement the
corresponding reductions on GPUs in an efficient manner.

\sphinxAtStartPar
Function templates \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceSum}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceMin}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceMax}}} can be used to implement user\sphinxhyphen{}defined reduction
functions over \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s. These same templates are implemented
in the \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} functions, so they can be used as a reference to
build a custom reduction. For example, the \sphinxcode{\sphinxupquote{\DUrole{name,label}{MultiFab}\DUrole{punctuation}{:}\DUrole{name}{Dot}}}
implementation is reproduced here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Real} \PYG{n+nf}{MultiFab::Dot} \PYG{p}{(}\PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{xcomp}\PYG{p}{,}
                    \PYG{k}{const} \PYG{n}{MultiFab}\PYG{o}{\PYGZam{}} \PYG{n}{y}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ycomp}\PYG{p}{,}
                    \PYG{k+kt}{int} \PYG{n}{numcomp}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{nghost}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{local}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Real} \PYG{n}{sm} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ReduceSum}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{nghost}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}HOST\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{FArrayBox} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{xfab}\PYG{p}{,} \PYG{n}{FArrayBox} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{yfab}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Real}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{xfab}\PYG{p}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}\PYG{n}{xcomp}\PYG{p}{,}\PYG{n}{yfab}\PYG{p}{,}\PYG{n}{bx}\PYG{p}{,}\PYG{n}{ycomp}\PYG{p}{,}\PYG{n}{numcomp}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{local}\PYG{p}{)} \PYG{n}{ParallelAllReduce}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Sum}\PYG{p}{(}\PYG{n}{sm}\PYG{p}{,} \PYG{n}{ParallelContext}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CommunicatorSub}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{sm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceSum}}} takes two \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s, \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} and
returns the sum of the value returned from the given lambda function.
In this case, \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{::}\DUrole{name}{dot}}} is returned, yielding a sum of the
dot product of each local pair of \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}s. Finally,
\sphinxcode{\sphinxupquote{\DUrole{name}{ParallelAllReduce}}} is used to sum the dot products across all
MPI ranks and return the total dot product of the two
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s.

\sphinxAtStartPar
To implement a different reduction, replace the code block inside the
lambda function with the operation that should be applied, being sure
to return the value to be summed, minimized, or maximized.  The reduction
templates have a few different interfaces to accommodate a variety of
reductions.  The \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceSum}}} reduction template has varieties
that take either one, two or three :\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}s.
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceMin}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ReduceMax}}} can take either one
or two.


\subsection{Box, IntVect and IndexType}
\label{\detokenize{GPU:box-intvect-and-indextype}}
\sphinxAtStartPar
In AMReX, \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{IntVect}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{IndexType}}}
are classes for representing indices.  These classes and most of
their member functions, including constructors and destructors,
have both host and device versions.  They can be used freely
in device code.


\subsection{Geometry}
\label{\detokenize{GPU:geometry}}
\sphinxAtStartPar
AMReX’s \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}} class is not a GPU safe class.  However, we often need
to use geometric information such as cell size and physical coordinates
in GPU kernels.  We can use the following member functions and pass
the returned values to GPU kernels:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GpuArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{ProbLoArray} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{n}{GpuArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{ProbHiArray} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{n}{GpuArray}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{isPeriodicArray} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{n}{GpuArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{CellSizeArray} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\PYG{n}{GpuArray}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{p}{,}\PYG{n}{AMREX\PYGZus{}SPACEDIM}\PYG{o}{\PYGZgt{}} \PYG{n}{InvCellSizeArray} \PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{k}{noexcept}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, we can copy the data into a GPU safe class that can be
passed by value to GPU kernels. This class is called
\sphinxcode{\sphinxupquote{\DUrole{name}{GeometryData}}}, which is created by calling
\sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}\DUrole{operator}{::}\DUrole{name}{data}\DUrole{punctuation}{()}}}.  The accessor functions of
\sphinxcode{\sphinxupquote{\DUrole{name}{GeometryData}}} are identical to \sphinxcode{\sphinxupquote{\DUrole{name}{Geometry}}}.


\subsection{BaseFab, FArrayBox, IArrayBox}
\label{\detokenize{GPU:basefab-farraybox-iarraybox}}\label{\detokenize{GPU:sec-gpu-classes-basefab}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{name}{T}\DUrole{operator}{\textgreater{}}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{IArrayBox}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} have some GPU
support.  They cannot be constructed in device code unless they are
constructed as an alias to \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}.  Many of their member
functions can be used in device code as long as they have been
constructed in device memory. Some of the device member functions
include \sphinxcode{\sphinxupquote{\DUrole{name}{array}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{dataPtr}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{box}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{nComp}}}, and
\sphinxcode{\sphinxupquote{\DUrole{name}{setVal}}}.

\sphinxAtStartPar
All \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{\textless{}}\DUrole{name}{T}\DUrole{operator}{\textgreater{}}}} objects in \sphinxcode{\sphinxupquote{\DUrole{name}{FabArray}\DUrole{operator}{\textless{}}\DUrole{name}{FAB}\DUrole{operator}{\textgreater{}}}} are allocated in
CPU memory, including \sphinxcode{\sphinxupquote{\DUrole{name}{IArrayBox}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}, which are
derived from \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}}, although the array data contained are
allocated in managed memory.  We cannot pass a \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} object by
value because they do not have copy constructor.  However, we can make
an \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} using member function \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{::}\DUrole{name}{array}\DUrole{punctuation}{()}}}, and pass it
by value to GPU kernels. In GPU device code, we can use \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}
or, if necessary, we can make an alias \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}}} from an
\sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}HOST\PYGZus{}DEVICE} \PYG{k+kt}{void} \PYG{n}{g} \PYG{p}{(}\PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}

\PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}HOST\PYGZus{}DEVICE} \PYG{k+kt}{void} \PYG{n}{f} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{FArrayBox} \PYG{n+nf}{fab}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{bx}\PYG{p}{.}\PYG{n}{ixType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{g}\PYG{p}{(}\PYG{n}{fab}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Elixir}
\label{\detokenize{GPU:elixir}}\label{\detokenize{GPU:sec-gpu-classes-elixir}}
\sphinxAtStartPar
We often have temporary \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}es in \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops.
These objects go out of scope at the end of each iteration.  Because
of the asynchronous nature of GPU kernel execution, their destructors
might get called before their data are used on GPU.  \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}} can
be used to extend the life of the data.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{FArrayBox} \PYG{n+nf}{tmp\PYGZus{}fab}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{n}{numcomps}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Elixir} \PYG{n}{tmp\PYGZus{}eli} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}fab}\PYG{p}{.}\PYG{n}{elixir}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{tmp\PYGZus{}arr} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}fab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// GPU kernels using the temporary}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Without \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}}, the code above will likely cause memory errors
because the temporary \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} is deleted on cpu before the
gpu kernels use its memory.  With \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}}, the ownership of the
memory is transferred to \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}} that is guaranteed to be
async\sphinxhyphen{}safe.


\subsection{Async Arena}
\label{\detokenize{GPU:async-arena}}
\sphinxAtStartPar
CUDA 11.2 has introduced a new feature, stream\sphinxhyphen{}ordered CUDA memory
allocator.  This feature enables AMReX to solve the temporary memory
allocation and deallocation issue discussed above using a memory pool.
Instead of using \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}}, we can write code like below,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{FArrayBox} \PYG{n+nf}{tmp\PYGZus{}fab}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{n}{numcomps}\PYG{p}{,} \PYG{n}{The\PYGZus{}Async\PYGZus{}Arena}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{tmp\PYGZus{}arr} \PYG{o}{=} \PYG{n}{tmp\PYGZus{}fab}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{FArrayBox} \PYG{n}{tmp\PYGZus{}fab\PYGZus{}2}\PYG{p}{;}
  \PYG{n}{tmp\PYGZus{}fab\PYGZus{}2}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{n}{numcomps}\PYG{p}{,} \PYG{n}{The\PYGZus{}Async\PYGZus{}Arena}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{// GPU kernels using the temporary}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is now the recommended way because it’s usually more efficient than
\sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}}.  Note that the code above works for CUDA older than 11.2, HIP
and DPC++ as well, and it’s equivalent to using \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}} in these
cases.  By default, the release threshold for the memory pool is unlimited.
One can adjust it with \sphinxcode{\sphinxupquote{\DUrole{name}{ParmParse}}} parameter,
\sphinxcode{\sphinxupquote{amrex.the\_async\_arena\_release\_threshold}}.


\section{Kernel Launch}
\label{\detokenize{GPU:kernel-launch}}\label{\detokenize{GPU:sec-gpu-launch}}
\sphinxAtStartPar
In this section, how to offload work to the GPU will be demonstrated.
AMReX supports offloading work with CUDA, OpenACC, or OpenMP.

\sphinxAtStartPar
When using CUDA, AMReX provides users with portable C++ function calls or
C++ macros that launch a user\sphinxhyphen{}defined lambda function.  When compiled without CUDA,
the lambda function is ran on the CPU. When compiled with CUDA, the launch function
prepares and launches the lambda function on the GPU. The preparation includes
calculating the appropriate number of blocks and threads, selecting the CUDA stream
and defining the appropriate work chunk for each CUDA thread.

\sphinxAtStartPar
When using OpenACC or OpenMP offloading pragmas, the users add the appropriate
pragmas to their work loops and functions to offload to the GPU.  These work
in conjunction with AMReX’s internal CUDA\sphinxhyphen{}based memory management, described
earlier, to ensure the required data is available on the GPU when the offloaded
function is executed.

\sphinxAtStartPar
The available launch schema are presented here in three categories: launching
nested loops over Boxes or 1D arrays, launching generic work and launching using
OpenACC or  OpenMP pragmas. The latest versions of the examples used in this section
of the documentation can be found in the AMReX source code in the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/GPU\_Tutorial.html\#launch}{Launch} tutorials.
Users should also refer to Chapter {\hyperref[\detokenize{Basics_Chapter:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Basics}}}} as needed for information about basic
AMReX classes.

\sphinxAtStartPar
AMReX also recommends writing primary floating point operation kernels
in C++ using AMReX’s \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} object syntax.  It provides a
multi\sphinxhyphen{}dimensional array syntax, similar in appearance to Fortran,
while maintaining performance.  The details can be found in
{\hyperref[\detokenize{Basics:sec-basics-array4}]{\sphinxcrossref{\DUrole{std,std-ref}{Array4}}}} and {\hyperref[\detokenize{Basics:sec-basics-cppkernel}]{\sphinxcrossref{\DUrole{std,std-ref}{C++ Kernel}}}}.


\subsection{Launching C++ nested loops}
\label{\detokenize{GPU:launching-c-nested-loops}}\label{\detokenize{GPU:sec-gpu-for}}
\sphinxAtStartPar
The most common AMReX work construct is a set of nested loops over
the cells in a box. AMReX provides C++ functions and macro equivalents to port nested
loops efficiently onto the GPU.  There are 3 different nested loop GPU
launches: a 4D launch for work over a box and a number of components, a 3D
launch for work over a box and a 1D launch for work over a number of arbitrary elements.
Each of these launches provides a performance portable set of nested loops for
both CPU and GPU applications.

\sphinxAtStartPar
These loop launches should only be used when each iteration of the
nested loop is independent of other iterations.  Therefore, these
launches have been marked with \sphinxcode{\sphinxupquote{AMREX\_PRAGMA\_SIMD}} when using the
CPU and they should only be used for \sphinxcode{\sphinxupquote{simd}}\sphinxhyphen{}capable nested loops.
Calculations that cannot vectorize should be rewritten wherever
possible to allow efficient utilization of GPU hardware.

\sphinxAtStartPar
However, it is important for applications to use these launches whenever appropriate
because they contain optimizations for both CPU and GPU variations of nested
loops.  For example, on the GPU the spatial coordinate loops are reduced to a single
loop and the component loop is moved to these inner most loop.  AMReX’s launch functions
apply the appropriate optimizations for \sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}} and \sphinxcode{\sphinxupquote{USE\_CUDA=FALSE}} in a
compact and readable format.

\sphinxAtStartPar
AMReX also provides a variation of the launch function that is implemented as a
C++ macro.  It behaves identically to the function, but hides the lambda function
from to the user.  There are some subtle differences between the two implementations,
that will be discussed.  It is up to the user to select which version they would like
to use.  For simplicity, the function variation will be discussed throughout the rest of
this documentation, however all code snippets will also include the macro variation
for reference.

\sphinxAtStartPar
A 4D example of the launch function, \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ParallelFor}}}, is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{ncomp} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{n}{ncomp}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{fab}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/* MACRO VARIATION:}
\PYG{c+cm}{    /}
\PYG{c+cm}{    /   AMREX\PYGZus{}PARALLEL\PYGZus{}FOR\PYGZus{}4D ( bx, ncomp, i, j, k, n,}
\PYG{c+cm}{    /   \PYGZob{}}
\PYG{c+cm}{    /       fab(i,j,k,n) += 1.;}
\PYG{c+cm}{    /   \PYGZcb{});}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This code works whether it is compiled for GPUs or CPUs. \sphinxcode{\sphinxupquote{\DUrole{name}{TilingIfNotGPU}\DUrole{punctuation}{()}}}
returns \sphinxcode{\sphinxupquote{false}} in the GPU case to turn off tiling and maximize the amount of
work given to the GPU in each launch. When tiling is off, \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}\DUrole{punctuation}{()}}}
returns the \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}\DUrole{punctuation}{()}}}.  The \sphinxcode{\sphinxupquote{\DUrole{name}{BaseFab}\DUrole{operator}{::}\DUrole{name}{array}\DUrole{punctuation}{()}}} function returns a
lightweight \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} object that defines access to the underlying \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}
data.  The \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}s is then captured by the C++ lambda functions defined in the
launch function.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{amrex::ParallelFor()}} expands into different variations of a quadruply\sphinxhyphen{}nested
\sphinxcode{\sphinxupquote{\DUrole{keyword}{for}}} loop depending dimensionality and whether it is being implemented on CPU or GPU.
The best way to understand this macro is to take a look at the 4D \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ParallelFor}}}
that is implemented when \sphinxcode{\sphinxupquote{USE\_CUDA=FALSE}}. A simplified version is reproduced here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{ParallelFor} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{box}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ncomp}\PYG{p}{,} \PYG{c+cm}{/* LAMBDA FUNCTION */}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Dim3} \PYG{n}{lo} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{lbound}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Dim3} \PYG{n}{hi} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ubound}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{ncomp}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{z} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{z}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{z}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{y} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{y}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{AMREX\PYGZus{}PRAGMA\PYGZus{}SIMD}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{hi}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{x}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{c+cm}{/* LAUNCH LAMBDA FUNCTION (x,y,z,n) */}
        \PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{ParallelFor}}} takes a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} and a number of components, which define the bounds
of the quadruply\sphinxhyphen{}nested \sphinxcode{\sphinxupquote{\DUrole{keyword}{for}}} loop, and a lambda function to run on each iteration of the
nested loop.  The lambda function takes the loop iterators as parameters, allowing the current
cell to be indexed in the lambda.  In addition to the loop indices, the lambda function captures
any necessary objects defined in the local scope.

\sphinxAtStartPar
CUDA lambda functions can only capture by value, as the information
must be able to be copied onto the device.  In this example, the
lambda function captures a \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} object, \sphinxcode{\sphinxupquote{fab}}, that defines
how to access the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}}.  The macro uses \sphinxcode{\sphinxupquote{fab}} to
increment the value of each cell within the \sphinxcode{\sphinxupquote{\DUrole{name}{Box} \DUrole{name}{bx}}}.  If
\sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}}, this incrementation is performed on the GPU, with
GPU optimized loops.

\sphinxAtStartPar
This 4D launch can also be used to work over any sequential set of components, by passing the
number of consecutive components and adding the iterator to the starting component:
\sphinxcode{\sphinxupquote{\DUrole{name}{fab}\DUrole{punctuation}{(}\DUrole{name}{i}\DUrole{punctuation}{,}\DUrole{name}{j}\DUrole{punctuation}{,}\DUrole{name}{k}\DUrole{punctuation}{,}\DUrole{name}{n\_start}\DUrole{operator}{+}\DUrole{name}{n}\DUrole{punctuation}{)}}}.

\sphinxAtStartPar
The 3D variation of the loop launch does not include a component loop and has the syntax
shown here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{k}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{fab}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/* MACRO VARIATION:}
\PYG{c+cm}{    /}
\PYG{c+cm}{    /   AMREX\PYGZus{}PARALLEL\PYGZus{}FOR\PYGZus{}3D ( bx, i, j, k,}
\PYG{c+cm}{    /   \PYGZob{}}
\PYG{c+cm}{    /       fab(i,j,k) += 1.;}
\PYG{c+cm}{    /   \PYGZcb{});}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, a 1D version is available for looping over a number of elements, such as particles.
An example of a 1D function launch is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Real}\PYG{o}{*} \PYG{n}{AMREX\PYGZus{}RESTRICT} \PYG{n}{p} \PYG{o}{=} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{dataPtr}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{k+kt}{long} \PYG{n}{nitems} \PYG{o}{=} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{box}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{numPts}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{fab}\PYG{p}{.}\PYG{n}{nComp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ParallelFor}\PYG{p}{(}\PYG{n}{nitems}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{k+kt}{long} \PYG{n}{idx}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{p}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/* MACRO VARIATION:}
\PYG{c+cm}{    /}
\PYG{c+cm}{    /   AMREX\PYGZus{}PARALLEL\PYGZus{}FOR\PYGZus{}1D ( nitems, idx,}
\PYG{c+cm}{    /   \PYGZob{}}
\PYG{c+cm}{    /       p[idx] += 1.;}
\PYG{c+cm}{    /   \PYGZcb{});}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Instead of passing an \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}}, \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}\DUrole{operator}{::}\DUrole{name}{dataPtr}\DUrole{punctuation}{()}}} is called to obtain a
CUDA managed pointer to the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} data.  This is an alternative way to access
the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} data on the GPU. Instead of passing a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} to define the loop
bounds, a \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{long}}} or \sphinxcode{\sphinxupquote{\DUrole{keyword,type}{int}}} number of elements is passed to bound the single
\sphinxcode{\sphinxupquote{\DUrole{keyword}{for}}} loop.  This construct can be used to work on any contiguous set of memory by
passing the number of elements to work on and indexing the pointer to the starting
element: \sphinxcode{\sphinxupquote{\DUrole{name}{p}\DUrole{punctuation}{{[}}\DUrole{name}{idx} \DUrole{operator}{+} \DUrole{literal,number,integer}{15}\DUrole{punctuation}{{]}}}}.


\subsection{Launching general kernels}
\label{\detokenize{GPU:launching-general-kernels}}
\sphinxAtStartPar
To launch more general work on the GPU, AMReX provides a standard launch function:
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{launch}}}.  Instead of creating nested loops, this function
prepares the device launch based on a \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}, launches with an appropriate sized
GPU kernel and constructs a thread \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} that defines the work for each thread.
On the CPU, the thread \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} is set equal to the total launch \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}}, so
tiling works as expected.  On the GPU, the thread \sphinxcode{\sphinxupquote{\DUrole{name}{Box}}} usually
contains a single cell to allow all GPU threads to be utilized effectively.

\sphinxAtStartPar
An example of a generic function launch is shown here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{arr} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{launch}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{tbx}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{pluseone\PYGZus{}array4}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,} \PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{FArrayBox} \PYG{n+nf}{fab}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{tbx}\PYG{p}{.}\PYG{n}{ixType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{plusone\PYGZus{}fab}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,} \PYG{n}{fab}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// this version takes FArrayBox}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/* MACRO VARIATION}
\PYG{c+cm}{    /}
\PYG{c+cm}{    /   AMREX\PYGZus{}LAUNCH\PYGZus{}DEVICE\PYGZus{}LAMBDA ( bx, tbx,}
\PYG{c+cm}{    /   \PYGZob{}}
\PYG{c+cm}{    /       plusone\PYGZus{}array4(tbx, arr);}
\PYG{c+cm}{    /       plusone\PYGZus{}fab(tbx, FArrayBox(arr,tbx.ixType()));}
\PYG{c+cm}{    /   \PYGZcb{});}
\PYG{c+cm}{    */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It also shows how to make a \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} from \sphinxcode{\sphinxupquote{\DUrole{name}{Array4}}} when
needed.  Note that \sphinxcode{\sphinxupquote{\DUrole{name}{FarrayBox}}}es cannot be passed to GPU
kernels directly.  \sphinxcode{\sphinxupquote{\DUrole{name}{TilingIfNotGPU}\DUrole{punctuation}{()}}} returns \sphinxcode{\sphinxupquote{false}} in the
GPU case to turn off tiling and maximize the amount of work given to
the GPU in each launch, which substantially improves performance.
When tiling is off, \sphinxcode{\sphinxupquote{\DUrole{name}{tilebox}\DUrole{punctuation}{()}}} returns the \sphinxcode{\sphinxupquote{\DUrole{name}{validbox}\DUrole{punctuation}{()}}} of
the \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} for that iteration.


\subsection{Offloading work using OpenACC or OpenMP pragmas}
\label{\detokenize{GPU:offloading-work-using-openacc-or-openmp-pragmas}}
\sphinxAtStartPar
When using OpenACC or OpenMP with AMReX, the GPU offloading work is done
with pragmas placed on the nested loops. This leaves the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop
largely unchanged.  An example GPU pragma based \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop that calls
a Fortran function is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{bx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab} \PYG{o}{=} \PYG{n}{mf}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{plusone\PYGZus{}acc}\PYG{p}{(}\PYG{n}{BL\PYGZus{}TO\PYGZus{}FORTRAN\PYGZus{}BOX}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{BL\PYGZus{}TO\PYGZus{}FORTRAN\PYGZus{}ANYD}\PYG{p}{(}\PYG{n}{fab}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{plusone\_acc}} is a CPU host function.  The
\sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} reference
from \sphinxcode{\sphinxupquote{\DUrole{keyword}{operator}\DUrole{punctuation}{{[}{]}}}} is a reference to a \sphinxcode{\sphinxupquote{\DUrole{name}{FArrayBox}}} in host
memory with data that has been placed in managed CUDA memory.
\sphinxcode{\sphinxupquote{BL\_TO\_FORTRAN\_BOX}} and \sphinxcode{\sphinxupquote{BL\_TO\_FORTRAN\_ANYD}} behave identically
to implementations used on the CPU.  These macros return the
individual components of the AMReX C++ objects to allow passing to
the Fortran function.

\sphinxAtStartPar
The corresponding OpenACC labelled loop in \sphinxcode{\sphinxupquote{plusone\_acc}} is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!dat = pointer to fab\PYGZsq{}s managed data}

\PYG{c}{!\PYGZdl{}acc kernels deviceptr(dat)}
\PYG{k}{do       }\PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{k}{do    }\PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
      \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
         \PYG{n}{dat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{dat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.0\PYGZus{}amrex\PYGZus{}real}
      \PYG{k}{end }\PYG{k}{do}
\PYG{k}{   }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{end }\PYG{k}{do}
\PYG{c}{!\PYGZdl{}acc end kernels}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since the data pointer passed to \sphinxcode{\sphinxupquote{plusone\_acc}} points to
unified memory, OpenACC can be told the data is available on the
device using the \sphinxcode{\sphinxupquote{deviceptr}} construct.  For further details
about OpenACC programming, consult the OpenACC user’s guide.

\sphinxAtStartPar
The OpenMP implementation of this loop is similar, only requiring
changing the pragmas utilized to obtain the proper offloading. The
OpenMP labelled version of this loop is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{!dat = pointer to fab\PYGZsq{}s managed data}

\PYG{c}{!\PYGZdl{}omp target teams distribute parallel do collapse(3) schedule(static,1) is\PYGZus{}device\PYGZus{}ptr(dat)}
\PYG{k}{do       }\PYG{n}{k} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{k}{do    }\PYG{n}{j} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
      \PYG{k}{do }\PYG{n}{i} \PYG{o}{=} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{hi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
         \PYG{n}{dat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{=} \PYG{n}{dat}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.0\PYGZus{}amrex\PYGZus{}real}
      \PYG{k}{end }\PYG{k}{do}
\PYG{k}{   }\PYG{k}{end }\PYG{k}{do}
\PYG{k}{end }\PYG{k}{do}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case, \sphinxcode{\sphinxupquote{is\_device\_ptr}} is used to indicate that \sphinxcode{\sphinxupquote{\DUrole{name}{dat}}}
is available in device memory. For further details about programming
with OpenMP for GPU offloading, consult the OpenMP user’s guide.


\subsection{Kernel launch details}
\label{\detokenize{GPU:kernel-launch-details}}
\sphinxAtStartPar
CUDA kernel calls are asynchronous and they return before the kernel
is finished on the GPU. So the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop finishes iterating on
the CPU and is ready to move on to the next work before the actual
work completes on the GPU.  To guarantee consistency,
there is an implicit device synchronization (a GPU barrier) in
the destructor of \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}.  This ensures that all GPU work
inside of an \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop will complete before code outside of
the loop is executed. Any CUDA kernel launches made outside of an
\sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop must ensure appropriate device synchronization
occurs. This can be done by calling \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{synchronize}\DUrole{punctuation}{()}}}.

\sphinxAtStartPar
CUDA supports multiple streams and kernels. Kernels launched in the
same stream are executed sequentially, but different streams of kernel
launches may be run in parallel.  For each iteration of \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}},
AMReX uses a different CUDA stream (up to 16 streams in total).  This
allows each iteration of an \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop to run independently,
but in the expected sequence, and maximize the use of GPU parallelism.
However, AMReX uses the default CUDA stream outside of \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}}
loops.

\sphinxAtStartPar
Launching kernels with AMReX’s launch macros or functions implement
a C++ lambda function. Lambdas functions used with CUDA have some
restrictions the user must understand.  First, the function enclosing the
extended lambda must not have private or protected access within its parent
class,  otherwise the code will not compile.  This can be fixed by changing
the access of the enclosing function to public.

\sphinxAtStartPar
Another pitfall that must be considered: if the lambda function
accesses a member of the enclosing class, the lambda function actually
captures \sphinxcode{\sphinxupquote{\DUrole{keyword}{this}}} pointer by value and accesses variables and functions
via \sphinxcode{\sphinxupquote{\DUrole{keyword}{this}\DUrole{operator}{\sphinxhyphen{}\textgreater{}}}}.  If the object is not accessible on GPU, the code will
not work as intended.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyClass} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Box} \PYG{n}{bx}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{;}                           \PYG{c+c1}{// Unmanaged integer created on the host.}
    \PYG{k+kt}{void} \PYG{n+nf}{f} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{launch}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}
        \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{tbx}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m = \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Failed attempt to use m on the GPU.}
        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{f}} in the code above will not work unless the \sphinxcode{\sphinxupquote{\DUrole{name}{MyClass}}}
object is in unified memory.  If it is undesirable to put the object into
unified memory, a local copy of the information can be created for the
lambda to capture. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyClass} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
    \PYG{n}{Box} \PYG{n}{bx}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{m}\PYG{p}{;}
    \PYG{k+kt}{void} \PYG{n+nf}{f} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{local\PYGZus{}m} \PYG{o}{=} \PYG{n}{m}\PYG{p}{;}                  \PYG{c+c1}{// Local temporary copy of m.}
        \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{launch}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{,}
        \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{tbx}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m = \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{local\PYGZus{}m}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Lambda captures local\PYGZus{}m by value.}
        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
C++ macros have some important limitations. For example, commas outside
of a set of parentheses are interpreted by the macro, leading to errors such
as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMREX\PYGZus{}PARALLEL\PYGZus{}FOR\PYGZus{}3D} \PYG{p}{(}\PYG{n}{bx}\PYG{p}{,} \PYG{n}{tbx}\PYG{p}{,}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Real} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Error}\PYG{p}{.} \PYG{n}{Macro} \PYG{n}{reads} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZob{} Real a}\PYG{l+s}{\PYGZdq{}} \PYG{n}{as} \PYG{n}{a} \PYG{n}{parameter}
                                             \PYG{n}{and} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b; \PYGZcb{}}\PYG{l+s}{\PYGZdq{}} \PYG{n}{as}
                                             \PYG{n}{another}\PYG{p}{.}
    \PYG{n}{Real} \PYG{n}{a}\PYG{p}{;}      \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{OK}
    \PYG{n}{Real} \PYG{n}{b}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One should also avoid using \sphinxcode{\sphinxupquote{\DUrole{keyword}{continue}}} and \sphinxcode{\sphinxupquote{\DUrole{keyword}{return}}} inside the macros
because it is not an actual \sphinxcode{\sphinxupquote{\DUrole{keyword}{for}}} loop.
Users that choose to implement the macro launches should be aware of the limitations
of C++ preprocessing macros to ensure GPU offloading is done properly.

\sphinxAtStartPar
Finally, AMReX’s most common CPU threading strategy for GPU/CPU systems is to utilize
OpenMP threads to maintain multi\sphinxhyphen{}threaded parallelism on work chosen to run on the host.
This means OpenMP pragmas should be maintained where CPU work is performed and usually
turned off where work is offloaded onto the GPU.  OpenMP pragmas can be turned
off using the conditional pragma and \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{notInLaunchRegion}\DUrole{punctuation}{()}}}, as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel if (Gpu::notInLaunchRegion())}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is generally expected that simply using OpenMP threads to launch GPU work quicker
will show little improvement or even perform worse. So, this conditional statement
should be added to MFIter loops that contain GPU work, unless users specifically test
the performance or are designing more complex workflows that require OpenMP.


\section{An Example of Migrating to GPU}
\label{\detokenize{GPU:an-example-of-migrating-to-gpu}}\label{\detokenize{GPU:sec-gpu-example}}
\sphinxAtStartPar
The nature of GPU programming poses difficulties for a number
of common AMReX patterns, such as the one below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Given MultiFab uin and uout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZob{}}
  \PYG{n}{FArrayBox} \PYG{n}{q}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{uin}\PYG{p}{,}\PYG{n+nb}{true}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{tbx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{gbx} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{grow}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{q}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{gbx}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Do some work with uin[mfi] as input and q as output.}
    \PYG{c+c1}{// The output region is gbx;}
    \PYG{n}{f1}\PYG{p}{(}\PYG{n}{gbx}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{uin}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Then do more work with q as input and uout[mfi] as output.}
    \PYG{c+c1}{// The output region is tbx.}
    \PYG{n}{f2}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,} \PYG{n}{uout}\PYG{p}{[}\PYG{n}{mfi}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are several issues in migrating this code to GPUs that need to
be addressed.  First, functions \sphinxcode{\sphinxupquote{f1}} and \sphinxcode{\sphinxupquote{f2}} have different
work regions (\sphinxcode{\sphinxupquote{tbx}} and \sphinxcode{\sphinxupquote{gbx}}, respectively) and there are data
dependencies between the two (\sphinxcode{\sphinxupquote{q}}). This makes it difficult to put
them into a single GPU kernel, so two separate kernels will be
launched, one for each function.

\sphinxAtStartPar
As we have discussed, AMReX uses multiple CUDA streams for launching
kernels.  Because \sphinxcode{\sphinxupquote{q}} is used inside \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops, multiple
GPU kernels on different streams are accessing its data.  This creates
a race condition.  One way to fix this is to move \sphinxcode{\sphinxupquote{FArrayBox q}}
inside the loop to make it local to each loop and use \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}} to
make it async\sphinxhyphen{}safe (see Section {\hyperref[\detokenize{GPU:sec-gpu-classes-elixir}]{\sphinxcrossref{\DUrole{std,std-ref}{Elixir}}}}).  This
strategy works well for GPU.  However it is not optimal for OpenMP CPU
threads when CUDA is not used, because of the memory allocation inside
OpenMP parallel region.  It turns out it is actually unnecessary to
make \sphinxcode{\sphinxupquote{FArrayBox q}} local to each iteration when \sphinxcode{\sphinxupquote{\DUrole{name}{Elixir}}} is
used to extend the life of its floating point data.  The code below
shows an example of how to rewrite the example in a performance
portable way.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Given MultiFab uin and uout}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef AMREX\PYGZus{}USE\PYGZus{}OMP}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{pragma omp parallel if (Gpu::notInLaunchRegion())}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZob{}}
  \PYG{n}{FArrayBox} \PYG{n}{q}\PYG{p}{;}
  \PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{uin}\PYG{p}{,}\PYG{n}{TilingIfNotGPU}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
  \PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{tbx} \PYG{o}{=} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{tilebox}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{const} \PYG{n}{Box}\PYG{o}{\PYGZam{}} \PYG{n}{gbx} \PYG{o}{=} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{grow}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{q}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{gbx}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Elixir} \PYG{n}{eli} \PYG{o}{=} \PYG{n}{q}\PYG{p}{.}\PYG{n}{elixir}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{qarr} \PYG{o}{=} \PYG{n}{q}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real} \PYG{k}{const}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{uinarr} \PYG{o}{=} \PYG{n}{uin}\PYG{p}{.}\PYG{n}{const\PYGZus{}array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Array4}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{uoutarr} \PYG{o}{=} \PYG{n}{uout}\PYG{p}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{mfi}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{launch}\PYG{p}{(}\PYG{n}{gbx}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{f1}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{qarr}\PYG{p}{,} \PYG{n}{uinarr}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{launch}\PYG{p}{(}\PYG{n}{tbx}\PYG{p}{,}
    \PYG{p}{[}\PYG{o}{=}\PYG{p}{]} \PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE} \PYG{p}{(}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
      \PYG{n}{f2}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{uoutarr}\PYG{p}{,} \PYG{n}{qarr}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Assertions, Error Checking and Synchronization}
\label{\detokenize{GPU:assertions-error-checking-and-synchronization}}\label{\detokenize{GPU:sec-gpu-assertion}}
\sphinxAtStartPar
To help debugging, we often use \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Assert}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Abort}}}.  These functions are GPU safe and can be used in
GPU kernels.  However, implementing these functions requires additional
GPU registers, which will reduce overall performance.  Therefore, it
is preferred to implement such calls in debug mode only by wrapping the
calls using \sphinxcode{\sphinxupquote{\#ifdef AMREX\_DEBUG}}.

\sphinxAtStartPar
In CPU code, \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_GPU\_ERROR\_CHECK}\DUrole{punctuation}{()}}} can be called
to check the health of previous GPU launches.  This call
looks up the return message from the most recently completed GPU
launch and aborts if it was not successful. Many kernel
launch macros as well as the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} destructor include a call
to \sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_GPU\_ERROR\_CHECK}\DUrole{punctuation}{()}}}. This prevents additional launches
from being called if a previous launch caused an error and ensures
all GPU launches within an \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop completed successfully
before continuing work.

\sphinxAtStartPar
However, due to asynchronicity, determining the source of the error
can be difficult.  Even if GPU kernels launched earlier in the code
result in a CUDA error, the error may not be output at a nearby call to
\sphinxcode{\sphinxupquote{\DUrole{name}{AMREX\_GPU\_ERROR\_CHECK}\DUrole{punctuation}{()}}} by the CPU.  When tracking down a CUDA
launch error, \sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{synchronize}\DUrole{punctuation}{()}}} and
\sphinxcode{\sphinxupquote{\DUrole{name}{Gpu}\DUrole{operator}{::}\DUrole{name}{streamSynchronize}\DUrole{punctuation}{()}}} can be used to synchronize
the device or the CUDA stream, respectively, and track down the specific
launch that causes the error.


\section{Particle Support}
\label{\detokenize{GPU:particle-support}}\phantomsection\label{\detokenize{GPU:sec-gpu-particle}}
\sphinxAtStartPar
As with \sphinxcode{\sphinxupquote{MultiFab}}, particle data stored in AMReX \sphinxcode{\sphinxupquote{ParticleContainer}} classes are
stored in unified memory when AMReX is compiled with \sphinxcode{\sphinxupquote{USE\_CUDA=TRUE}}. This means that the \sphinxcode{\sphinxupquote{\DUrole{name}{dataPtr}}} associated with particles
is managed and can be passed into GPU kernels. These kernels can be launched with a variety of approaches,
including Cuda C / Fortran and OpenACC. An example Fortran particle subroutine offloaded via OpenACC might
look like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{subroutine }\PYG{n}{push\PYGZus{}position\PYGZus{}boris}\PYG{p}{(}\PYG{n}{np}\PYG{p}{,} \PYG{n}{structs}\PYG{p}{,} \PYG{n}{uxp}\PYG{p}{,} \PYG{n}{uyp}\PYG{p}{,} \PYG{n}{uzp}\PYG{p}{,} \PYG{n}{gaminv}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}

\PYG{k}{use }\PYG{n}{em\PYGZus{}particle\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{particle\PYGZus{}t}
\PYG{k}{use }\PYG{n}{amrex\PYGZus{}fort\PYGZus{}module}\PYG{p}{,} \PYG{k}{only} \PYG{p}{:} \PYG{n}{amrex\PYGZus{}real}
\PYG{k}{implicit }\PYG{k}{none}

\PYG{k+kt}{integer}\PYG{p}{,}          \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value}  \PYG{k+kd}{::} \PYG{n}{np}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{particle\PYGZus{}t}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{inout}\PYG{p}{)}      \PYG{k+kd}{::} \PYG{n}{structs}\PYG{p}{(}\PYG{n}{np}\PYG{p}{)}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}         \PYG{k+kd}{::} \PYG{n}{uxp}\PYG{p}{(}\PYG{n}{np}\PYG{p}{)}\PYG{p}{,} \PYG{n}{uyp}\PYG{p}{(}\PYG{n}{np}\PYG{p}{)}\PYG{p}{,} \PYG{n}{uzp}\PYG{p}{(}\PYG{n}{np}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gaminv}\PYG{p}{(}\PYG{n}{np}\PYG{p}{)}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{amrex\PYGZus{}real}\PYG{p}{)}\PYG{p}{,} \PYG{k}{intent}\PYG{p}{(}\PYG{n}{in}\PYG{p}{)}\PYG{p}{,} \PYG{k}{value}  \PYG{k+kd}{::} \PYG{n}{dt}

\PYG{k+kt}{integer}                              \PYG{k+kd}{::} \PYG{n}{ip}

\PYG{c}{!\PYGZdl{}acc parallel deviceptr(structs, uxp, uyp, uzp, gaminv)}
\PYG{c}{!\PYGZdl{}acc loop gang vector}
\PYG{k}{do }\PYG{n}{ip} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{np}
    \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{uxp}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{gaminv}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}
    \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{uyp}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{gaminv}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}
    \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{n}{structs}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{p}{\PYGZpc{}}\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{uzp}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{gaminv}\PYG{p}{(}\PYG{n}{ip}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}
\PYG{k}{end }\PYG{k}{do}
\PYG{c}{!\PYGZdl{}acc end loop}
\PYG{c}{!\PYGZdl{}acc end parallel}

\PYG{k}{end }\PYG{k}{subroutine }\PYG{n}{push\PYGZus{}position\PYGZus{}boris}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the use of the \sphinxcode{\sphinxupquote{\DUrole{comment}{!\$acc parallel deviceptr}}} clause to specify which data has been placed
in managed memory. This instructs OpenACC to treat those variables as if they already live on
the device, bypassing the usual copies. For complete examples of a particle code that has been ported
to GPUs using Cuda, OpenACC, and OpenMP, please see the tutorial \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Particles\_Tutorial.html\#electromagneticpic}{Electromagnetic PIC}.

\sphinxAtStartPar
GPU\sphinxhyphen{}aware implementations of many common particle operations are provided with AMReX, including neighbor list
construction and traversal, particle\sphinxhyphen{}mesh deposition and interpolation, parallel reductions of particle data,
and a set of transformation and filtering operations that are useful when operating on sets of particles. For
examples of these features in use, please see \sphinxcode{\sphinxupquote{\DUrole{name}{Tests}\DUrole{operator}{/}\DUrole{name}{Particles}\DUrole{operator}{/}}}.

\sphinxAtStartPar
Finally, the parallel communication of particle data has been ported and optimized for performance on GPU
platforms. This includes \sphinxcode{\sphinxupquote{\DUrole{name}{Redistribute}\DUrole{punctuation}{()}}}, which moves particles back to the proper grids after their positions
have changed, as well as \sphinxcode{\sphinxupquote{\DUrole{name}{fillNeighbors}\DUrole{punctuation}{()}}} and \sphinxcode{\sphinxupquote{\DUrole{name}{updateNeighbors}\DUrole{punctuation}{()}}}, which are used to exchange halo particles.
As with \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} data, these have been designed to minimize host / device traffic as much as possible, and can
take advantage of the Cuda\sphinxhyphen{}aware MPI implementations available on platforms such as ORNL’s Summit.


\section{Profiling with GPUs}
\label{\detokenize{GPU:profiling-with-gpus}}\phantomsection\label{\detokenize{GPU:sec-gpu-profiling}}
\sphinxAtStartPar
When profiling for GPUs, AMReX recommends \sphinxcode{\sphinxupquote{nvprof}}, NVIDIA’s visual
profiler.  \sphinxcode{\sphinxupquote{nvprof}} returns data on how long each kernel launch lasted on
the GPU, the number of threads and registers used, the occupancy of the GPU
and recommendations for improving the code.  For more information on how to
use \sphinxcode{\sphinxupquote{nvprof}}, see NVIDIA’s User’s Guide as well as the help web pages of
your favorite supercomputing facility that uses NVIDIA GPUs.

\sphinxAtStartPar
AMReX’s internal profilers currently cannot hook into profiling information
on the GPU and an efficient way to time and retrieve that information is
being explored. In the meantime, AMReX’s timers can be used to report some
generic timers that are useful in categorizing an application.

\sphinxAtStartPar
Due to the asynchronous launching of GPU kernels, any AMReX timers inside of
asynchronous regions or inside GPU kernels will not measure useful
information.  However, since the \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} synchronizes when being
destroyed, any timer wrapped around an \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loop will yield a
consistent timing of the entire set of GPU launches contained within. For
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A\PYGZus{}NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{blp}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Profiling start}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{MFIter} \PYG{n}{mfi}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mfi}\PYG{p}{.}\PYG{n}{isValid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{mfi}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// gpu works}
\PYG{p}{\PYGZcb{}}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{blp}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// Profiling stop}
\end{sphinxVerbatim}

\sphinxAtStartPar
For now, this is the best way to profile GPU codes using \sphinxcode{\sphinxupquote{TinyProfiler}}.
If you require further profiling detail, use \sphinxcode{\sphinxupquote{nvprof}}.


\section{Performance Tips}
\label{\detokenize{GPU:performance-tips}}\phantomsection\label{\detokenize{GPU:sec-gpu-performance}}
\sphinxAtStartPar
Here are some helpful performance tips to keep in mind when working with
AMReX for GPUs:
\begin{itemize}
\item {} 
\sphinxAtStartPar
To obtain the best performance when using CUDA kernel launches, all
device functions called within the launch region should be inlined.
Inlined functions use substantially fewer registers, freeing up GPU
resources to perform other tasks. This increases parallel
performance and greatly reduces runtime.  Functions are written
inline by putting their definitions in the \sphinxcode{\sphinxupquote{.H}} file and using
the \sphinxcode{\sphinxupquote{AMREX\_FORCE\_INLINE}} AMReX macro.  Examples can be found in
in the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/GPU\_Tutorial.html\#launch}{Launch} tutorial. For example:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMREX\PYGZus{}GPU\PYGZus{}DEVICE}
\PYG{n}{AMREX\PYGZus{}FORCE\PYGZus{}INLINE}
\PYG{k+kt}{void} \PYG{n}{plusone\PYGZus{}cudacpp} \PYG{p}{(}\PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Box} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FArrayBox}\PYG{o}{\PYGZam{}} \PYG{n}{fab}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pay attention to what GPUs your job scheduler is assigning to each MPI
rank. In most cases you’ll achieve the best performance when a single
MPI rank is assigned to each GPU, and has boxes large enough to saturate
that GPU’s compute capacity. While there are some cases where multiple
MPI ranks per GPU can make sense (typically this would be when you have
some portion of your code that is not GPU accelerated and want to have
many MPI ranks to make that part faster), this is probably the minority
of cases. For example, on OLCF Summit you would want to ensure that your
resource sets contain one MPI rank and GPU each, using \sphinxtitleref{jsrun \sphinxhyphen{}n N \sphinxhyphen{}a 1 \sphinxhyphen{}c 7 \sphinxhyphen{}g 1},
where \sphinxtitleref{N} is the total number of MPI ranks/GPUs you want to use. (See the OLCF
{[}job step viewer{]}(\sphinxurl{https://jobstepviewer.olcf.ornl.gov/}) for more information.)

\sphinxAtStartPar
Conversely, if you choose to have multiple GPUs visible to each MPI rank,
AMReX will attempt to do the best job it can assigning MPI ranks to GPUs by
doing round robin assignment. This may be suboptimal because this assignment
scheme would not be aware of locality benefits that come from having an MPI
rank be on the same socket as the GPU it is managing. If you know the hardware
layout of the system you’re running on, specifically the number of GPUs per
socket (\sphinxtitleref{M}) and number of GPUs per node (\sphinxtitleref{N}), you can set the preprocessor
defines \sphinxtitleref{\sphinxhyphen{}DAMREX\_GPUS\_PER\_SOCKET=M} and \sphinxtitleref{\sphinxhyphen{}DAMREX\_GPUS\_PER\_NODE=N}, which are
exposed in the GNU Make system through the variables \sphinxtitleref{GPUS\_PER\_SOCKET} and
\sphinxtitleref{GPUS\_PER\_NODE} respectively (see an example in \sphinxtitleref{Tools/GNUMake/sites/Make.olcf}).
Then AMReX can ensure that each MPI rank selects a GPU on the same socket as
that rank (assuming your MPI implementation supports MPI 3.)

\end{itemize}


\section{Inputs Parameters}
\label{\detokenize{GPU:inputs-parameters}}\phantomsection\label{\detokenize{GPU:sec-gpu-parameters}}
\sphinxAtStartPar
The following inputs parameters control the behavior of amrex when running on GPUs. They should be prefaced
by “amrex” in your \sphinxcode{\sphinxupquote{\DUrole{name}{inputs}}} file.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
use\_gpu\_aware\_mpi
&
\sphinxAtStartPar
Whether to use GPU memory for communication buffers during MPI calls.
If true, the buffers will use device memory. If false, they will use
pinned memory. In practice, we find it is usually not worth it to use
GPU aware MPI.
&
\sphinxAtStartPar
Bool
&
\sphinxAtStartPar
False
\\
\hline
\sphinxAtStartPar
abort\_on\_out\_of\_gpu\_memory
&
\sphinxAtStartPar
If the size of free memory on the GPU is less than the size of a
requested allocation, AMReX will call AMReX::Abort() with an error
describing how much free memory there is and what was requested.
&
\sphinxAtStartPar
Bool
&
\sphinxAtStartPar
False
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Basic Gpu Debugging}
\label{\detokenize{GPU:basic-gpu-debugging}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Turn off GPU offloading for some part of the code with

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Gpu}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setLaunchRegion}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;}
\PYG{n}{Gpu}\PYG{o}{:}\PYG{o}{:}\PYG{n}{setLaunchRegion}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that functions, \sphinxcode{\sphinxupquote{amrex::launch}} and \sphinxcode{\sphinxupquote{amrex::ParallelFor}}, do
not respect the launch region flag.  Only the macros (e.g.,
\sphinxcode{\sphinxupquote{AMREX\_LAUNCH\_HOST\_DEVICE\_LAMBDA}} and \sphinxcode{\sphinxupquote{AMREX\_HOST\_DEVICE\_FOR\_*D}}) do.


\subsection{Cuda\sphinxhyphen{}specific tests}
\label{\detokenize{GPU:cuda-specific-tests}}\begin{itemize}
\item {} 
\sphinxAtStartPar
To test if your kernels have launched, run

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nvprof} \PYG{p}{.}\PYG{o}{/}\PYG{n}{main3d}\PYG{p}{.}\PYG{n}{xxx}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Run under \sphinxcode{\sphinxupquote{nvprof \sphinxhyphen{}o profile\%p.nvvp ./main3d.xxxx}} for
a small problem and examine page faults using nvvp

\item {} 
\sphinxAtStartPar
Run under \sphinxcode{\sphinxupquote{cuda\sphinxhyphen{}memcheck}}

\item {} 
\sphinxAtStartPar
Run under \sphinxcode{\sphinxupquote{cuda\sphinxhyphen{}gdb}}

\item {} 
\sphinxAtStartPar
Run with \sphinxcode{\sphinxupquote{CUDA\_LAUNCH\_BLOCKING=1}}.  This means that only one
kernel will run at a time.  This can help identify if there are race
conditions.

\end{itemize}


\chapter{Visualization}
\label{\detokenize{Visualization_Chapter:visualization}}\label{\detokenize{Visualization_Chapter:chap-visualization}}\label{\detokenize{Visualization_Chapter::doc}}
\sphinxAtStartPar
There are several visualization tools that can be used for AMReX plotfiles. The
standard tool used within the AMReX\sphinxhyphen{}community is Amrvis, a package developed
and supported by CCSE that is designed specifically for highly efficient
visualization of block\sphinxhyphen{}structured hierarchical AMR data. Plotfiles can also be
viewed using the VisIt, ParaView, and yt packages. Particle data can be viewed
using ParaView.


\section{Amrvis}
\label{\detokenize{Visualization:amrvis}}\label{\detokenize{Visualization:sec-amrvis}}\label{\detokenize{Visualization::doc}}
\sphinxAtStartPar
Our favorite visualization tool is Amrvis. We heartily encourage you to build
the \sphinxcode{\sphinxupquote{amrvis1d}}, \sphinxcode{\sphinxupquote{amrvis2d}}, and \sphinxcode{\sphinxupquote{amrvis3d}} executables, and to try using
them to visualize your data. A very useful feature is View/Dataset, which
allows you to actually view the numbers in a spreadsheet that is nested to
reflect the AMR hierarchy \textendash{} this can be handy for debugging. You can modify how
many levels of data you want to see, whether you want to see the grid boxes or
not, what palette you use, etc. Below are some instructions and tips for using
Amrvis; you can find additional information in Amrvis/Docs/Amrvis.tex (which
you can build into a pdf using pdflatex).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Download and build :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{git clone https://github.com/AMReX\PYGZhy{}Codes/Amrvis}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then cd into Amrvis/, edit the GNUmakefile by setting \sphinxcode{\sphinxupquote{COMP}} to the
compiler suite you have.

\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{make DIM=1}}, \sphinxcode{\sphinxupquote{make DIM=2}}, or \sphinxcode{\sphinxupquote{make DIM=3}} to build, resulting
in an executable that looks like amrvis2d…ex.

\sphinxAtStartPar
If you want to build amrvis with \sphinxcode{\sphinxupquote{DIM=3}}, you must first download and build
\sphinxcode{\sphinxupquote{volpack}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{git clone https://ccse.lbl.gov/pub/Downloads/volpack.git}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then cd into volpack/ and type \sphinxcode{\sphinxupquote{make}}.

\sphinxAtStartPar
Note: Amrvis requires the OSF/Motif libraries and headers. If you don’t have
these you will need to install the development version of motif through your
package manager.  \sphinxcode{\sphinxupquote{lesstif}} gives some functionality and will allow you to
build the amrvis executable, but Amrvis may exhibit subtle anomalies.

\sphinxAtStartPar
On most Linux distributions, the motif library is provided by the
\sphinxcode{\sphinxupquote{openmotif}} package, and its header files (like Xm.h) are provided by
\sphinxcode{\sphinxupquote{openmotif\sphinxhyphen{}devel}}. If those packages are not installed, then use the
OS\sphinxhyphen{}specific package management tool to install them.

\sphinxAtStartPar
You may then want to create an alias to amrvis2d, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{alias amrvis2d /tmp/Amrvis/amrvis2d...ex}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Run the command \sphinxcode{\sphinxupquote{cp Amrvis/amrvis.defaults \textasciitilde{}/.amrvis.defaults}}.  Then, in
your copy, edit the line containing “palette” line to point to, e.g.,
“palette /home/username/Amrvis/Palette”. The other lines control options
such as the initial field to display, the number format, widow size, etc.
If there are multiple instances of the same option, the last option takes
precedence.

\item {} 
\sphinxAtStartPar
Generally the plotfiles have the form pltXXXXX (the plt prefix can be
changed), where XXXXX is a number corresponding to the timestep the file was
output. \sphinxcode{\sphinxupquote{amrvis2d \textless{}filename\textgreater{}}} or \sphinxcode{\sphinxupquote{amrvis3d \textless{}filename\textgreater{}}} to see a single
plotfile, or for 2D data sets, \sphinxcode{\sphinxupquote{amrvis2d \sphinxhyphen{}a plt*}}, which will animate the
sequence of plotfiles. FArrayBoxes and MultiFabs can also be viewed with the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}fab}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}mf}} options. When opening MultiFabs, use the name of the
MultiFab’s header file \sphinxcode{\sphinxupquote{amrvis2d \sphinxhyphen{}mf MyMultiFab\_H}}.

\sphinxAtStartPar
You can use the “Variable” menu to change the variable.
You can left\sphinxhyphen{}click drag a box around a region and click “View”
\(\rightarrow\) “Dataset” in order to look at the actual numerical
values (see \hyperref[\detokenize{Visualization:fig-amrvis}]{Table \ref{\detokenize{Visualization:fig-amrvis}}}).  Or you can simply left
click on a point to obtain the numerical value.  You can also export the
pictures in several different formats under “File/Export”.  In 2D you can
right and center click to get line\sphinxhyphen{}out plots.  In 3D you can right and
center click to change the planes, and the hold shift+(right or center)
click to get line\sphinxhyphen{}out plots.

\sphinxAtStartPar
We have created a number of routines to convert AMReX plotfile data other
formats (such as matlab), but in order to properly interpret the
hierarchical AMR data, each tends to have its own idiosyncrasies. If you
would like to display the data in another format, please contact Marc Day
(\sphinxhref{mailto:MSDay@lbl.gov}{MSDay@lbl.gov}) and we will point you to whatever we have that can help.

\end{enumerate}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{2D and 3D images generated using Amrvis}\label{\detokenize{Visualization:id3}}\label{\detokenize{Visualization:fig-amrvis}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Amrvis_2d}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{Amrvis_3d}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Building Amrvis on macOS}
\label{\detokenize{Visualization:building-amrvis-on-macos}}
\sphinxAtStartPar
As previously outlined at the end of section {\hyperref[\detokenize{BuildingAMReX:sec-build-make}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with GNU Make}}}}, it is
recommended to build using the \sphinxhref{https://brew.sh}{homebrew} package manager to
install gcc. Furthermore, you will also need x11 and openmotif. These can be
installed using homebrew also:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{brew cask install xquartz}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{brew install openmotif}}

\end{enumerate}

\sphinxAtStartPar
Note that when the \sphinxcode{\sphinxupquote{GNUmakefile}} detects a macOS install, it assumes that
dependencies are installed in the locations that Homebrew uses. Namely the
\sphinxcode{\sphinxupquote{/usr/local/}} tree for regular dependencies and the \sphinxcode{\sphinxupquote{/opt/}} tree for X11.


\section{VisIt}
\label{\detokenize{Visualization:visit}}\label{\detokenize{Visualization:sec-visit}}
\sphinxAtStartPar
AMReX data can also be visualized by VisIt, an open source visualization and
analysis software. To follow along with this example, first build and run the
first heat equation tutorial code (see the section on {\hyperref[\detokenize{GettingStarted:sec-heat-equation}]{\sphinxcrossref{\DUrole{std,std-ref}{Example: Heat Equation Solver}}}}).

\sphinxAtStartPar
Next, download and install VisIt from
\sphinxurl{https://wci.llnl.gov/simulation/computer-codes/visit}.  To open a single
plotfile, run VisIt, then select “File” \(\rightarrow\) “Open file …”,
then select the Header file associated the the plotfile of interest (e.g.,
plt00000/Header).  Assuming you ran the simulation in 2D, here are instructions
for making a simple plot:
\begin{itemize}
\item {} 
\sphinxAtStartPar
To view the data, select “Add” \(\rightarrow\) “Pseudocolor”
\(\rightarrow\) “phi”, and then select “Draw”.

\item {} 
\sphinxAtStartPar
To view the grid structure (not particularly interesting yet, but when we
add AMR it will be), select “Add” \(\rightarrow\) “Subset”
\(\rightarrow\) “levels”. Then double\sphinxhyphen{}click the text “Subset \sphinxhyphen{} levels”,
enable the “Wireframe” option, select “Apply”, select “Dismiss”, and then
select “Draw”.

\item {} 
\sphinxAtStartPar
To save the image, select “File” \(\rightarrow\) “Set save options”,
then customize the image format to your liking, then click “Save”.

\end{itemize}

\sphinxAtStartPar
Your image should look similar to the left side of \hyperref[\detokenize{Visualization:fig-visit}]{Table \ref{\detokenize{Visualization:fig-visit}}}.

\begin{center}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{: 2D (left) and 3D (right) images generated using VisIt.}\label{\detokenize{Visualization:id4}}\label{\detokenize{Visualization:fig-visit}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{VisIt_2D}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{VisIt_3D}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{center}

\sphinxAtStartPar
In 3D, you must apply the “Operators” \(\rightarrow\) “Slicing”
\(\rightarrow\) “ThreeSlice”, with the “ThreeSlice operator attribute” set
to \sphinxcode{\sphinxupquote{x=0.25}}, \sphinxcode{\sphinxupquote{y=0.25}}, and \sphinxcode{\sphinxupquote{z=0.25}}. You can left\sphinxhyphen{}click and drag over the
image to rotate the image to generate something similar to right side of
\hyperref[\detokenize{Visualization:fig-visit}]{Table \ref{\detokenize{Visualization:fig-visit}}}.

\sphinxAtStartPar
To make a movie, you must first create a text file named \sphinxcode{\sphinxupquote{movie.visit}} with a
list of the Header files for the individual frames. This can most easily be
done using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZti{}/amrex/Tutorials/Basic/HeatEquation\PYGZus{}EX1\PYGZus{}C\PYGZgt{} ls \PYGZhy{}1 plt*/Header | tee movie.visit}
\PYG{g+go}{plt00000/Header}
\PYG{g+go}{plt01000/Header}
\PYG{g+go}{plt02000/Header}
\PYG{g+go}{plt03000/Header}
\PYG{g+go}{plt04000/Header}
\PYG{g+go}{plt05000/Header}
\PYG{g+go}{plt06000/Header}
\PYG{g+go}{plt07000/Header}
\PYG{g+go}{plt08000/Header}
\PYG{g+go}{plt09000/Header}
\PYG{g+go}{plt10000/Header}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next step is to run VisIt, select “File” \(\rightarrow\) “Open file…”,
then select movie.visit. Create an image to your liking and press the
“play”  button on the VCR\sphinxhyphen{}like control panel to preview all the frames. To save
the movie, choose “File” \(\rightarrow\) “Save movie …”, and follow the
on\sphinxhyphen{}screen instructions.

\sphinxAtStartPar
Caveat:

\sphinxAtStartPar
The Visit reader determines “Cycle” from the name of the plotfile (directory),
specifically from the integer that follows the string “plt” in the plotfile name.

\sphinxAtStartPar
So … if you call it plt00100 or myplt00100 or this\_is\_my\_plt00100 then it will
correctly recognize and print Cycle: 100.

\sphinxAtStartPar
If you call it plt00100\_old it will also correctly recognize and print Cycle: 100

\sphinxAtStartPar
But, if you do not have “plt” followed immediately by the number,
e.g. you name it pltx00100, then VisIt will not be able to correctly recognize
and print the value for “Cycle”.  (It will still read and display the data itself.)


\section{ParaView}
\label{\detokenize{Visualization:paraview}}\label{\detokenize{Visualization:section-1}}
\sphinxAtStartPar
The open source visualization package ParaView v5.7 and later can be used to view 2D and 3D
plotfiles, as well as particles data. Download the package at
\sphinxurl{https://www.paraview.org/}.

\sphinxAtStartPar
To open a plotfile (for example, you could run the
\sphinxcode{\sphinxupquote{HeatEquation\_EX1\_C}} in 3D):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Run ParaView v5.7, then select “File” \(\rightarrow\) “Open”.

\item {} 
\sphinxAtStartPar
Navigate to your run directory, and select the fluid or particle plotfile.
Note that you can either open single/multiple plotfile(s) at once by selecting
them one by one or select an ensemble of file, labelled as \sphinxcode{\sphinxupquote{plt..}} and indicated
as a Group in the “Type” column of the file explorer (see \hyperref[\detokenize{Visualization:fig-paraview-filegroup}]{Fig.\@ \ref{\detokenize{Visualization:fig-paraview-filegroup}}}).
In the later case, Paraview will load the plotfiles as a time series.
ParaView will ask you about the file type \textendash{} choose “AMReX/BoxLib Grid Reader” or
“AMReX/BoxLib Particles Reader”.

\item {} 
\sphinxAtStartPar
Under the “Cell Arrays” field, select a variable (e.g., “phi”) and click
“Apply”. Note that the default number of refinement levels loaded and visualized is 1.
Change to the required number of AMR level before clicking “Apply”.

\item {} 
\sphinxAtStartPar
Under “Representation” select “Surface”.

\item {} 
\sphinxAtStartPar
Under “Coloring” select the variable you chose above.

\item {} 
\sphinxAtStartPar
To add planes, near the top left you will see a cube icon with a green plane
slicing through it. If you hover your mouse over it, it will say “Slice”.
Click that button.

\item {} 
\sphinxAtStartPar
You can play with the Plane Parameters to define a plane of data to view, as
shown in \hyperref[\detokenize{Visualization:fig-paraview}]{Fig.\@ \ref{\detokenize{Visualization:fig-paraview}}}.

\end{enumerate}

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.1in]{{ParaView}.png}
\caption{: Plotfile image generated with ParaView}\label{\detokenize{Visualization:id5}}\label{\detokenize{Visualization:fig-paraview}}\end{figure}

\end{center}

\sphinxAtStartPar
Note that Paraview is not able to generate iso\sphinxhyphen{}surfaces from cell centered data. To build an iso\sphinxhyphen{}surface (or iso\sphinxhyphen{}line in 2D):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Perform a cell to node interpolation: “Filters” \(\rightarrow\) “Alphabetical” \(\rightarrow\) “Cell Data to Point Data”.

\item {} 
\sphinxAtStartPar
Use the “Contour” icon (next to the calculator) to select the data from which to build the contour (“Contour by”), enters the iso\sphinxhyphen{}surfaces
values and click “Apply”.

\end{enumerate}

\sphinxAtStartPar
To visualize particle data within plofile directories (for example, you could
run the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Particles\_Tutorial.html\#neighborlist}{NeighborList} example in \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/Particles\_Tutorial.html}{Tutorials/Particles}):

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.1in]{{ParaView_filegroup}.png}
\caption{: File dialog in ParaView showing a group of plotfile directories selected}\label{\detokenize{Visualization:id6}}\label{\detokenize{Visualization:fig-paraview-filegroup}}\end{figure}

\end{center}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Run ParaView v5.7, and select  then  “File” \(\rightarrow\) “Open”. You
will see a combined “plt..” group. Click on “+” to expand the group, if you
want inspect the files in the group. You can select an individual plotfile
directory or select a group of directories to read them a time series, as
shown in \hyperref[\detokenize{Visualization:fig-paraview-filegroup}]{Fig.\@ \ref{\detokenize{Visualization:fig-paraview-filegroup}}}, and click OK. ParaView will ask you about the file type \textendash{} choose “AMReX/BoxLib Particles Reader”.

\item {} 
\sphinxAtStartPar
The “Properties” panel in ParaView allows you to specify the “Particle
Type”, which defaults to “particles”. Using the “Properties” panel, you can
also choose which point arrays to read.

\item {} 
\sphinxAtStartPar
Click “Apply” and under “Representation” select “Point Gaussian”.

\item {} 
\sphinxAtStartPar
Change the Gaussian Radius if you like. You can scroll through the frames
with the VCR\sphinxhyphen{}like controls at the top, as shown in
\hyperref[\detokenize{Visualization:fig-paraview-particles}]{Fig.\@ \ref{\detokenize{Visualization:fig-paraview-particles}}}.

\end{enumerate}

\begin{center}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=3.1in]{{ParaView_particles}.png}
\caption{: Particle image generated with ParaView}\label{\detokenize{Visualization:id7}}\label{\detokenize{Visualization:fig-paraview-particles}}\end{figure}

\end{center}

\sphinxAtStartPar
Following these instructions, you can open fluid and/or particles plotfiles and visualize them together on the same Panel View.

\sphinxAtStartPar
Once you have loaded an AMReX plotfile time series (fluid and/or particles), you can generate a movie following these instructions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
“File” \(\rightarrow\) “Save Animation…”.

\item {} 
\sphinxAtStartPar
Enter a file name, select “.avi” as the Type of File and click “OK”.

\item {} 
\sphinxAtStartPar
Adjust the resolution, compression and framerate, and click “OK”

\end{enumerate}


\section{yt}
\label{\detokenize{Visualization:yt}}\label{\detokenize{Visualization:section-2}}
\sphinxAtStartPar
yt, an open source Python package available at \sphinxurl{http://yt-project.org/}, can be
used for analyzing and visualizing mesh and particle data generated by
AMReX codes. Some of the AMReX developers are also yt project members.  Below
we describe how to use on both a local workstation, as well as at the NERSC
HPC facility for high\sphinxhyphen{}throughput visualization of large data sets.

\sphinxAtStartPar
Note \sphinxhyphen{} AMReX datasets require yt version 3.4 or greater.


\subsection{Using on a local workstation}
\label{\detokenize{Visualization:using-on-a-local-workstation}}
\sphinxAtStartPar
Running yt on a local system generally provides good interactivity, but limited
performance. Consequently, this configuration is best when doing exploratory
visualization (e.g., experimenting with camera angles, lighting, and color
schemes) of small data sets.

\sphinxAtStartPar
To use yt on an AMReX plot file, first start a Jupyter notebook or an IPython
kernel, and import the \sphinxcode{\sphinxupquote{yt}} module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} \PYG{k+kn}{import} \PYG{n+nn}{yt}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{:} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{yt}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}version\PYGZus{}\PYGZus{}}\PYG{p}{)}
\PYG{l+m+mf}{3.4}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, load a plot file; in this example we use a plot file from the Nyx
cosmology application:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:} \PYG{n}{ds} \PYG{o}{=} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{plt00401}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{03}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{182} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{current\PYGZus{}time}              \PYG{o}{=} \PYG{l+m+mf}{0.00605694344696544}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{03}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{182} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}dimensions}         \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128}\PYG{p}{]}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{03}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{182} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}left\PYGZus{}edge}          \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{03}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{183} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}right\PYGZus{}edge}         \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{14.24501}  \PYG{l+m+mf}{14.24501}  \PYG{l+m+mf}{14.24501}\PYG{p}{]}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{:} \PYG{n}{ds}\PYG{o}{.}\PYG{n}{field\PYGZus{}list}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{:}
\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DM}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}position\PYGZus{}z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}velocity\PYGZus{}z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boxlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{density}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boxlib}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{particle\PYGZus{}mass\PYGZus{}density}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
From here one can make slice plots, 3\sphinxhyphen{}D volume renderings, etc. An example of
the slice plot feature is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{:} \PYG{n}{slc} \PYG{o}{=} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{SlicePlot}\PYG{p}{(}\PYG{n}{ds}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{density}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{358} \PYG{n}{xlim} \PYG{o}{=} \PYG{l+m+mf}{0.000000} \PYG{l+m+mf}{14.245010}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{358} \PYG{n}{ylim} \PYG{o}{=} \PYG{l+m+mf}{0.000000} \PYG{l+m+mf}{14.245010}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{359} \PYG{n}{xlim} \PYG{o}{=} \PYG{l+m+mf}{0.000000} \PYG{l+m+mf}{14.245010}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{359} \PYG{n}{ylim} \PYG{o}{=} \PYG{l+m+mf}{0.000000} \PYG{l+m+mf}{14.245010}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{:} \PYG{n}{slc}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{:} \PYG{n}{slc}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{021} \PYG{n}{Saving} \PYG{n}{plot} \PYG{n}{plt00401\PYGZus{}Slice\PYGZus{}z\PYGZus{}density}\PYG{o}{.}\PYG{n}{png}
\PYG{n}{Out}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{]}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plt00401\PYGZus{}Slice\PYGZus{}z\PYGZus{}density.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The resulting image is \hyperref[\detokenize{Visualization:fig-yt-nyx-slice-plot}]{Fig.\@ \ref{\detokenize{Visualization:fig-yt-nyx-slice-plot}}}. One can also make
volume renderings with ; an example is show below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{yt_Nyx_density_slice}.png}
\caption{: Slice plot of \(128^3\) Nyx simulation using yt.}\label{\detokenize{Visualization:id8}}\label{\detokenize{Visualization:fig-yt-nyx-slice-plot}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{:} \PYG{n}{sc} \PYG{o}{=} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{create\PYGZus{}scene}\PYG{p}{(}\PYG{n}{ds}\PYG{p}{,} \PYG{n}{field}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{density}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lens\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{perspective}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{:} \PYG{n}{source} \PYG{o}{=} \PYG{n}{sc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{:} \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{set\PYGZus{}bounds}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1e8}\PYG{p}{,} \PYG{l+m+mf}{1e15}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{:} \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{set\PYGZus{}log}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{:} \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{grey\PYGZus{}opacity} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{:} \PYG{n}{sc}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{o}{\PYGZlt{}}\PYG{n}{Scene} \PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{:}
\PYG{n}{Sources}\PYG{p}{:}
    \PYG{n}{source\PYGZus{}00}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{Volume} \PYG{n}{Source}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{n}{YTRegion} \PYG{p}{(}\PYG{n}{plt00401}\PYG{p}{)}\PYG{p}{:} \PYG{p}{,} \PYG{n}{center}\PYG{o}{=}\PYG{p}{[}  \PYG{l+m+mf}{1.09888770e+25}   \PYG{l+m+mf}{1.09888770e+25}   \PYG{l+m+mf}{1.09888770e+25}\PYG{p}{]} \PYG{n}{cm}\PYG{p}{,} \PYG{n}{left\PYGZus{}edge}\PYG{o}{=}\PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]} \PYG{n}{cm}\PYG{p}{,} \PYG{n}{right\PYGZus{}edge}\PYG{o}{=}\PYG{p}{[}  \PYG{l+m+mf}{2.19777540e+25}   \PYG{l+m+mf}{2.19777540e+25}   \PYG{l+m+mf}{2.19777540e+25}\PYG{p}{]} \PYG{n}{cm} \PYG{n}{transfer\PYGZus{}function}\PYG{p}{:}\PYG{k+kc}{None}
\PYG{n}{Camera}\PYG{p}{:}
    \PYG{o}{\PYGZlt{}}\PYG{n}{Camera} \PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{:}
    \PYG{n}{position}\PYG{p}{:}\PYG{p}{[} \PYG{l+m+mf}{14.24501}  \PYG{l+m+mf}{14.24501}  \PYG{l+m+mf}{14.24501}\PYG{p}{]} \PYG{n}{code\PYGZus{}length}
    \PYG{n}{focus}\PYG{p}{:}\PYG{p}{[} \PYG{l+m+mf}{7.122505}  \PYG{l+m+mf}{7.122505}  \PYG{l+m+mf}{7.122505}\PYG{p}{]} \PYG{n}{code\PYGZus{}length}
    \PYG{n}{north\PYGZus{}vector}\PYG{p}{:}\PYG{p}{[} \PYG{l+m+mf}{0.81649658} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.40824829} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.40824829}\PYG{p}{]}
    \PYG{n}{width}\PYG{p}{:}\PYG{p}{[} \PYG{l+m+mf}{21.367515}  \PYG{l+m+mf}{21.367515}  \PYG{l+m+mf}{21.367515}\PYG{p}{]} \PYG{n}{code\PYGZus{}length}
    \PYG{n}{light}\PYG{p}{:}\PYG{k+kc}{None}
    \PYG{n}{resolution}\PYG{p}{:}\PYG{p}{(}\PYG{l+m+mi}{512}\PYG{p}{,} \PYG{l+m+mi}{512}\PYG{p}{)}
\PYG{n}{Lens}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{Lens} \PYG{n}{Object}\PYG{o}{\PYGZgt{}}\PYG{p}{:}
    \PYG{n}{lens\PYGZus{}type}\PYG{p}{:}\PYG{n}{perspective}
    \PYG{n}{viewpoint}\PYG{p}{:}\PYG{p}{[} \PYG{l+m+mf}{0.95423473}  \PYG{l+m+mf}{0.95423473}  \PYG{l+m+mf}{0.95423473}\PYG{p}{]} \PYG{n}{code\PYGZus{}length}

\PYG{n}{In} \PYG{p}{[}\PYG{l+m+mi}{19}\PYG{p}{]}\PYG{p}{:} \PYG{n}{sc}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{07}\PYG{p}{,}\PYG{l+m+mi}{825} \PYG{n}{Rendering} \PYG{n}{scene} \PYG{p}{(}\PYG{n}{Can} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{07}\PYG{p}{,}\PYG{l+m+mi}{825} \PYG{n}{Creating} \PYG{n}{volume}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{07}\PYG{p}{,}\PYG{l+m+mi}{996} \PYG{n}{Creating} \PYG{n}{transfer} \PYG{n}{function}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{07}\PYG{p}{,}\PYG{l+m+mi}{997} \PYG{n}{Calculating} \PYG{n}{data} \PYG{n}{bounds}\PYG{o}{.} \PYG{n}{This} \PYG{n}{may} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{o}{.}
\PYG{n}{Set} \PYG{n}{the} \PYG{n}{TransferFunctionHelper}\PYG{o}{.}\PYG{n}{bounds} \PYG{n}{to} \PYG{n}{avoid} \PYG{n}{this}\PYG{o}{.}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{15}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{471} \PYG{n}{Saving} \PYG{n}{render} \PYG{n}{plt00401\PYGZus{}Render\PYGZus{}density}\PYG{o}{.}\PYG{n}{png}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this is \hyperref[\detokenize{Visualization:fig-yt-nyx-vol-rend}]{Fig.\@ \ref{\detokenize{Visualization:fig-yt-nyx-vol-rend}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{yt_Nyx_density_vol_rend}.png}
\caption{Volume rendering of \(128^3\) Nyx simulation using yt. This corresponds
to the same plot file used to generate the slice plot in
\hyperref[\detokenize{Visualization:fig-yt-nyx-slice-plot}]{Fig.\@ \ref{\detokenize{Visualization:fig-yt-nyx-slice-plot}}}.}\label{\detokenize{Visualization:id9}}\label{\detokenize{Visualization:fig-yt-nyx-vol-rend}}\end{figure}


\subsection{Using yt at NERSC (\sphinxstyleemphasis{under development})}
\label{\detokenize{Visualization:using-yt-at-nersc-under-development}}
\sphinxAtStartPar
Because yt is Python\sphinxhyphen{}based, it is portable and can be used in many software
environments. Here we focus on yt’s capabilities at NERSC, which provides
resources for performing both interactive and batch queue\sphinxhyphen{}based visualization
and analysis of AMReX data. Coupled with yt’s MPI and OpenMP parallelization
capabilities, this can enable high\sphinxhyphen{}throughput visualization and analysis
workflows.


\subsubsection{Interactive yt with Jupyter notebooks}
\label{\detokenize{Visualization:interactive-yt-with-jupyter-notebooks}}
\sphinxAtStartPar
Unlike VisIt (see the section on {\hyperref[\detokenize{Visualization:sec-visit}]{\sphinxcrossref{\DUrole{std,std-ref}{VisIt}}}}), yt has no client\sphinxhyphen{}server
interface. Such an interface is often crucial when one has large data sets
generated on a remote system, but wishes to visualize the data on a local
workstation. Both copying the data between the two systems, as well as
visualizing the data itself on a workstation, can be prohibitively slow.

\sphinxAtStartPar
Fortunately, NERSC has implemented several resources which allow one to
interact with yt remotely, emulating a client\sphinxhyphen{}server model. In particular,
NERSC now hosts Jupyter notebooks which run IPython kernels on the Cori system;
this provides users access to the \sphinxcode{\sphinxupquote{\$HOME}}, \sphinxcode{\sphinxupquote{/project}}, and \sphinxcode{\sphinxupquote{\$SCRATCH}}
file systems from a web browser\sphinxhyphen{}based Jupyter notebook.  \sphinxstylestrong{*Please note that
Jupyter hosting at NERSC is still under development, and the environment may
change without notice.*}

\sphinxAtStartPar
NERSC also provides Anaconda Python, which allows users to create their own
customizable Python environments. It is recommended to install yt in such an
environment. One can do so with the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{user@cori10:\PYGZti{}\PYGZgt{} module load python/3.5\PYGZhy{}anaconda}
\PYG{g+go}{user@cori10:\PYGZti{}\PYGZgt{} conda create \PYGZhy{}p \PYGZdl{}HOME/yt\PYGZhy{}conda numpy}
\PYG{g+go}{user@cori10:\PYGZti{}\PYGZgt{} source activate \PYGZdl{}HOME/yt\PYGZhy{}conda}
\PYG{g+gp+gpVirtualEnv}{(/global/homes/u/user/yt\PYGZhy{}conda/)} \PYG{g+go}{user@cori10:\PYGZti{}\PYGZgt{} pip install yt}
\end{sphinxVerbatim}

\sphinxAtStartPar
More information about Anaconda Python at NERSC is here:
\sphinxurl{http://www.nersc.gov/users/data-analytics/data-analytics/python/anaconda-python/}.

\sphinxAtStartPar
One can then configure this Anaconda environment to run in a Jupyter notebook
hosted on the Cori system. Currently this is available in two places: on
\sphinxurl{https://ipython.nersc.gov}, and on \sphinxurl{https://jupyter-dev.nersc.gov}.  The latter
likely reflects what the stable, production environment for Jupyter notebooks
will look like at NERSC, but it is still under development and subject to
change. To load this custom Python kernel in a Jupyter notebook, follow the
instructions at this URL under the “Custom Kernels” heading:
\sphinxurl{http://www.nersc.gov/users/data-analytics/data-analytics/web-applications-for-data-analytics}.
After writing the appropriate \sphinxcode{\sphinxupquote{kernel.json}} file, the custom kernel will
appear as an available Jupyter notebook. Then one can interactively visualize
AMReX plot files in the web browser. \sphinxstepexplicit %
\begin{footnote}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
It is convenient to use the
magic command \sphinxcode{\sphinxupquote{\%matplotlib inline}} in order to render matplotlib
figures in the same browser window as the notebook, as opposed to displaying it
as a new window.
%
\end{footnote}


\subsubsection{Parallel}
\label{\detokenize{Visualization:parallel}}
\sphinxAtStartPar
Besides the benefit of no longer needing to move data back and forth between
NERSC and one’s local workstation to do visualization and analysis, an
additional feature of yt which takes advantage of the computational resources
at NERSC is its parallelization capabilities. yt supports both MPI\sphinxhyphen{} and
OpenMP\sphinxhyphen{}based parallelization of various tasks, which are discussed here:
\sphinxurl{http://yt-project.org/doc/analyzing/parallel\_computation.html}.

\sphinxAtStartPar
Configuring yt for MPI parallelization at NERSC is a more complex task than
discussed in the official yt documentation; the command \sphinxcode{\sphinxupquote{pip install mpi4py}}
is not sufficient. Rather, one must compile \sphinxcode{\sphinxupquote{mpi4py}} from source using the
Cray compiler wrappers \sphinxcode{\sphinxupquote{cc}}, \sphinxcode{\sphinxupquote{CC}}, and \sphinxcode{\sphinxupquote{ftn}} on Cori. Instructions for
compiling \sphinxcode{\sphinxupquote{mpi4py}} at NERSC are provided here:
\sphinxurl{http://www.nersc.gov/users/data-analytics/data-analytics/python/anaconda-python/\#toc-anchor-3}.
After \sphinxcode{\sphinxupquote{mpi4py}} has been compiled, one can use the regular Python interpreter
in the Anaconda environment as normal; when executing yt operations which
support MPI parallelization, the multiple MPI processes will spawn
automatically.

\sphinxAtStartPar
Although several components of yt support MPI parallelization, a few are
particularly useful:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time series analysis.} Often one runs a simulation for many time steps
and periodically writes plot files to disk for visualization and
post\sphinxhyphen{}processing. yt supports parallelization over time series data via the
\sphinxcode{\sphinxupquote{DatasetSeries}} object. yt can iterate over a \sphinxcode{\sphinxupquote{DatasetSeries}} in
parallel, with different MPI processes operating on different elements of the
series. This page provides more documentation:
\sphinxurl{http://yt-project.org/doc/analyzing/time\_series\_analysis.html\#time-series-analysis}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Volume rendering}. yt implements spatial decomposition among MPI
processes for volume rendering procedures, which can be computationally
expensive. Note that yt also implements OpenMP parallelization in volume
rendering, and so one can execute volume rendering with a hybrid MPI+OpenMP
approach. See this URL for more detail:
\sphinxurl{http://yt-project.org/doc/visualizing/volume\_rendering.html?highlight=openmp\#openmp-parallelization}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generic parallelization over multiple objects.} Sometimes one wishes to
loop over a series which is not a \sphinxcode{\sphinxupquote{DatasetSeries}}, e.g., performing
translational or rotational operations on a camera to make a volume rendering
in which the field of view moves through the simulation. In this case, one is
applying a set of operations on a single object (a single plot file), rather
than over a time series of data. For this workflow, yt provides the
\sphinxcode{\sphinxupquote{parallel\_objects()}} function. See this URL for more details:
\sphinxurl{http://yt-project.org/doc/analyzing/parallel\_computation.html\#parallelizing-over-multiple-objects}.
\begin{quote}

\sphinxAtStartPar
An example of MPI parallelization in yt is shown below, where one animates a
time series of plot files from an IAMR simulation while revolving the camera
such that it completes two full revolutions over the span of the animation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{yt}
\PYG{k+kn}{import} \PYG{n+nn}{glob}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{yt}\PYG{o}{.}\PYG{n}{enable\PYGZus{}parallelism}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{base\PYGZus{}dir1} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/global/cscratch1/sd/user/Nyx\PYGZus{}run\PYGZus{}p1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base\PYGZus{}dir2} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/global/cscratch1/sd/user/Nyx\PYGZus{}run\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base\PYGZus{}dir3} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/global/cscratch1/sd/user/Nyx\PYGZus{}run\PYGZus{}p3}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{glob1} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{base\PYGZus{}dir1} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/plt*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{glob2} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{base\PYGZus{}dir2} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/plt*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{glob3} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{n}{base\PYGZus{}dir3} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/plt*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{files} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{glob1} \PYG{o}{+} \PYG{n}{glob2} \PYG{o}{+} \PYG{n}{glob3}\PYG{p}{)}

\PYG{n}{ts} \PYG{o}{=} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{DatasetSeries}\PYG{p}{(}\PYG{n}{files}\PYG{p}{,} \PYG{n}{parallel}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{frame} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{num\PYGZus{}frames} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ts}\PYG{p}{)}
\PYG{n}{num\PYGZus{}revol} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{n}{slices} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ts}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{parallel\PYGZus{}objects}\PYG{p}{(}\PYG{n}{slices}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sc} \PYG{o}{=} \PYG{n}{yt}\PYG{o}{.}\PYG{n}{create\PYGZus{}scene}\PYG{p}{(}\PYG{n}{ts}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lens\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{perspective}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{field}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z\PYGZus{}velocity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{source} \PYG{o}{=} \PYG{n}{sc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{set\PYGZus{}bounds}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{,} \PYG{l+m+mf}{9e+0}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{set\PYGZus{}log}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n}{source}\PYG{o}{.}\PYG{n}{tfh}\PYG{o}{.}\PYG{n}{grey\PYGZus{}opacity} \PYG{o}{=} \PYG{k+kc}{False}

    \PYG{n}{cam} \PYG{o}{=} \PYG{n}{sc}\PYG{o}{.}\PYG{n}{camera}

    \PYG{n}{cam}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{num\PYGZus{}revol}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{n}{num\PYGZus{}frames}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{rot\PYGZus{}center}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{sc}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{sigma\PYGZus{}clip}\PYG{o}{=}\PYG{l+m+mf}{5.0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When executed on 4 CPUs on a Haswell node of Cori, the output looks like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{user}\PYG{n+nd}{@nid00009}\PYG{p}{:}\PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{yt\PYGZus{}vis}\PYG{o}{/}\PYG{o}{\PYGZgt{}} \PYG{n}{srun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu\PYGZus{}bind}\PYG{o}{=}\PYG{n}{cores} \PYG{n}{python} \PYG{n}{make\PYGZus{}yt\PYGZus{}movie}\PYG{o}{.}\PYG{n}{py}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{565} \PYG{n}{Global} \PYG{n}{parallel} \PYG{n}{computation} \PYG{n}{enabled}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{o}{/} \PYG{l+m+mi}{4}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{565} \PYG{n}{Global} \PYG{n}{parallel} \PYG{n}{computation} \PYG{n}{enabled}\PYG{p}{:} \PYG{l+m+mi}{2} \PYG{o}{/} \PYG{l+m+mi}{4}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{566} \PYG{n}{Global} \PYG{n}{parallel} \PYG{n}{computation} \PYG{n}{enabled}\PYG{p}{:} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{4}
\PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{566} \PYG{n}{Global} \PYG{n}{parallel} \PYG{n}{computation} \PYG{n}{enabled}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{o}{/} \PYG{l+m+mi}{4}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{957} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{current\PYGZus{}time}              \PYG{o}{=} \PYG{l+m+mf}{0.103169376949795}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{957} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}dimensions}         \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128}\PYG{p}{]}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{957} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}left\PYGZus{}edge}          \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{958} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}right\PYGZus{}edge}         \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}\PYG{p}{]}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{969} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{current\PYGZus{}time}              \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{969} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}dimensions}         \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128}\PYG{p}{]}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{969} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{current\PYGZus{}time}              \PYG{o}{=} \PYG{l+m+mf}{0.0687808060674485}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{969} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}left\PYGZus{}edge}          \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{969} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}dimensions}         \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128}\PYG{p}{]}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{970} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}right\PYGZus{}edge}         \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}\PYG{p}{]}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{970} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}left\PYGZus{}edge}          \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{970} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}right\PYGZus{}edge}         \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}\PYG{p}{]}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{973} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{current\PYGZus{}time}              \PYG{o}{=} \PYG{l+m+mf}{0.0343922351851018}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{973} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}dimensions}         \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128}\PYG{p}{]}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{974} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}left\PYGZus{}edge}          \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}  \PYG{l+m+mf}{0.}\PYG{p}{]}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{,}\PYG{l+m+mi}{974} \PYG{n}{Parameters}\PYG{p}{:} \PYG{n}{domain\PYGZus{}right\PYGZus{}edge}         \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}  \PYG{l+m+mf}{6.28318531}\PYG{p}{]}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{589} \PYG{n}{Rendering} \PYG{n}{scene} \PYG{p}{(}\PYG{n}{Can} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{P000} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{590} \PYG{n}{Creating} \PYG{n}{volume}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{592} \PYG{n}{Rendering} \PYG{n}{scene} \PYG{p}{(}\PYG{n}{Can} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{592} \PYG{n}{Rendering} \PYG{n}{scene} \PYG{p}{(}\PYG{n}{Can} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{P003} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{593} \PYG{n}{Creating} \PYG{n}{volume}
\PYG{n}{P002} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{593} \PYG{n}{Creating} \PYG{n}{volume}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{606} \PYG{n}{Rendering} \PYG{n}{scene} \PYG{p}{(}\PYG{n}{Can} \PYG{n}{take} \PYG{n}{a} \PYG{k}{while}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{P001} \PYG{n}{yt} \PYG{p}{:} \PYG{p}{[}\PYG{n}{INFO}     \PYG{p}{]} \PYG{l+m+mi}{2017}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{05}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{51}\PYG{p}{:}\PYG{l+m+mi}{34}\PYG{p}{,}\PYG{l+m+mi}{607} \PYG{n}{Creating} \PYG{n}{volume}
\end{sphinxVerbatim}

\sphinxAtStartPar
Because the \sphinxcode{\sphinxupquote{parallel\_objects()}} function transforms the loop into a
data\sphinxhyphen{}parallel problem, this procedure strong scales nearly perfectly to an
arbitrarily large number of MPI processes, allowing for rapid rendering of
large time series of data.
\end{quote}

\end{itemize}


\section{SENSEI}
\label{\detokenize{Visualization:sensei}}
\sphinxAtStartPar
SENSEI is a light weight framework for in situ data analysis. SENSEI’s data
model and API provide uniform access to and run time selection of a diverse set
of visualization and analysis back ends including VisIt Libsim, ParaView
Catalyst, VTK\sphinxhyphen{}m, Ascent, ADIOS, Yt, and Python.


\subsection{System Architecture}
\label{\detokenize{Visualization:system-architecture}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sensei_amrex_arch_sm_824}.png}
\caption{SENSEI’s in situ architecture enables use of a diverse of back ends which
can be selected at run time via an XML configuration file}\label{\detokenize{Visualization:id10}}\label{\detokenize{Visualization:sensei-arch}}\end{figure}

\sphinxAtStartPar
The three major architectural components in SENSEI are \sphinxstyleemphasis{data adaptors} which
present simulation data in SENSEI’s data model, \sphinxstyleemphasis{analysis adaptors} which
present the back end data consumers to the simulation, and \sphinxstyleemphasis{bridge code} from
which the simulation manages adaptors and periodically pushes data through the
system. SENSEI comes equipped with a number of analysis adaptors enabling use
of popular analysis and visualization libraries such as VisIt Libsim, ParaView
Catalyst, Python, and ADIOS to name a few. AMReX contains SENSEI data adaptors
and bridge code making it easy to use in AMReX based simulation codes.

\sphinxAtStartPar
SENSEI provides a \sphinxstyleemphasis{configurable analysis adaptor} which uses an XML file to
select and configure one or more back ends at run time. Run time selection of
the back end via XML means one user can access Catalyst, another Libsim, yet
another Python with no changes to the code.  This is depicted in figure
\hyperref[\detokenize{Visualization:sensei-arch}]{Fig.\@ \ref{\detokenize{Visualization:sensei-arch}}}. On the left side of the figure AMReX produces data, the
bridge code pushes the data through the configurable analysis adaptor to the
back end that was selected at run time.


\subsection{AMReX Integration}
\label{\detokenize{Visualization:amrex-integration}}
\sphinxAtStartPar
AMReX codes based on \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{Amr}}} can use SENSEI simply by enabling it in
the build and run via ParmParse parameters.  AMReX codes based on
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{AmrMesh}}} need to additionally invoke the bridge code in
\sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{::}\DUrole{name}{AmrMeshInSituBridge}}}.


\subsection{Compiling with GNU Make}
\label{\detokenize{Visualization:compiling-with-gnu-make}}
\sphinxAtStartPar
For codes making use of AMReX’s build system add the following variable to the
code’s main \sphinxcode{\sphinxupquote{GNUmakefile}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{USE\PYGZus{}SENSEI\PYGZus{}INSITU} \PYG{o}{=} TRUE
\end{sphinxVerbatim}

\sphinxAtStartPar
When set, AMReX’s make files will query environment variables for the lists of
compiler and linker flags, include directories, and link libraries. These lists
can be quite elaborate when using more sophisticated back ends, and are best
set automatically using the \sphinxcode{\sphinxupquote{sensei\_config}} command line tool that should
be installed with SENSEI. Prior to invoking make use the following command to
set these variables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{source} sensei\PYGZus{}config
\end{sphinxVerbatim}

\sphinxAtStartPar
Typically, the \sphinxcode{\sphinxupquote{sensei\_config}} tool is in the users PATH after loading
the desired SENSEI module. After configuring the build environment with
\sphinxcode{\sphinxupquote{sensei\_config}}, proceed as usual.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
make \PYGZhy{}j4 \PYGZhy{}f GNUmakefile
\end{sphinxVerbatim}


\subsection{Compiling with CMake}
\label{\detokenize{Visualization:compiling-with-cmake}}
\sphinxAtStartPar
For codes making use of AMReX’s CMake based build, one needs to enable SENSEI
and point to the CMake configuration installed with SENSEI.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cmake \PYGZhy{}DAMReX\PYGZus{}SENSEI\PYG{o}{=}ON \PYGZhy{}DSENSEI\PYGZus{}DIR\PYG{o}{=}\PYGZlt{}path to install\PYGZgt{}/lib/cmake ..
\end{sphinxVerbatim}

\sphinxAtStartPar
When CMake generates the make files proceed as usual.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
make \PYGZhy{}j4 \PYGZhy{}f GNUmakefile
\end{sphinxVerbatim}


\subsection{ParmParse Configuration}
\label{\detokenize{Visualization:parmparse-configuration}}
\sphinxAtStartPar
Once an AMReX code has been compiled with SENSEI features enabled, it will need
to be enabled and configured at runtime. This is done using ParmParse input file.
The following 3 ParmParse parameters are used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sensei}\PYG{o}{.}\PYG{n}{enabled} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{sensei}\PYG{o}{.}\PYG{n}{config} \PYG{o}{=} \PYG{n}{render\PYGZus{}iso\PYGZus{}catalyst\PYGZus{}2d}\PYG{o}{.}\PYG{n}{xml}
\PYG{n}{sensei}\PYG{o}{.}\PYG{n}{frequency} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sensei.enabled}} turns SENSEI on or off.  \sphinxcode{\sphinxupquote{sensei.config}} points to
the SENSEI XML file which selects and configures the desired back end.
\sphinxcode{\sphinxupquote{sensei.frequency}} controls the number of level 0 time steps in between
SENSEI processing.


\subsection{Back\sphinxhyphen{}end Selection and Configuration}
\label{\detokenize{Visualization:back-end-selection-and-configuration}}
\sphinxAtStartPar
The back end is selected and configured at run time using the SENSEI XML file.
The XML sets parameters specific to SENSEI and to the chosen back end. Many of
the back ends have sophisticated configuration mechanisms which SENSEI makes
use of.  For example the following XML configuration was used on NERSC’s Cori
with IAMR to render 10 iso surfaces, shown in figure \hyperref[\detokenize{Visualization:rt-visit}]{Fig.\@ \ref{\detokenize{Visualization:rt-visit}}}, using
VisIt Libsim.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}sensei}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}analysis} \PYG{n+na}{type=}\PYG{l+s}{\PYGZdq{}libsim\PYGZdq{}} \PYG{n+na}{frequency=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}} \PYG{n+na}{mode=}\PYG{l+s}{\PYGZdq{}batch\PYGZdq{}}
    \PYG{n+na}{visitdir=}\PYG{l+s}{\PYGZdq{}/usr/common/software/sensei/visit\PYGZdq{}}
    \PYG{n+na}{session=}\PYG{l+s}{\PYGZdq{}rt\PYGZus{}sensei\PYGZus{}configs/visit\PYGZus{}rt\PYGZus{}contour\PYGZus{}alpha\PYGZus{}10.session\PYGZdq{}}
    \PYG{n+na}{image\PYGZhy{}filename=}\PYG{l+s}{\PYGZdq{}rt\PYGZus{}contour\PYGZus{}\PYGZpc{}ts\PYGZdq{}} \PYG{n+na}{image\PYGZhy{}width=}\PYG{l+s}{\PYGZdq{}1555\PYGZdq{}} \PYG{n+na}{image\PYGZhy{}height=}\PYG{l+s}{\PYGZdq{}815\PYGZdq{}}
    \PYG{n+na}{image\PYGZhy{}format=}\PYG{l+s}{\PYGZdq{}png\PYGZdq{}} \PYG{n+na}{enabled=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/sensei\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxstyleemphasis{session} attribute names a session file that contains VisIt specific
runtime configuration. The session file is generated using VisIt GUI on a
representative dataset. Usually this data set is generated in a low resolution
run of the desired simulation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{rt_2048_visit_000500}.png}
\caption{SENSEI\sphinxhyphen{}Libsim in situ visualization of a Raleigh\sphinxhyphen{}Taylor instability computed
by IAMR on NERSC Cori using 2048 cores.}\label{\detokenize{Visualization:id11}}\label{\detokenize{Visualization:rt-visit}}\end{figure}

\sphinxAtStartPar
The same run and visualization was repeated using ParaView Catalyst, shown in
figure \hyperref[\detokenize{Visualization:rt-pv}]{Fig.\@ \ref{\detokenize{Visualization:rt-pv}}}, by providing the following XML configuration.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}sensei}\PYG{n+nt}{\PYGZgt{}}
  \PYG{n+nt}{\PYGZlt{}analysis} \PYG{n+na}{type=}\PYG{l+s}{\PYGZdq{}catalyst\PYGZdq{}} \PYG{n+na}{pipeline=}\PYG{l+s}{\PYGZdq{}pythonscript\PYGZdq{}}
    \PYG{n+na}{filename=}\PYG{l+s}{\PYGZdq{}rt\PYGZus{}sensei\PYGZus{}configs/rt\PYGZus{}contour.py\PYGZdq{}} \PYG{n+na}{enabled=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/sensei\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here the \sphinxstyleemphasis{filename} attribute is used to pass Catalyst a Catalyst specific
configuration that was generated using the ParaView GUI on a representative
dataset.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{rt_2048_paraview_000500}.png}
\caption{SENSEI\sphinxhyphen{}Catalyst in situ visualization of a Raleigh\sphinxhyphen{}Taylor instability
computed by IAMR on NERSC Cori using 2048 cores.}\label{\detokenize{Visualization:id12}}\label{\detokenize{Visualization:rt-pv}}\end{figure}


\subsection{Obtaining SENSEI}
\label{\detokenize{Visualization:obtaining-sensei}}
\sphinxAtStartPar
SENSEI is hosted on Kitware’s Gitlab site at \sphinxurl{https://gitlab.kitware.com/sensei/sensei}
It’s best to checkout the latest release rather than working on the master branch.

\sphinxAtStartPar
To ease the burden of wrangling back end installs SENSEI provides two platforms
with all dependencies pre\sphinxhyphen{}installed, a VirtualBox VM, and a NERSC Cori
deployment. New users are encouraged to experiment with one of these.


\subsubsection{SENSEI VM}
\label{\detokenize{Visualization:sensei-vm}}
\sphinxAtStartPar
The SENSEI VM comes with all of SENSEI’s dependencies and the major back ends
such as VisIt and ParaView installed. The VM is the easiest way to test things
out. It also can be used to see how installs were done and the environment
configured.


\subsubsection{NERSC Cori}
\label{\detokenize{Visualization:nersc-cori}}
\sphinxAtStartPar
SENSEI is deployed at NERSC on Cori. The NERSC deployment includes the major
back ends such as ParaView Catalyst, VisIt Libsim, and Python.


\paragraph{AmrLevel Tutorial with Catalyst}
\label{\detokenize{Visualization:amrlevel-tutorial-with-catalyst}}
\sphinxAtStartPar
The following steps show how to run the tutorial with ParaView Catalyst. The
simulation will periodically write images during the run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ssh cori.nersc.gov
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}SCRATCH}
git clone https://github.com/AMReX\PYGZhy{}Codes/amrex.git
\PYG{n+nb}{cd} amrex/Tutorials/Amr/Advection\PYGZus{}AmrLevel/Exec/SingleVortex
module use /usr/common/software/sensei/modulefiles
module load sensei/2.1.0\PYGZhy{}catalyst\PYGZhy{}shared
\PYG{n+nb}{source} sensei\PYGZus{}config
vim GNUmakefile
\PYG{c+c1}{\PYGZsh{} USE\PYGZus{}SENSEI\PYGZus{}INSITU=TRUE}
make \PYGZhy{}j4 \PYGZhy{}f GNUmakefile
vim inputs
\PYG{c+c1}{\PYGZsh{} sensei.enabled=1}
\PYG{c+c1}{\PYGZsh{} sensei.config=sensei/render\PYGZus{}iso\PYGZus{}catalyst\PYGZus{}2d.xml}
salloc \PYGZhy{}C haswell \PYGZhy{}N \PYG{l+m}{1} \PYGZhy{}t \PYG{l+m}{00}:30:00 \PYGZhy{}q debug
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}SCRATCH}/amrex/Tutorials/Amr/Advection\PYGZus{}AmrLevel/Exec/SingleVortex
./main2d.gnu.haswell.MPI.ex inputs
\end{sphinxVerbatim}


\paragraph{AmrLevel Tutorial with Libsim}
\label{\detokenize{Visualization:amrlevel-tutorial-with-libsim}}
\sphinxAtStartPar
The following steps show how to run the tutorial with VisIt Libsim. The
simulation will periodically write images during the run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ssh cori.nersc.gov
\PYG{n+nb}{cd} \PYG{n+nv}{\PYGZdl{}SCRATCH}
git clone https://github.com/AMReX\PYGZhy{}Codes/amrex.git
\PYG{n+nb}{cd} amrex/Tutorials/Amr/Advection\PYGZus{}AmrLevel/Exec/SingleVortex
module use /usr/common/software/sensei/modulefiles
module load sensei/2.1.0\PYGZhy{}libsim\PYGZhy{}shared
\PYG{n+nb}{source} sensei\PYGZus{}config
vim GNUmakefile
\PYG{c+c1}{\PYGZsh{} USE\PYGZus{}SENSEI\PYGZus{}INSITU=TRUE}
make \PYGZhy{}j4 \PYGZhy{}f GNUmakefile
vim inputs
\PYG{c+c1}{\PYGZsh{} sensei.enabled=1}
\PYG{c+c1}{\PYGZsh{} sensei.config=sensei/render\PYGZus{}iso\PYGZus{}libsim\PYGZus{}2d.xml}
salloc \PYGZhy{}C haswell \PYGZhy{}N \PYG{l+m}{1} \PYGZhy{}t \PYG{l+m}{00}:30:00 \PYGZhy{}q debug
./main2d.gnu.haswell.MPI.ex inputs
\end{sphinxVerbatim}


\chapter{Post\sphinxhyphen{}Processing}
\label{\detokenize{Post_Processing_Chapter:post-processing}}\label{\detokenize{Post_Processing_Chapter:chap-post-processing}}\label{\detokenize{Post_Processing_Chapter::doc}}
\sphinxAtStartPar
There are utilities you can build that can read in plotfiles into a
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} and perform post\sphinxhyphen{}processing.  Since the data is read into
\sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} you can perform standard \sphinxcode{\sphinxupquote{\DUrole{name}{MFIter}}} loops to iterate over
the data to perform calculations.


\section{Post\sphinxhyphen{}Processing}
\label{\detokenize{Post_Processing:post-processing}}\label{\detokenize{Post_Processing:sec-postprocessing}}\label{\detokenize{Post_Processing::doc}}
\sphinxAtStartPar
The following is a list of tools you may find useful for processing
plotfile data generated by AMReX codes.


\subsection{WritePlotfileToASCII}
\label{\detokenize{Post_Processing:writeplotfiletoascii}}
\sphinxAtStartPar
This basic routine reads in a single\sphinxhyphen{}level plotfile and writes the entire contents
to the standard output, one line at a time for each data value.
After reading in the plotfile to a \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}}, the program copies the data
into a separate \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}} with one large grid to make writing the data out
sequentially an easier task.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Postprocessing/C\_Src}}, edit \sphinxcode{\sphinxupquote{GNUMakefile}} to read
\sphinxcode{\sphinxupquote{EBASE = WritePlotfileToASCII}} and \sphinxcode{\sphinxupquote{NEEDS\_f90\_SRC = FALSE}} and then \sphinxcode{\sphinxupquote{make}}
to generate an executable.  To run the executable, \sphinxcode{\sphinxupquote{\textless{}executable\textgreater{} infile=\textless{}plotfilename\textgreater{}}}.
You can modify the cpp file to write out on certain components, coordinates,
row/column formatting, etc.

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fextract}
\label{\detokenize{Post_Processing:fextract}}
\sphinxAtStartPar
This basic routine reads in a single\sphinxhyphen{}level plotfile and extracts selected contents
along a 1\sphinxhyphen{}D axis to an ascii file.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, just type  \sphinxcode{\sphinxupquote{make}}
to generate an executable.  To run the executable, execute \sphinxcode{\sphinxupquote{./fextract.gnu.ex}} to see the full command line
and all the available options.
It is possible to select the axis (\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} flag) where the data are collected. By default the axis is taken at the center of the domain.
A generic ASCII file is generated by default, which contains many details of the simulation. However data can be exported in a raw csv file with the command \sphinxcode{\sphinxupquote{\sphinxhyphen{}csv}}.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile(postproc\PYGZus{}docs)\PYGZdl{} }./fextract.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}Equil\PYGZus{}2d\PYGZus{}Bench/plt0000003

\PYG{g+go}{ slicing along x\PYGZhy{}direction at coarse grid (j,k)=(16,0) and output to /home/user/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}Equil\PYGZus{}2d\PYGZus{}Bench/plt0000003.slice}
\end{sphinxVerbatim}

\sphinxAtStartPar
This produces an ascii file of the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@machine:\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}Equil\PYGZus{}2d\PYGZus{}Bench(main)\PYGZdl{} cat plt0000003.slice
\PYGZsh{} 1\PYGZhy{}d slice in x\PYGZhy{}direction, file: /home/user/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}Equil\PYGZus{}2d\PYGZus{}Bench/plt0000003
\PYGZsh{} time =  0.30000000000000004
\PYGZsh{}                       x                      rho                     rho1                     rho2
                      0.5       2.9993686498953114      0.60059557892152249       1.0502705977511799
                      1.5       3.0003554204928884      0.59935306004478783       1.0508550827449006
                      2.5       3.0008794559257246       0.5990345897671786       1.0500559828760208
                      3.5       2.9997442287698322      0.60001913923213179       1.0508294996618532
                      4.5       3.0001395958111967      0.60021852440041579       1.0487977074444519
                      5.5       3.0000989976613459      0.60022830117083248       1.0489080268816791
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fcompare}
\label{\detokenize{Post_Processing:fcompare}}
\sphinxAtStartPar
Compares two plotfiles, zone by zone, to machine precision
and reports the maximum absolute and relative errors for each
variable.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fextract.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fextract.gnu.ex}} without inputs will bring up usage and options.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{}   }./fcompare.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000000 \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000003

\PYG{g+go}{            variable name            absolute error            relative error}
\PYG{g+go}{                                        (||A \PYGZhy{} B||)         (||A \PYGZhy{} B||/||A||)}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{ level = 0}
\PYG{g+go}{ rho                                    0.020039805             0.00845645443}
\PYG{g+go}{ rho1                                 0.01703166127             0.01450634203}
\PYG{g+go}{ rho2                                 0.01737072831             0.01479513491}
\PYG{g+go}{ rho3                                 0.01436258458             0.01436258458}
\PYG{g+go}{ c1                                  0.003022939351             0.00610148453}
\PYG{g+go}{ c2                                  0.003167240107            0.006392740399}
\PYG{g+go}{ c3                                  0.006190179458            0.006190179458}
\PYG{g+go}{ averaged\PYGZus{}velx                      0.0001120979347             0.02141254606}
\PYG{g+go}{ averaged\PYGZus{}vely                      0.0001120979347             0.02141254606}
\PYG{g+go}{ shifted\PYGZus{}velx                       0.0001151524563             0.02145887678}
\PYG{g+go}{ shifted\PYGZus{}vely                       0.0001151524563             0.02145887678}
\PYG{g+go}{ pres                                 0.05687549245          1.797693135e+308}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fboxinfo}
\label{\detokenize{Post_Processing:fboxinfo}}
\sphinxAtStartPar
Displays information about AMR levels and boxes. Works with
1\sphinxhyphen{}, 2\sphinxhyphen{} or 3\sphinxhyphen{}dimensional datasets.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fboxinfo.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fboxinfo.gnu.ex}} without inputs will bring up usage and options.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }./fboxinfo.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000000

\PYG{g+go}{ plotfile: /home/user/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000000}
\PYG{g+go}{ level   0: number of boxes =      4, volume = 100.00\PYGZpc{}}
\PYG{g+go}{            maximum zones =        64 x      64}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fvarnames}
\label{\detokenize{Post_Processing:fvarnames}}
\sphinxAtStartPar
Takes a single plotfile and displays a list of the variables present.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fvarnames.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fvarnames.gnu.ex}} without inputs will bring up usage and description.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }./fvarnames.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000000
\PYG{g+go}{    0   rho}
\PYG{g+go}{    1   rho1}
\PYG{g+go}{    2   rho2}
\PYG{g+go}{    3   rho3}
\PYG{g+go}{    4   c1}
\PYG{g+go}{    5   c2}
\PYG{g+go}{    6   c3}
\PYG{g+go}{    7   averaged\PYGZus{}velx}
\PYG{g+go}{    8   averaged\PYGZus{}vely}
\PYG{g+go}{    9   shifted\PYGZus{}velx}
\PYG{g+go}{   10   shifted\PYGZus{}vely}
\PYG{g+go}{   11   pres}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{ftime}
\label{\detokenize{Post_Processing:ftime}}
\sphinxAtStartPar
Takes a whitespace separated list of plotfiles and returns the time
for each plotfile.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./ftime.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./ftime.gnu.ex}} without inputs will bring up usage and description.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine :\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }./ftime.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000000 \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000002 \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000004 \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000006

\PYG{g+go}{ /home/user/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000000    0}
\PYG{g+go}{ /home/user/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000002    4.0000000000000001e\PYGZhy{}13}
\PYG{g+go}{ /home/user/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000004    8.0000000000000002e\PYGZhy{}13}
\PYG{g+go}{ /home/user/AMReX/FHDeX/exec/multispec/Spinodal\PYGZus{}Charges\PYGZus{}2d\PYGZus{}Bench/plt0000006    1.1999999999999999e\PYGZhy{}12}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fsnapshot}
\label{\detokenize{Post_Processing:fsnapshot}}
\sphinxAtStartPar
Produces an image of a 2\sphinxhyphen{}d plotfile, or a slice of a 3\sphinxhyphen{}d plotfile.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fsnapshot.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fsnapshot.gnu.ex}} without inputs will bring up usage and options.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\sphinxAtStartPar
In this example an image of the data from the 2\sphinxhyphen{}d plotfile \sphinxcode{\sphinxupquote{plt0000003}} is created.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@silentm:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }./fsnapshot.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZhy{}v rho \PYGZhy{}p Palette \PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000003
\PYG{g+go}{ plotfile variable maximum = 2.349724636}
\PYG{g+go}{ plotfile variable minimum = 1}
\end{sphinxVerbatim}

\sphinxAtStartPar
This command tells \sphinxcode{\sphinxupquote{fsnapshot}} to plot the variable \sphinxcode{\sphinxupquote{rho}} using the palette
\sphinxcode{\sphinxupquote{Palette}} which is available in the current directory, \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}.
The image is created in the same directory as the plotfile folder.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }ls \PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/
\PYG{g+go}{ plt0000000  plt0000003  plt0000003.rho.ppm}
\end{sphinxVerbatim}

\sphinxAtStartPar
The image is produced in the portable pixmap format (.ppm). It can be displayed using
the command \sphinxcode{\sphinxupquote{display}} from \sphinxhref{https://imagemagick.org/index.php}{ImageMagick} as seen below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }display \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000003.rho.ppm
\end{sphinxVerbatim}

\sphinxAtStartPar
This should produce a window to view the image. (The example here is enlarged for clarity.):

\noindent\sphinxincludegraphics{{ex_fsnapshot_resize}.png}

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fnan}
\label{\detokenize{Post_Processing:fnan}}
\sphinxAtStartPar
Takes a single plot file and reports whether each variable contains
NaN values.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fnan.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fnan.gnu.ex}} without inputs will bring up usage and description.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@machine:\PYGZti{}/AMReX/amrex/Tools/Plotfile\PYGZdl{} }./fnan.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000003
\PYG{g+go}{ rho           : clean}
\PYG{g+go}{ rho1          : clean}
\PYG{g+go}{ rho2          : clean}
\PYG{g+go}{ rho3          : clean}
\PYG{g+go}{ c1            : clean}
\PYG{g+go}{ c2            : clean}
\PYG{g+go}{ c3            : clean}
\PYG{g+go}{ averaged\PYGZus{}velx : clean}
\PYG{g+go}{ averaged\PYGZus{}vely : clean}
\PYG{g+go}{ shifted\PYGZus{}velx  : clean}
\PYG{g+go}{ shifted\PYGZus{}vely  : clean}
\PYG{g+go}{ pres          : clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example, there were no NaN values found in the variable data.

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}


\subsection{fextrema}
\label{\detokenize{Post_Processing:fextrema}}
\sphinxAtStartPar
Report the extrema (min/max) for each variable in a plotfile.

\sphinxAtStartPar
\sphinxstylestrong{How to build and run}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{amrex/Tools/Plotfile}}, type \sphinxcode{\sphinxupquote{make}} and then \sphinxcode{\sphinxupquote{./fextrema.gnu.ex}} to run.
Typing \sphinxcode{\sphinxupquote{./fextrema.gnu.ex}} without inputs will bring up usage and options.

\sphinxAtStartPar
\sphinxstylestrong{Example}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{user@:\PYGZti{}/AMReX/amrex/Tools/Plotfile(postproc\PYGZus{}docs)\PYGZdl{} }./fextrema.gnu.ex \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000000 \PYG{l+s+se}{\PYGZbs{}}
\PYG{g+gp}{\PYGZgt{} }\PYGZti{}/AMReX/FHDeX/exec/multispec/Reg\PYGZus{}DetBubble\PYGZus{}2d\PYGZus{}Bench/plt0000003
\PYG{g+gp}{\PYGZsh{}                   }\PYG{n+nb}{time} \PYG{p}{|}rho                                         \PYG{p}{|}rho1                                        \PYG{p}{|}rho2                                        \PYG{p}{|}rho3                                        \PYG{p}{|}c1                                          \PYG{p}{|}c2                                          \PYG{p}{|}c3                                          \PYG{p}{|}averaged\PYGZus{}velx                               \PYG{p}{|}averaged\PYGZus{}vely                               \PYG{p}{|}shifted\PYGZus{}velx                                \PYG{p}{|}shifted\PYGZus{}vely                                \PYG{p}{|}pres                                        \PYG{p}{|}
\PYG{g+gp}{\PYGZsh{}                        }\PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}         min                   max          \PYG{p}{|}
\PYG{g+go}{                      0                       1          2.369764441         8.277319027e\PYGZhy{}17          1.174083806         8.277319027e\PYGZhy{}17          1.174083806           0.02159682815                    1         8.277319027e\PYGZhy{}17         0.4954432542         8.277319027e\PYGZhy{}17         0.4954432542          0.009113491527                    1         \PYGZhy{}0.005235152063       0.005235152063         \PYGZhy{}0.005235152063       0.005235152063         \PYGZhy{}0.005366192156       0.005366192156         \PYGZhy{}0.005366192156       0.005366192156                       0                    0}
\PYG{g+go}{                   0.03                       1          2.349724636         8.277319027e\PYGZhy{}17          1.157052145         8.277319027e\PYGZhy{}17          1.156713078           0.03595941273                    1         8.277319027e\PYGZhy{}17         0.4924203149         8.277319027e\PYGZhy{}17         0.4922760141           0.01530367099                    1         \PYGZhy{}0.005172583789       0.005172583789         \PYGZhy{}0.005172583789       0.005172583789         \PYGZhy{}0.005287367803       0.005287367803         \PYGZhy{}0.005287367803       0.005287367803         \PYGZhy{}0.004924487345        0.05687549245}
\end{sphinxVerbatim}


\chapter{Run\sphinxhyphen{}time Inputs}
\label{\detokenize{Inputs_Chapter:run-time-inputs}}\label{\detokenize{Inputs_Chapter:chap-inputs}}\label{\detokenize{Inputs_Chapter::doc}}

\section{Problem Definition}
\label{\detokenize{InputsProblemDefinition:problem-definition}}\label{\detokenize{InputsProblemDefinition::doc}}
\sphinxAtStartPar
The following inputs must be preceded by “amr.”


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
n\_cell
&
\sphinxAtStartPar
Number of cells at level 0 in each coordinate direction
&
\sphinxAtStartPar
Int Int Int
&
\sphinxAtStartPar
None
\\
\hline
\sphinxAtStartPar
max\_level
&
\sphinxAtStartPar
Maximum level of refinement allowed (0 when single\sphinxhyphen{}level)
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
None
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The following inputs must be preceded by “geometry.”


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
coord\_sys
&
\sphinxAtStartPar
0 for Cartesian
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
is\_periodic
&
\sphinxAtStartPar
1 for true, 0 for false (one value for each coordinate direction)
&
\sphinxAtStartPar
Ints
&
\sphinxAtStartPar
0 0 0
\\
\hline
\sphinxAtStartPar
prob\_lo
&
\sphinxAtStartPar
Low corner of physical domain (physical not index space)
&
\sphinxAtStartPar
Reals
&
\sphinxAtStartPar
None
\\
\hline
\sphinxAtStartPar
prob\_hi
&
\sphinxAtStartPar
High corner of physical domain (physical not index space)
&
\sphinxAtStartPar
Reals
&
\sphinxAtStartPar
None
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Time Stepping}
\label{\detokenize{InputsTimeStepping:time-stepping}}\label{\detokenize{InputsTimeStepping::doc}}
\sphinxAtStartPar
The following inputs must be preceded by “amr.”   Note that if both are specified, both criteria
are used and the simulation still stop when the first criterion is hit.  In the case of unsteady flow,
the simulation will stop when either the number of steps reaches max\_step or time reaches stop\_time.
In the case of unsteady flow, the simulation will stop when either the tolerance (difference between
subsequent steps) is reached or the number of iterations reaches the maximum number specified.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
max\_step
&
\sphinxAtStartPar
Maximum number of time steps to take
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
stop\_time
&
\sphinxAtStartPar
Maximum time to reach
&
\sphinxAtStartPar
Real
&
\sphinxAtStartPar
\sphinxhyphen{}1.0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Gridding and Load Balancing}
\label{\detokenize{InputsLoadBalancing:gridding-and-load-balancing}}\label{\detokenize{InputsLoadBalancing:chap-inputsloadbalancing}}\label{\detokenize{InputsLoadBalancing::doc}}
\sphinxAtStartPar
The following inputs must be preceded by “amr” and determine how we create the grids and how often we regrid.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
regrid\_int
&
\sphinxAtStartPar
How often to regrid (in number of steps at level 0)
if regrid\_int = \sphinxhyphen{}1 then no regridding will occur
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_x
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in x\sphinxhyphen{}direction
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_y
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in y\sphinxhyphen{}direction
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_z
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in z\sphinxhyphen{}direction
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\sphinxAtStartPar
blocking\_factor\_x
&
\sphinxAtStartPar
Each grid must be divisible by blocking\_factor\_x in x\sphinxhyphen{}direction
(must be 1 or power of 2)
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
8
\\
\hline
\sphinxAtStartPar
blocking\_factor\_y
&
\sphinxAtStartPar
Each grid must be divisible by blocking\_factor\_y in y\sphinxhyphen{}direction
(must be 1 or power of 2)
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
8
\\
\hline
\sphinxAtStartPar
blocking\_factor\_z
&
\sphinxAtStartPar
Each grid must be divisible by blocking\_factor\_z in z\sphinxhyphen{}direction
(must be 1 or power of 2)
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
8
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The following inputs must be preceded by “particles”


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_x
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in x\sphinxhyphen{}direction
for grids in the ParticleBoxArray if dual\_grid is true
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_y
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in y\sphinxhyphen{}direction
for grids in the ParticleBoxArray if dual\_grid is true
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\sphinxAtStartPar
max\_grid\_size\_z
&
\sphinxAtStartPar
Maximum number of cells at level 0 in each grid in z\sphinxhyphen{}direction
for grids in the ParticleBoxArray if dual\_grid is true.
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
32
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Plotfiles and Other Output}
\label{\detokenize{InputsPlotFiles:plotfiles-and-other-output}}\label{\detokenize{InputsPlotFiles:chap-inputsplotfiles}}\label{\detokenize{InputsPlotFiles::doc}}
\sphinxAtStartPar
The following inputs must be preceded by “amr” and control the frequency and naming of plotfile generation, as well
as whether a plotfile should be written out immediately after restarting a simulation.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
plot\_int
&
\sphinxAtStartPar
Frequency of plotfile output;
if \sphinxhyphen{}1 then no plotfiles will be written
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
plotfile\_on\_restart
&
\sphinxAtStartPar
Should we write a plotfile when we restart (only used if plot\_int\textgreater{}0)
&
\sphinxAtStartPar
Bool
&
\sphinxAtStartPar
False
\\
\hline
\sphinxAtStartPar
plot\_file
&
\sphinxAtStartPar
Prefix to use for plotfile output
&
\sphinxAtStartPar
String
&
\sphinxAtStartPar
plt
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Checkpoint/Restart}
\label{\detokenize{InputsCheckpoint:checkpoint-restart}}\label{\detokenize{InputsCheckpoint:chap-inputscheckpoint}}\label{\detokenize{InputsCheckpoint::doc}}
\sphinxAtStartPar
The following inputs must be preceded by “amr” and control checkpoint/restart.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default
\\
\hline
\sphinxAtStartPar
restart
&
\sphinxAtStartPar
If present, then the name of file to restart from
&
\sphinxAtStartPar
String
&
\sphinxAtStartPar
None
\\
\hline
\sphinxAtStartPar
check\_int
&
\sphinxAtStartPar
Frequency of checkpoint output;
if \sphinxhyphen{}1 then no checkpoints will be written
&
\sphinxAtStartPar
Int
&
\sphinxAtStartPar
\sphinxhyphen{}1
\\
\hline
\sphinxAtStartPar
check\_file
&
\sphinxAtStartPar
Prefix to use for checkpoint output
&
\sphinxAtStartPar
String
&
\sphinxAtStartPar
chk
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{AMReX\sphinxhyphen{}based Profiling Tools}
\label{\detokenize{AMReX_Profiling_Tools_Chapter:amrex-based-profiling-tools}}\label{\detokenize{AMReX_Profiling_Tools_Chapter:chap-amrex-based-profiling-tools}}\label{\detokenize{AMReX_Profiling_Tools_Chapter::doc}}
\sphinxAtStartPar
AMReX\sphinxhyphen{}based application codes can be instrumented using AMReX\sphinxhyphen{}specific
performance profiling tools that take into account the hierarchical nature of
the mesh in most AMReX\sphinxhyphen{}based applications. These codes can be instrumented for
varying levels of profiling detail.

\sphinxAtStartPar
Here are links to short courses (slides) on how to use the profiling tools.
More details can be found in the documentation below.

\sphinxAtStartPar
Lecture 1: \sphinxhref{http://ccse.lbl.gov/AMReX/AMReX\_Profiling\_Lecture1.pdf}{Introduction and TINYPROFILER}

\sphinxAtStartPar
Lecture 2: \sphinxhref{http://ccse.lbl.gov/AMReX/AMReX\_Profiling\_Lecture2.pdf}{Introduction to  Full Profiling}

\sphinxAtStartPar
Lecture 3: \sphinxhref{http://ccse.lbl.gov/AMReX/AMReX\_Profiling\_Lecture3.pdf}{Using ProfVis \textendash{} GUI Features}

\sphinxAtStartPar
Lecture 4: \sphinxhref{http://ccse.lbl.gov/AMReX/AMReX\_Profiling\_Lecture4.pdf}{Batch Options and Advanced Profiling Flags}


\section{Types of Profiling}
\label{\detokenize{AMReX_Profiling_Tools:types-of-profiling}}\label{\detokenize{AMReX_Profiling_Tools::doc}}
\sphinxAtStartPar
Currently you have two options for AMReX\sphinxhyphen{}specific profiling:
{\hyperref[\detokenize{AMReX_Profiling_Tools:sec-tiny-profiling}]{\sphinxcrossref{\DUrole{std,std-ref}{Tiny Profiling}}}} and {\hyperref[\detokenize{AMReX_Profiling_Tools:sec-full-profiling}]{\sphinxcrossref{\DUrole{std,std-ref}{Full Profiling}}}}.


\subsection{Tiny Profiling}
\label{\detokenize{AMReX_Profiling_Tools:tiny-profiling}}\label{\detokenize{AMReX_Profiling_Tools:sec-tiny-profiling}}
\sphinxAtStartPar
To enable “Tiny Profiling”, if using GNU Make then set

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TINY\PYGZus{}PROFILE} \PYG{o}{=} \PYG{n}{TRUE}
\PYG{n}{PROFILE}      \PYG{o}{=} \PYG{n}{FALSE}
\end{sphinxVerbatim}

\sphinxAtStartPar
in your GNUMakefile.   If using cmake then set the following cmake flags

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AMReX\PYGZus{}TINY\PYGZus{}PROFILE} \PYG{o}{=} \PYG{n}{ON}
\PYG{n}{AMReX\PYGZus{}BASE\PYGZus{}PROFILE} \PYG{o}{=} \PYG{n}{OFF}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that if you set \sphinxcode{\sphinxupquote{PROFILE = TRUE}}  (or \sphinxcode{\sphinxupquote{AMReX\_BASE\_PROFILE =
ON}}) then this will override the \sphinxcode{\sphinxupquote{TINY\_PROFILE}} flag and tiny profiling will
be disabled.

\sphinxAtStartPar
At the end of the run, a summary of exclusive and inclusive function times will
be written to stdout.  This output includes the minimum and maximum (over
processes) time spent in each routine as well as the average and the maximum
percentage of total run time.   See {\hyperref[\detokenize{AMReX_Profiling_Tools:sec-sample-tiny}]{\sphinxcrossref{\DUrole{std,std-ref}{Sample Output From Tiny Profile}}}} for sample output.

\sphinxAtStartPar
The tiny profiler automatically writes the results to stdout at the end of your
code, when \sphinxcode{\sphinxupquote{amrex::Finalize();}} is reached. However, you may want to write
partial profiling results to ensure your information is saved when you may fail
to converge or if you expect to run out of allocated time. Partial results can
be written at user\sphinxhyphen{}defined times by inserting the line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}TINY\PYGZus{}FLUSH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Any timers that have not reached their \sphinxcode{\sphinxupquote{BL\_PROFILE\_VAR\_STOP}} call or exited
their scope and deconstructed will not be included in these partial outputs.
(e.g., a properly instrumented \sphinxcode{\sphinxupquote{main()}} should show a time of zero in all
partial outputs.) Therefore, it is recommended to place these flush calls in
easily identifiable regions of your code and outside of as many profiling
timers as possible, such as immediately before or after writing a checkpoint.

\sphinxAtStartPar
Also, since flush calls will print multiple, similar looking outputs to stdout,
it is also recommended to wrap any \sphinxcode{\sphinxupquote{BL\_PROFILE\_TINY\_FLUSH();}} calls in
informative \sphinxcode{\sphinxupquote{amrex::Print()}} lines to ensure accurate identification of each
set of timers.


\subsection{Full Profiling}
\label{\detokenize{AMReX_Profiling_Tools:full-profiling}}\label{\detokenize{AMReX_Profiling_Tools:sec-full-profiling}}
\sphinxAtStartPar
If you set \sphinxcode{\sphinxupquote{PROFILE = TRUE}} then a \sphinxcode{\sphinxupquote{bl\_prof}} directory will be written that
contains detailed per\sphinxhyphen{}task timings for each processor.  This will be written in
\sphinxcode{\sphinxupquote{nfiles}} files (where \sphinxcode{\sphinxupquote{nfiles}} is specified by the user).  In addition, an
exclusive\sphinxhyphen{}only set of function timings will be written to stdout.


\subsubsection{Trace Profiling}
\label{\detokenize{AMReX_Profiling_Tools:trace-profiling}}\begin{quote}

\sphinxAtStartPar
If, in addition to \sphinxcode{\sphinxupquote{PROFILE = TRUE}}, you set \sphinxcode{\sphinxupquote{TRACE\_PROFILE = TRUE}},
then the profiler keeps track of when each profiled function is called and
the \sphinxcode{\sphinxupquote{bl\_prof}} directory will include the function call stack. This is
especially useful when core functions, such as \sphinxcode{\sphinxupquote{\DUrole{name}{FillBoundary}}} can be
called from many different regions of the code. Part of the trace profiling
is the ability to set regions in the code which can be analyzed for
profiling information independently from other regions.
\end{quote}


\subsubsection{Communication Profiling}
\label{\detokenize{AMReX_Profiling_Tools:communication-profiling}}\begin{quote}

\sphinxAtStartPar
If, in addition to \sphinxcode{\sphinxupquote{PROFILE = TRUE}}, you set \sphinxcode{\sphinxupquote{COMM\_PROFILE = TRUE}}, then
the \sphinxcode{\sphinxupquote{bl\_prof}} directory will contain additional information about MPI
communication (point\sphinxhyphen{}to\sphinxhyphen{}point timings, data volume, barrier/reduction times,
etc.). \sphinxcode{\sphinxupquote{TRACE\_PROFILE = TRUE}} and \sphinxcode{\sphinxupquote{COMM\_PROFILE = TRUE}} can be set
together.
\end{quote}

\sphinxAtStartPar
The AMReX\sphinxhyphen{}specific profiling tools are currently under development and this
documentation will reflect the latest status in the development branch.


\section{Instrumenting C++ Code}
\label{\detokenize{AMReX_Profiling_Tools:instrumenting-c-code}}
\sphinxAtStartPar
You must at least instrument main(), i.e

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Initialize}\PYG{p}{(}\PYG{n}{argc}\PYG{p}{,}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{main()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{pmain}\PYG{p}{)}\PYG{p}{;}

  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

  \PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{pmain}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{amrex}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Finalize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can then instrument any of your functions

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{YourClass::YourFunction}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{YourClass::YourFunction()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{object\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// this name can be any string}

  \PYG{c+c1}{// your function code}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that you do not need to put BL\_PROFILE\_VAR\_STOP because the profiler will
go out of scope at the end of the function.

\sphinxAtStartPar
For other timers within an already instrumented function, add:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Flaten::FORT\PYGZus{}FLATENX()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{anyname}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// add this before}
  \PYG{n}{FORT\PYGZus{}FLATENX}\PYG{p}{(}\PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{anyname}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// add this after, using the same name}
\end{sphinxVerbatim}

\sphinxAtStartPar
if you want to use the same name within the same scope, you can use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyFuncs()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// the first one}
  \PYG{n}{MyFunc\PYGZus{}0}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}START}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MyFunc\PYGZus{}1}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or create a profiling variable without starting, then start/stop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}NS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MyFuncs()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// dont start the timer}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}START}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MyFunc\PYGZus{}0}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}START}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{MyFunc\PYGZus{}1}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{BL\PYGZus{}PROFILE\PYGZus{}VAR\PYGZus{}STOP}\PYG{p}{(}\PYG{n}{myfuncs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Instrumenting Fortran90 Code}
\label{\detokenize{AMReX_Profiling_Tools:instrumenting-fortran90-code}}
\sphinxAtStartPar
When using the full profiler, Fortran90 functions can also be instrumented
with the following calls:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{call }\PYG{n}{bl\PYGZus{}proffortfuncstart}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}my\PYGZus{}function\PYGZdq{}}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{call }\PYG{n}{bl\PYGZus{}proffortfuncstop}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}my\PYGZus{}function\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the start and stop calls must be matched and the profiling output
will warn of any \sphinxcode{\sphinxupquote{\DUrole{name}{bl\_proffortfuncstart}}} calls that were not stopped
with \sphinxcode{\sphinxupquote{\DUrole{name}{bl\_proffortfuncstop}}} calls (in debug mode only). You will need
to add \sphinxcode{\sphinxupquote{\DUrole{name}{bl\_proffortfuncstop}}} before any returns and at the end of the
function or at the point in the function you want to stop profiling.

\sphinxAtStartPar
For functions with a high number of calls, there is a lighter\sphinxhyphen{}weight interface:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{call }\PYG{n}{bl\PYGZus{}proffortfuncstart\PYGZus{}int}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{call }\PYG{n}{bl\PYGZus{}proffortfuncstop\PYGZus{}int}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{n}} is an integer in the range \sphinxcode{\sphinxupquote{{[}1,mFortProfsIntMaxFuncs{]}}}.
\sphinxcode{\sphinxupquote{mFortProfsIntMaxFuncs}} is currently set to 32.  The profiled
function will be named \sphinxcode{\sphinxupquote{FORTFUNC\_n}} in the profiler output,
unless you rename it with \sphinxcode{\sphinxupquote{BL\_PROFILE\_CHANGE\_FORT\_INT\_NAME(fname, int)}}
where \sphinxcode{\sphinxupquote{fname}} is a std::string and \sphinxcode{\sphinxupquote{int}} is the integer \sphinxcode{\sphinxupquote{n}}
in the \sphinxcode{\sphinxupquote{bl\_proffortfuncstart\_int/bl\_proffortfuncstop\_int}} calls.
\sphinxcode{\sphinxupquote{BL\_PROFILE\_CHANGE\_FORT\_INT\_NAME}} should be called in \sphinxcode{\sphinxupquote{main()}}.

\sphinxAtStartPar
Be aware: Fortran functions cannot be profiled when using the Tiny Profiler.
You will need to turn on the full profiler to receive the results from
fortran instrumentation.


\section{Sample Output From Tiny Profile}
\label{\detokenize{AMReX_Profiling_Tools:sample-output-from-tiny-profile}}\label{\detokenize{AMReX_Profiling_Tools:sec-sample-tiny}}
\sphinxAtStartPar
Sample output using \sphinxcode{\sphinxupquote{TINY\_PROFILE = TRUE}} can look like the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{TinyProfiler total time across processes [min...avg...max]: 1.765...1.765...1.765}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Name                          NCalls   Excl. Min   Excl. Avg   Excl. Max   Max  \PYGZpc{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{mfix\PYGZus{}level::EvolveFluid       1        1.602       1.668       1.691       95.83\PYGZpc{}}
\PYG{g+go}{FabArray::FillBoundary()      11081    0.02195     0.03336     0.06617      3.75\PYGZpc{}}
\PYG{g+go}{FabArrayBase::getFB()         22162    0.02031     0.02147     0.02275      1.29\PYGZpc{}}
\PYG{g+go}{PC\PYGZlt{}...\PYGZgt{}::WriteAsciiFile()     1        0.00292     0.004072    0.004551     0.26\PYGZpc{}}


\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{Name                          NCalls   Incl. Min   Incl. Avg  Incl. Max    Max  \PYGZpc{}}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{mfix\PYGZus{}level::Evolve()          1        1.69        1.723      1.734        98.23\PYGZpc{}}
\PYG{g+go}{mfix\PYGZus{}level::EvolveFluid       1        1.69        1.723      1.734        98.23\PYGZpc{}}
\PYG{g+go}{FabArray::FillBoundary()      11081    0.04236     0.05485    0.08826       5.00\PYGZpc{}}
\PYG{g+go}{FabArrayBase::getFB()         22162    0.02031     0.02149    0.02275       1.29\PYGZpc{}}
\end{sphinxVerbatim}


\section{AMRProfParser}
\label{\detokenize{AMReX_Profiling_Tools:amrprofparser}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\DUrole{name}{AMRProfParser}}} is a tool for processing and analyzing the \sphinxcode{\sphinxupquote{bl\_prof}}
database. It is a command line application that can create performance
summaries, plotfiles showing point to point communication and timelines, HTML
call trees, communication call statistics, function timing graphs, and other
data products. The parser’s data services functionality can be called from an
interactive environment such as Amrvis, from a sidecar for dynamic performance
optimization, and from other utilities such as the command line version of the
parser itself. It has been integrated into Amrvis for visual interpretation of
the data allowing Amrvis to open the bl\_prof database like a plotfile but with
interfaces appropriate to profiling data. AMRProfParser and Amrvis can be run
in parallel both interactively and in batch mode.


\chapter{External Profiling Tools}
\label{\detokenize{External_Profiling_Tools_Chapter:external-profiling-tools}}\label{\detokenize{External_Profiling_Tools_Chapter:chap-external-profiling-tools}}\label{\detokenize{External_Profiling_Tools_Chapter::doc}}
\sphinxAtStartPar
AMReX is compatible with most commonly used profiling tools. This chapter provides some
selected useful documentation on implementing a few of these tools on AMReX. For additional
details on running these tools, please refer to the official documentation of the tools.


\section{CrayPat}
\label{\detokenize{External_Profiling_Tools:craypat}}\label{\detokenize{External_Profiling_Tools::doc}}
\sphinxAtStartPar
The profiling suite available on Cray XC systems is Cray Performance
Measurement and Analysis Tools (“CrayPat”) \sphinxstepexplicit %
\begin{footnote}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
\sphinxurl{https://pubs.cray.com/content/S-2376/6.4.6/cray-performance-measurement-and-analysis-tools-user-guide-646-s-2376}
%
\end{footnote}.  Most CrayPat functionality is
supported for all compilers available in the Cray “programming environments”
(modules which begin “\sphinxcode{\sphinxupquote{PrgEnv\sphinxhyphen{}}}“); however, a few features, chiefly the
“Reveal” tool, are supported only on applications compiled with Cray’s compiler
CCE \sphinxstepexplicit %
\begin{footnote}[2]\phantomsection\label{\thesphinxscope.2}%
\sphinxAtStartFootnote
\sphinxurl{https://pubs.cray.com/content/S-2179/8.5/cray-c-and-c++-reference-manual-85}
%
\end{footnote} \sphinxstepexplicit %
\begin{footnote}[3]\phantomsection\label{\thesphinxscope.3}%
\sphinxAtStartFootnote
\sphinxurl{https://pubs.cray.com/content/S-3901/8.5/cray-fortran-reference-manual-85}
%
\end{footnote}.

\sphinxAtStartPar
CrayPat supports both high\sphinxhyphen{}level profiling tools, as well as fine\sphinxhyphen{}grained
performance analysis, such as reading hardware counters. The default behavior
uses sampling to identify the most time\sphinxhyphen{}consuming functions in an application.


\subsection{High\sphinxhyphen{}level application profiling}
\label{\detokenize{External_Profiling_Tools:high-level-application-profiling}}
\sphinxAtStartPar
The simplest way to obtain a high\sphinxhyphen{}level overview of an application’s
performance consists of the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Load the \sphinxcode{\sphinxupquote{perftools\sphinxhyphen{}base}} module, then the \sphinxcode{\sphinxupquote{perftools\sphinxhyphen{}lite}} module. (The
modules will not work if loaded in the opposite order.)

\item {} 
\sphinxAtStartPar
Compile the application with the Cray compiler wrappers \sphinxcode{\sphinxupquote{cc}}, \sphinxcode{\sphinxupquote{CC}},
and/or \sphinxcode{\sphinxupquote{ftn}}. This works with any of the compilers available in the
\sphinxcode{\sphinxupquote{PrgEnv\sphinxhyphen{}}} modules. E.g., on the Cori system at NERSC, one can use the
Intel, GCC, or CCE compilers. No extra compiler flags are necessary in order
for CrayPat to work. CrayPat instruments the application, so the
\sphinxcode{\sphinxupquote{perftools\sphinxhyphen{}}} modules must be loaded before one compiles the application.

\item {} 
\sphinxAtStartPar
Run the application as normal. No special flags are required. Upon
application completion, CrayPat will write a few files to the directory from
which the application was launched. The profiling database is a single file
with the \sphinxcode{\sphinxupquote{.ap2}} suffix.

\item {} 
\sphinxAtStartPar
One can query the database in many different ways using the \sphinxcode{\sphinxupquote{pat\_report}}
command on the \sphinxcode{\sphinxupquote{.ap2}} file. \sphinxcode{\sphinxupquote{pat\_report}} is available on login nodes, so
the analysis need not be done on a compute node.  Querying the database with
no arguments to \sphinxcode{\sphinxupquote{pat\_report}} prints several different profiling reports to
STDOUT, including a list of the most time\sphinxhyphen{}consuming regions in the
application. The output of this command can be long, so it can be convenient
to pipe the output to a pager or a file. A portion of the output from
\sphinxcode{\sphinxupquote{pat\_report \textless{}file\textgreater{}.ap2}} is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Table} \PYG{l+m+mi}{1}\PYG{p}{:}  \PYG{n}{Profile} \PYG{n}{by} \PYG{n}{Function}

  \PYG{n}{Samp}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{n}{Samp} \PYG{o}{|}  \PYG{n}{Imb}\PYG{o}{.} \PYG{o}{|}  \PYG{n}{Imb}\PYG{o}{.} \PYG{o}{|} \PYG{n}{Group}
        \PYG{o}{|}         \PYG{o}{|}  \PYG{n}{Samp} \PYG{o}{|} \PYG{n}{Samp}\PYG{o}{\PYGZpc{}} \PYG{o}{|}  \PYG{n}{Function}
        \PYG{o}{|}         \PYG{o}{|}       \PYG{o}{|}       \PYG{o}{|}   \PYG{n}{PE}\PYG{o}{=}\PYG{n}{HIDE}

 \PYG{l+m+mf}{100.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mf}{235.5} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|} \PYG{n}{Total}
\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}  \PYG{l+m+mf}{50.2}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{628.5} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|} \PYG{n}{USER}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{7.3}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{383.0} \PYG{o}{|}  \PYG{l+m+mf}{15.0} \PYG{o}{|}  \PYG{l+m+mf}{5.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{eos\PYGZus{}module\PYGZus{}mp\PYGZus{}iterate\PYGZus{}ne\PYGZus{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{5.7}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{300.8} \PYG{o}{|} \PYG{l+m+mf}{138.2} \PYG{o}{|} \PYG{l+m+mf}{42.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{amrex\PYGZus{}deposit\PYGZus{}cic}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{5.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{265.2} \PYG{o}{|}  \PYG{l+m+mf}{79.8} \PYG{o}{|} \PYG{l+m+mf}{30.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{update\PYGZus{}dm\PYGZus{}particles}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{147.2} \PYG{o}{|}   \PYG{l+m+mf}{5.8} \PYG{o}{|}  \PYG{l+m+mf}{5.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{fort\PYGZus{}fab\PYGZus{}setval}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.6}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{137.2} \PYG{o}{|}  \PYG{l+m+mf}{48.8} \PYG{o}{|} \PYG{l+m+mf}{34.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{amrex}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Where}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.6}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{137.0} \PYG{o}{|}  \PYG{l+m+mf}{11.0} \PYG{o}{|}  \PYG{l+m+mf}{9.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{ppm\PYGZus{}module\PYGZus{}mp\PYGZus{}ppm\PYGZus{}type1\PYGZus{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.5}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{133.0} \PYG{o}{|}  \PYG{l+m+mf}{24.0} \PYG{o}{|} \PYG{l+m+mf}{20.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{eos\PYGZus{}module\PYGZus{}mp\PYGZus{}nyx\PYGZus{}eos\PYGZus{}t\PYGZus{}given\PYGZus{}re\PYGZus{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{107.8} \PYG{o}{|}  \PYG{l+m+mf}{33.2} \PYG{o}{|} \PYG{l+m+mf}{31.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{amrex}\PYG{p}{:}\PYG{p}{:}\PYG{n}{ParticleContainer}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{IncrementWithTotal}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{1.7}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{89.2} \PYG{o}{|}  \PYG{l+m+mf}{19.8} \PYG{o}{|} \PYG{l+m+mf}{24.2}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{f\PYGZus{}rhs\PYGZus{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{1.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{74.0} \PYG{o}{|}   \PYG{l+m+mf}{7.0} \PYG{o}{|} \PYG{l+m+mf}{11.5}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{riemannus\PYGZus{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{1.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{56.0} \PYG{o}{|}   \PYG{l+m+mf}{2.0} \PYG{o}{|}  \PYG{l+m+mf}{4.6}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{amrex}\PYG{p}{:}\PYG{p}{:}\PYG{n}{VisMF}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Write}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{1.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{50.5} \PYG{o}{|}   \PYG{l+m+mf}{1.5} \PYG{o}{|}  \PYG{l+m+mf}{3.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{amrex}\PYG{p}{:}\PYG{p}{:}\PYG{n}{VisMF}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Header}\PYG{p}{:}\PYG{p}{:}\PYG{n}{CalculateMinMax}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{|}  \PYG{l+m+mf}{28.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{471.0} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|} \PYG{n}{ETC}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{7.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{388.8} \PYG{o}{|}  \PYG{l+m+mf}{10.2} \PYG{o}{|}  \PYG{l+m+mf}{3.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{\PYGZus{}\PYGZus{}intel\PYGZus{}mic\PYGZus{}avx512f\PYGZus{}memcpy}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{6.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{362.5} \PYG{o}{|}  \PYG{l+m+mf}{45.5} \PYG{o}{|} \PYG{l+m+mf}{14.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{CVode}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{3.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{164.5} \PYG{o}{|}   \PYG{l+m+mf}{8.5} \PYG{o}{|}  \PYG{l+m+mf}{6.6}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{\PYGZus{}\PYGZus{}libm\PYGZus{}log10\PYGZus{}l9}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{149.8} \PYG{o}{|}  \PYG{l+m+mf}{29.2} \PYG{o}{|} \PYG{l+m+mf}{21.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{\PYGZus{}INTERNAL\PYGZus{}25\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}src\PYGZus{}kmp\PYGZus{}barrier\PYGZus{}cpp\PYGZus{}5de9139b}\PYG{p}{:}\PYG{p}{:}\PYG{n}{\PYGZus{}\PYGZus{}kmp\PYGZus{}hyper\PYGZus{}barrier\PYGZus{}gather}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{|}  \PYG{l+m+mf}{16.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{879.8} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|} \PYG{n}{MPI}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{5.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{266.0} \PYG{o}{|} \PYG{l+m+mf}{123.0} \PYG{o}{|} \PYG{l+m+mf}{42.2}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{MPI\PYGZus{}Allreduce}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{4.2}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{218.2} \PYG{o}{|} \PYG{l+m+mf}{104.8} \PYG{o}{|} \PYG{l+m+mf}{43.2}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{MPI\PYGZus{}Waitall}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{151.8} \PYG{o}{|}  \PYG{l+m+mf}{78.2} \PYG{o}{|} \PYG{l+m+mf}{45.4}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{MPI\PYGZus{}Bcast}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.6}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{135.0} \PYG{o}{|}  \PYG{l+m+mf}{98.0} \PYG{o}{|} \PYG{l+m+mf}{56.1}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{MPI\PYGZus{}Barrier}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{2.0}\PYG{o}{\PYGZpc{}} \PYG{o}{|}   \PYG{l+m+mf}{105.8} \PYG{o}{|}   \PYG{l+m+mf}{5.2} \PYG{o}{|}  \PYG{l+m+mf}{6.3}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{MPI\PYGZus{}Recv}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\PYG{o}{|}   \PYG{l+m+mf}{1.9}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{98.2} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|}    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{|} \PYG{n}{IO}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{|}\PYG{o}{|}   \PYG{l+m+mf}{1.8}\PYG{o}{\PYGZpc{}} \PYG{o}{|}    \PYG{l+m+mf}{93.8} \PYG{o}{|}   \PYG{l+m+mf}{6.2} \PYG{o}{|}  \PYG{l+m+mf}{8.3}\PYG{o}{\PYGZpc{}} \PYG{o}{|} \PYG{n}{read}
\PYG{o}{|}\PYG{o}{|}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}\PYG{o}{==}
\end{sphinxVerbatim}

\end{enumerate}


\section{IPM \sphinxhyphen{} Cross\sphinxhyphen{}Platform Integrated Performance Monitoring}
\label{\detokenize{External_Profiling_Tools:ipm-cross-platform-integrated-performance-monitoring}}
\sphinxAtStartPar
IPM provides portable profiling capabilities across HPC platforms, including
support on selected Cray and IBM machines (cori and (TODO: verify it works on)
summit). Running an IPM instrumented binary generates a summary of number of
calls and time spent on MPI communication library functions. In addition,
hardware performance counters can also be collected through PAPI.

\sphinxAtStartPar
Detailed instructions can be found at  \sphinxstepexplicit %
\begin{footnote}[4]\phantomsection\label{\thesphinxscope.4}%
\sphinxAtStartFootnote
\sphinxurl{http://ipm-hpc.sourceforge.net/userguide.html}
%
\end{footnote} and \sphinxstepexplicit %
\begin{footnote}[5]\phantomsection\label{\thesphinxscope.5}%
\sphinxAtStartFootnote
\sphinxurl{https://www.nersc.gov/users/software/performance-and-debugging-tools/ipm/}
%
\end{footnote}.


\subsection{Building with IPM on cori}
\label{\detokenize{External_Profiling_Tools:building-with-ipm-on-cori}}
\sphinxAtStartPar
Steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Run module load ipm.

\item {} 
\sphinxAtStartPar
Build code as normal with make.

\item {} 
\sphinxAtStartPar
Re\sphinxhyphen{}run the link command (e.g. cut\sphinxhyphen{}and\sphinxhyphen{}paste) with \sphinxcode{\sphinxupquote{\$IPM}} added to the end of the line.

\end{enumerate}


\subsection{Running with IPM on cori}
\label{\detokenize{External_Profiling_Tools:running-with-ipm-on-cori}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Set environment variables: \sphinxcode{\sphinxupquote{export IPM\_REPORT=full IPM\_LOG=full IPM\_LOGDIR= \textless{}dir\textgreater{}}}

\item {} 
\sphinxAtStartPar
Results will be printed to stdout and an xml file generated in the directory specified by \sphinxcode{\sphinxupquote{IPM\_LOGDIR}}.

\item {} 
\sphinxAtStartPar
Post\sphinxhyphen{}process the xml with \sphinxcode{\sphinxupquote{ipm\_parse \sphinxhyphen{}html \textless{}xmlfile\textgreater{}}}, which produces an directory with html.

\end{enumerate}


\subsection{Summary MPI Profile}
\label{\detokenize{External_Profiling_Tools:summary-mpi-profile}}
\sphinxAtStartPar
Example MPI profile output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZsh{}}\PYG{c+c1}{\PYGZsh{}IPMv2.0.5\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{g+gp}{\PYGZsh{}}
\PYG{g+gp}{\PYGZsh{} }\PYG{n+nb}{command}   : /global/cscratch1/sd/cchan2/projects/lbl/BoxLib/Tests/LinearSolvers/C\PYGZus{}CellMG/./main3d.intel.MPI.OMP.ex.ipm inputs.3d.25600
\PYG{g+gp}{\PYGZsh{} }start     : Tue Aug \PYG{l+m}{15} \PYG{l+m}{17}:34:23 \PYG{l+m}{2017}   host      : nid11311
\PYG{g+gp}{\PYGZsh{} }stop      : Tue Aug \PYG{l+m}{15} \PYG{l+m}{17}:34:35 \PYG{l+m}{2017}   wallclock : \PYG{l+m}{11}.54
\PYG{g+gp}{\PYGZsh{} }mpi\PYGZus{}tasks : \PYG{l+m}{128} on \PYG{l+m}{32} nodes            \PYGZpc{}comm     : \PYG{l+m}{32}.51
\PYG{g+gp}{\PYGZsh{} }mem \PYG{o}{[}GB\PYG{o}{]}  : \PYG{l+m}{126}.47                     gflop/sec : \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{}}
\PYG{g+gp}{\PYGZsh{}           }:       \PYG{o}{[}total\PYG{o}{]}        \PYGZlt{}avg\PYGZgt{}          min          max
\PYG{g+gp}{\PYGZsh{} }wallclock :       \PYG{l+m}{1188}.42         \PYG{l+m}{9}.28         \PYG{l+m}{8}.73        \PYG{l+m}{11}.54
\PYG{g+gp}{\PYGZsh{} }MPI       :        \PYG{l+m}{386}.31         \PYG{l+m}{3}.02         \PYG{l+m}{2}.51         \PYG{l+m}{4}.78
\PYG{g+gp}{\PYGZsh{} }\PYGZpc{}wall     :
\PYG{g+gp}{\PYGZsh{}   }MPI     :                      \PYG{l+m}{32}.52        \PYG{l+m}{24}.36        \PYG{l+m}{41}.44
\PYG{g+gp}{\PYGZsh{} }\PYG{c+c1}{\PYGZsh{}calls    :}
\PYG{g+gp}{\PYGZsh{}   }MPI     :       \PYG{l+m}{5031172}        \PYG{l+m}{39306}        \PYG{l+m}{23067}        \PYG{l+m}{57189}
\PYG{g+gp}{\PYGZsh{} }mem \PYG{o}{[}GB\PYG{o}{]}  :        \PYG{l+m}{126}.47         \PYG{l+m}{0}.99         \PYG{l+m}{0}.98         \PYG{l+m}{1}.00
\PYG{g+gp}{\PYGZsh{}}
\PYG{g+gp}{\PYGZsh{}                             }\PYG{o}{[}time\PYG{o}{]}        \PYG{o}{[}count\PYG{o}{]}        \PYGZlt{}\PYGZpc{}wall\PYGZgt{}
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Allreduce               \PYG{l+m}{225}.72         \PYG{l+m}{567552}          \PYG{l+m}{18}.99
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Waitall                  \PYG{l+m}{92}.84         \PYG{l+m}{397056}           \PYG{l+m}{7}.81
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Recv                     \PYG{l+m}{29}.36            \PYG{l+m}{193}           \PYG{l+m}{2}.47
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Isend                    \PYG{l+m}{25}.04        \PYG{l+m}{2031810}           \PYG{l+m}{2}.11
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Irecv                     \PYG{l+m}{4}.35        \PYG{l+m}{2031810}           \PYG{l+m}{0}.37
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Allgather                 \PYG{l+m}{2}.60            \PYG{l+m}{128}           \PYG{l+m}{0}.22
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Barrier                   \PYG{l+m}{2}.24            \PYG{l+m}{512}           \PYG{l+m}{0}.19
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Gatherv                   \PYG{l+m}{1}.70            \PYG{l+m}{128}           \PYG{l+m}{0}.14
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Comm\PYGZus{}dup                  \PYG{l+m}{1}.23            \PYG{l+m}{256}           \PYG{l+m}{0}.10
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Bcast                     \PYG{l+m}{1}.14            \PYG{l+m}{256}           \PYG{l+m}{0}.10
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Send                      \PYG{l+m}{0}.06            \PYG{l+m}{319}           \PYG{l+m}{0}.01
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Reduce                    \PYG{l+m}{0}.02            \PYG{l+m}{128}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Comm\PYGZus{}free                 \PYG{l+m}{0}.01            \PYG{l+m}{128}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Comm\PYGZus{}group                \PYG{l+m}{0}.00            \PYG{l+m}{128}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Comm\PYGZus{}size                 \PYG{l+m}{0}.00            \PYG{l+m}{256}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Comm\PYGZus{}rank                 \PYG{l+m}{0}.00            \PYG{l+m}{256}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Init                      \PYG{l+m}{0}.00            \PYG{l+m}{128}           \PYG{l+m}{0}.00
\PYG{g+gp}{\PYGZsh{} }MPI\PYGZus{}Finalize                  \PYG{l+m}{0}.00            \PYG{l+m}{128}           \PYG{l+m}{0}.00
\end{sphinxVerbatim}

\sphinxAtStartPar
The total, average, minimum, and maximum wallclock and MPI times across ranks
is shown.  The memory footprint is also collected.  Finally, results include
number of calls and total time spent in each type of MPI call.


\subsection{PAPI Performance Counters}
\label{\detokenize{External_Profiling_Tools:papi-performance-counters}}
\sphinxAtStartPar
To collect performance counters, set \sphinxcode{\sphinxupquote{IPM\_HPM=\textless{}list\textgreater{}}}, where the list is a
comma\sphinxhyphen{}separated list of PAPI counters. For example: \sphinxcode{\sphinxupquote{export
IPM\_HPM=PAPI\_L2\_TCA,PAPI\_L2\_TCM}}.

\sphinxAtStartPar
For reference, here is the list of available counters on cori, which can be
found by running \sphinxcode{\sphinxupquote{papi\_avail}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{    Name        Code    Avail Deriv Description (Note)}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}DCM  0x80000000  Yes   No   Level 1 data cache misses}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}ICM  0x80000001  Yes   No   Level 1 instruction cache misses}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}TCM  0x80000006  Yes   Yes  Level 1 cache misses}
\PYG{g+go}{PAPI\PYGZus{}L2\PYGZus{}TCM  0x80000007  Yes   No   Level 2 cache misses}
\PYG{g+go}{PAPI\PYGZus{}TLB\PYGZus{}DM  0x80000014  Yes   No   Data translation lookaside buffer misses}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}LDM  0x80000017  Yes   No   Level 1 load misses}
\PYG{g+go}{PAPI\PYGZus{}L2\PYGZus{}LDM  0x80000019  Yes   No   Level 2 load misses}
\PYG{g+go}{PAPI\PYGZus{}STL\PYGZus{}ICY 0x80000025  Yes   No   Cycles with no instruction issue}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}UCN  0x8000002a  Yes   Yes  Unconditional branch instructions}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}CN   0x8000002b  Yes   No   Conditional branch instructions}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}TKN  0x8000002c  Yes   No   Conditional branch instructions taken}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}NTK  0x8000002d  Yes   Yes  Conditional branch instructions not taken}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}MSP  0x8000002e  Yes   No   Conditional branch instructions mispredicted}
\PYG{g+go}{PAPI\PYGZus{}TOT\PYGZus{}INS 0x80000032  Yes   No   Instructions completed}
\PYG{g+go}{PAPI\PYGZus{}LD\PYGZus{}INS  0x80000035  Yes   No   Load instructions}
\PYG{g+go}{PAPI\PYGZus{}SR\PYGZus{}INS  0x80000036  Yes   No   Store instructions}
\PYG{g+go}{PAPI\PYGZus{}BR\PYGZus{}INS  0x80000037  Yes   No   Branch instructions}
\PYG{g+go}{PAPI\PYGZus{}RES\PYGZus{}STL 0x80000039  Yes   No   Cycles stalled on any resource}
\PYG{g+go}{PAPI\PYGZus{}TOT\PYGZus{}CYC 0x8000003b  Yes   No   Total cycles}
\PYG{g+go}{PAPI\PYGZus{}LST\PYGZus{}INS 0x8000003c  Yes   Yes  Load/store instructions completed}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}DCA  0x80000040  Yes   Yes  Level 1 data cache accesses}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}ICH  0x80000049  Yes   No   Level 1 instruction cache hits}
\PYG{g+go}{PAPI\PYGZus{}L1\PYGZus{}ICA  0x8000004c  Yes   No   Level 1 instruction cache accesses}
\PYG{g+go}{PAPI\PYGZus{}L2\PYGZus{}TCH  0x80000056  Yes   Yes  Level 2 total cache hits}
\PYG{g+go}{PAPI\PYGZus{}L2\PYGZus{}TCA  0x80000059  Yes   No   Level 2 total cache accesses}
\PYG{g+go}{PAPI\PYGZus{}REF\PYGZus{}CYC 0x8000006b  Yes   No   Reference clock cycles}
\end{sphinxVerbatim}

\sphinxAtStartPar
Due to hardware limitations, there is a limit to which counters can be
collected simultaneously in a single run. Some counters may map to the same
registers and thus cannot be collected at the same time.


\subsection{Example HTML Performance Summary}
\label{\detokenize{External_Profiling_Tools:example-html-performance-summary}}
\sphinxAtStartPar
Running \sphinxcode{\sphinxupquote{ipm\_parse \sphinxhyphen{}html \textless{}xmlfile\textgreater{}}} on the generated xml file will produce an
HTML document that includes summary performance numbers and automatically
generated figures. Some examples are shown here.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{summary}.png}
\caption{Sample performance summary generated by IPM}\label{\detokenize{External_Profiling_Tools:id11}}\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{timings}.png}
\end{figure}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Example of performance graphs generated by IPM}\label{\detokenize{External_Profiling_Tools:id12}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{timings}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{papi}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] Timings
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] PAPI Counters
\end{DUlineblock}
\\
\hline
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{mpi}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{msgsizes}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] MPI Time by Function
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] MPI Time by Message Size
\end{DUlineblock}
\\
\hline
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{commtopo}.png}
&
\begin{DUlineblock}{0em}
\item[] (left) Point\sphinxhyphen{}to\sphinxhyphen{}Point Communication Volume
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Nsight Systems}
\label{\detokenize{External_Profiling_Tools:nsight-systems}}
\sphinxAtStartPar
The Nsight Systems tool provides a high\sphinxhyphen{}level overview of your code, displaying the kernel
launches, API calls, NVTX regions and more in a timeline for a clear, visual picture of the
overall runtime patterns.  It analyzes CPU\sphinxhyphen{}codes or CUDA\sphinxhyphen{}based GPU codes and is available
on Summit and Cori in a system module.

\sphinxAtStartPar
Nsight Systems provides a variety of profiling options.  This documentation will cover the
most commonly used options for AMReX users to keep track of useful flags and analysis
patterns. For the complete details of using Nsight Systems, refer to the \sphinxhref{https://docs.nvidia.com/nsight-systems/index.html}{Nsight Systems
official documentation}.


\subsection{Profile Analysis}
\label{\detokenize{External_Profiling_Tools:profile-analysis}}
\sphinxAtStartPar
The most common use case of Nsight Systems for AMReX users is the creation of a qdrep file
that is viewed in the Nsight Systems GUI, typically on a local workstation or machine.

\sphinxAtStartPar
To generate a qdrep file, run nsys with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{nsys profile \PYGZhy{}o \PYGZlt{}file\PYGZus{}name\PYGZgt{} \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
AMReX’s lambda\sphinxhyphen{}based launch system often makes these timelines difficult to parse, as the kernel
are mangled and are difficult to decipher. AMReX’s Tiny Profiler includes NVTX region markers,
which can be used to mark the respective section of the Nsight Systems timeline.  To include AMReX’s
built\sphinxhyphen{}in Tiny Profiler NVTX regions in Nsight Systems outputs, compile AMReX with \sphinxcode{\sphinxupquote{TINY\_PROFILE=TRUE}}.

\sphinxAtStartPar
Nsight Systems timelines only profile a single, contiguous block of time. There are a variety of
methods to specify the specific region you would like to analyze. The most common options that AMReX users
may find helpful are:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Specify an NVTX region as the starting point of the analysis.}

\end{enumerate}

\sphinxAtStartPar
This is done using \sphinxcode{\sphinxupquote{\sphinxhyphen{}c nvtx \sphinxhyphen{}p "region\_name@*" \sphinxhyphen{}e NSYS\_NVTX\_PROFILER\_REGISTER\_ONLY=0}}, where \sphinxcode{\sphinxupquote{region\_name}}
is the identification string for the of the NVTX region. The additional environment variable,
\sphinxcode{\sphinxupquote{\sphinxhyphen{}e ...}} is needed because AMReX’s NVTX region names currently do not use a registered string.
TinyProfiler’s built\sphinxhyphen{}in NVTX regions use the same identification string as the timer itself. For
example, to start an analysis at the \sphinxcode{\sphinxupquote{do\_hydro}} NVTX region, run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{nsys profile \PYGZhy{}o \PYGZlt{}file\PYGZus{}name\PYGZgt{} \PYGZhy{}c nvtx \PYGZhy{}p \PYGZdq{}do\PYGZus{}hydro@*\PYGZdq{} \PYGZhy{}e NSYS\PYGZus{}NVTX\PYGZus{}PROFILER\PYGZus{}REGISTER\PYGZus{}ONLY=0 \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will profile from the first instance of the specified NVTX region until the end of the
application.  In AMReX applications, this can be helpful to skip initialization and analyze the
remainder of the code.  To only analyze the specified NVTX region, add the flag \sphinxcode{\sphinxupquote{\sphinxhyphen{}x true}}, which
will end the analysis at the end of the region:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{nsys profile \PYGZhy{}o \PYGZlt{}file\PYGZus{}name\PYGZgt{} \PYGZhy{}c nvtx \PYGZhy{}p \PYGZdq{}do\PYGZus{}hydro@*\PYGZdq{} \PYGZhy{}x true \PYGZhy{}e NSYS\PYGZus{}NVTX\PYGZus{}PROFILER\PYGZus{}REGISTER\PYGZus{}ONLY=0 \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again, it’s important to remember that Nsight Systems only analyzes a single contiguous block of
time. So, this will only give you a profile for the first instance of the named region.  Plan your
Nsight System analyses accordingly.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Specify a region with cuda profiler function calls.}

\end{enumerate}

\sphinxAtStartPar
This requires manually altering your source code, but can provide better specificity in what you analyze.
Directly insert \sphinxcode{\sphinxupquote{cudaProfilerStart\textbackslash{}Stop}} around the region of code you want to analyze:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cudaProfilerStart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// CODE TO PROFILE}

\PYG{n}{cudaProfilerStop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, run with \sphinxcode{\sphinxupquote{\sphinxhyphen{}c cudaProfilerApi}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{nsys profile \PYGZhy{}o \PYGZlt{}file\PYGZus{}name\PYGZgt{} \PYGZhy{}c cudaProfilerApi \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
As with NVTX regions, Nsight Systems will only profile from the first call to \sphinxcode{\sphinxupquote{cudaProfilerStart()}}
to the first call to \sphinxcode{\sphinxupquote{cudaProfilerStop()}}, so be sure to add these markers appropriately.


\subsection{Nsight Systems GUI Tips}
\label{\detokenize{External_Profiling_Tools:nsight-systems-gui-tips}}\begin{itemize}
\item {} 
\sphinxAtStartPar
When analyzing an AMReX application in the Nsight Systems GUI using NVTX regions or \sphinxcode{\sphinxupquote{TINY\_PROFILE=TRUE}},
AMReX users may find it useful to turn on the feature “Rename CUDA Kernels by NVTX”. This will change the
CUDA kernel names to match the inner\sphinxhyphen{}most NVTX region in which they were launched instead of the typical
mangled compiler name. This will make identifying AMReX CUDA kernels in Nsight Systems reports considerably easier.

\sphinxAtStartPar
This feature can be found in the GUI’s drop down menu, under:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{Tools \PYGZhy{}\PYGZgt{} Options \PYGZhy{}\PYGZgt{} Environment \PYGZhy{}\PYGZgt{} Rename CUDA Kernels by NVTX.}
\end{sphinxVerbatim}


\section{Nsight Compute}
\label{\detokenize{External_Profiling_Tools:nsight-compute}}
\sphinxAtStartPar
The Nsight Compute tool provides a detailed, fine\sphinxhyphen{}grained analysis of your CUDA kernels,
giving details about the kernel launch, occupancy, and limitations while suggesting possible
improvements to maximize the use of the GPU.  It analyzes CUDA\sphinxhyphen{}based GPU codes and is available
on Summit and Cori in system modules.

\sphinxAtStartPar
Nsight Compute provides a variety of profiling options.  This documentation will focus on the
most commonly used options for AMReX users, primarily to keep track of useful flags and analysis
patterns.  For the complete details of using Nsight Compute, refer to the \sphinxhref{https://docs.nvidia.com/nsight-compute/index.html}{Nsight compute
official documentation}.


\subsection{Kernel Analysis}
\label{\detokenize{External_Profiling_Tools:kernel-analysis}}
\sphinxAtStartPar
The standard way to run Nsight Compute on an AMReX application is to specify an output file
that will be transferred to a local workstation of machine for viewing in the Nsight Compute GUI.
Nsight Compute can be told to return a report file using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}} flag. In addition, when
running with Nsight compute on an AMReX application, it is important to turn off the floating
point exception trap, as it causes a runtime error.  So, an entire AMReX application can be
analyzed with Nsight Compute by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ncu \PYGZhy{}o \PYGZlt{}file\PYGZus{}name\PYGZgt{} \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{} amrex.fpe\PYGZus{}trap\PYGZus{}invalid=0}
\end{sphinxVerbatim}

\sphinxAtStartPar
However, this implementation should almost never used by AMReX applications, as the analysis of
every kernel would be  extremely lengthy and unnecessary.  To analyze a desired subset of CUDA
kernels, AMReX users can use the Tiny Profiler’s built\sphinxhyphen{}in NVTX regions to narrow the scope of
the analysis.  Nsight Compute allows users to specify which NVTX regions to include and exclude
through the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nvtx}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nvtx\sphinxhyphen{}include}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nvtx\sphinxhyphen{}exclude}} flags. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ncu \PYGZhy{}\PYGZhy{}nvtx \PYGZhy{}\PYGZhy{}nvtx\PYGZhy{}include \PYGZdq{}Hydro()\PYGZdq{} \PYGZhy{}\PYGZhy{}nvtx\PYGZhy{}exclude \PYGZdq{}StencilA(),StencilC()\PYGZdq{} \PYGZhy{}o kernels \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{} amrex.fpe\PYGZus{}trap\PYGZus{}invalid=0}
\end{sphinxVerbatim}

\sphinxAtStartPar
will return a file named \sphinxcode{\sphinxupquote{kernels}} which contains an analysis of the CUDA kernels launched inside
the \sphinxcode{\sphinxupquote{Hydro()}} region, ignoring any kernels launched inside \sphinxcode{\sphinxupquote{StencilA()}} and \sphinxcode{\sphinxupquote{StencilC()}}.
When using the NVTX regions built into AMReX’s TinyProfiler, be aware that the application must be built
with \sphinxcode{\sphinxupquote{TINY\_PROFILE=TRUE}} and the NVTX region names are identical to the TinyProfiler timer names.

\sphinxAtStartPar
Another helpful flag for selecting a reasonable subset of kernels for analysis is the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c}} option. This
flag specifies the total number of kernels to be analyzed. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ncu \PYGZhy{}\PYGZhy{}nvtx \PYGZhy{}\PYGZhy{}nvtx\PYGZhy{}include \PYGZdq{}GravitySolve()\PYGZdq{} \PYGZhy{}c 10 \PYGZhy{}o kernels \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{} amrex.fpe\PYGZus{}trap\PYGZus{}invalid=0}
\end{sphinxVerbatim}

\sphinxAtStartPar
will only analyze the first ten kernels inside of the \sphinxcode{\sphinxupquote{GravitySolve()}} NVTX region.

\sphinxAtStartPar
For further details on how to choose a subset of CUDA kernels to analyze, or to run a more detailed
analysis, including CUDA hardware counters, refer to the Nsight Compute official documentation on
\sphinxhref{https://docs.nvidia.com/nsight-compute/NsightComputeCli/index.html\#nvtx-filtering}{NVTX Filtering}.


\subsection{Roofline}
\label{\detokenize{External_Profiling_Tools:roofline}}
\sphinxAtStartPar
As of version 2020.1.0, Nsight Compute has added the capability to perform roofline analyses on CUDA
kernels to describe how well a given kernel is running on a given NVIDIA architecture.  For details
on the roofline capabilities in Nsight Compute, refer to the \sphinxhref{https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html\#roofline}{NVIDIA Kernel Profiling Guide}.

\sphinxAtStartPar
To run a roofline analysis on an AMReX application, run \sphinxcode{\sphinxupquote{ncu}} with the flag
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}section SpeedOfLight\_RooflineChart}}. Again, using appropriate NVTX flags to limit the scope of the
analysis will be critical to achieve results within a reasonable time. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{ncu \PYGZhy{}\PYGZhy{}section SpeedOfLight\PYGZus{}RooflineChart \PYGZhy{}\PYGZhy{}nvtx \PYGZhy{}\PYGZhy{}nvtx\PYGZhy{}include \PYGZdq{}MLMG()\PYGZdq{} \PYGZhy{}c 10 \PYGZhy{}o roofline \PYGZdl{}\PYGZob{}EXE\PYGZcb{} \PYGZdl{}\PYGZob{}INPUTS\PYGZcb{} amrex.fpe\PYGZus{}trap\PYGZus{}invalid=0}
\end{sphinxVerbatim}

\sphinxAtStartPar
will perform a roofline analysis of the first ten kernels inside of the region \sphinxcode{\sphinxupquote{MLMG()}}, and report
their relative performance in the file \sphinxcode{\sphinxupquote{roofline}}, which can be read by the Nsight Compute GUI.

\sphinxAtStartPar
For further information on the roofline model, refer to the scientific literature, \sphinxhref{https://en.wikipedia.org/wiki/Roofline\_model}{Wikipedia
overview}, NERSC
\sphinxhref{https://docs.nersc.gov/development/performance-debugging-tools/roofline/}{documentation} and
\sphinxhref{https://www.nersc.gov/users/training/events/roofline-on-nvidia-gpus-hackathon/}{tutorials}.


\chapter{External Frameworks}
\label{\detokenize{External_Frameworks_Chapter:external-frameworks}}\label{\detokenize{External_Frameworks_Chapter:chap-external-frameworks}}\label{\detokenize{External_Frameworks_Chapter::doc}}

\section{SUNDIALS}
\label{\detokenize{SUNDIALS_top:sundials}}\label{\detokenize{SUNDIALS_top:chap-sundials}}\label{\detokenize{SUNDIALS_top::doc}}
\sphinxAtStartPar
Tutorials on how to use AMReX with SUNDIALS are available
\sphinxhref{https://github.com/AMReX-Codes/ATPESC-codes}{here}.


\section{SWFFT}
\label{\detokenize{SWFFT:swfft}}\label{\detokenize{SWFFT:swfftdoc}}\label{\detokenize{SWFFT::doc}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hacc/SWFFT}}, developed by Adrian Pope et al. at Argonne National Lab, provides the functionality to perform forward and reverse Fast Fourier Transforms (FFT) within a fully parallelized framework built in C++ and F90. In the words of HACC’s developers, SWFFT is a “distributed\sphinxhyphen{}memory, pencil\sphinxhyphen{}decomposed, parallel 3D FFT.” \sphinxstepexplicit %
\begin{footnote}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
\sphinxurl{https://xgitlab.cels.anl.gov/hacc/SWFFT}
%
\end{footnote} The SWFFT source code is also contained in the following directory within AMReX: \sphinxcode{\sphinxupquote{amrex/Src/Extern/SWFFT}}. \sphinxstepexplicit %
\begin{footnote}[2]\phantomsection\label{\thesphinxscope.2}%
\sphinxAtStartFootnote
SWFFT source code directory in AMReX: amrex/Src/Extern/SWFFT
%
\end{footnote}


\subsection{Pencil Redistribution}
\label{\detokenize{SWFFT:pencil-redistribution}}
\sphinxAtStartPar
As input, SWFFT takes three\sphinxhyphen{}dimensional arrays of data distributed across block\sphinxhyphen{}structured grids, and redistributes the data into “pencil” grids in \(z, x,\) and then \(y\), belonging to different MPI processes. After each pencil conversion, a 1D FFT is performed on the data along the pencil direction using calls to the FFTW \sphinxstepexplicit %
\begin{footnote}[3]\phantomsection\label{\thesphinxscope.3}%
\sphinxAtStartFootnote
\sphinxurl{http://www.fftw.org/}
%
\end{footnote} library. The \sphinxcode{\sphinxupquote{README}} files in the tutorial directories specify the relationship between the number of grids and the number of MPI processes that should be used. The \sphinxcode{\sphinxupquote{hacc/SWFFT}} \sphinxcode{\sphinxupquote{README}} document by Adrian Pope et al. explains restrictions on grid dimensions in relation to the number of MPI processes \sphinxfootnotemark[1]  \sphinxfootnotemark[2]:
\begin{quote}

\sphinxAtStartPar
{[}…{]} A rule of thumb is that {[}SWFFT{]} generally works when the number of vertices along
one side of the global 3D grid (“ng”) can be factored into small primes, and
when the number of MPI ranks can also be factored into small primes.
I believe that all of the unique prime factors of the number of MPI ranks
must be present in the set of prime factors of the grid, eg. if you have
20 MPI ranks then ng must be a multiple of 5 and 2. The \sphinxcode{\sphinxupquote{CheckDecomposition}}
utility is provided to check (on one rank) whether a proposed grid size and
number of MPI ranks will work, which can be done before submitting a large
test with \sphinxcode{\sphinxupquote{TestDfft/TestFDfft}}.
\end{quote}

\sphinxAtStartPar
The relationship between the number of processes versus global grid dimensions is determined by how the total number of grids can be factored from a three dimensional grid structure (block structured grids) into a two dimensional structure (pencil arrays), as shown in the figures below.

\sphinxAtStartPar
The following figures illustrate how data is distributed from block structured grids to pencil arrays within SWFFT, where the colors of each box indicate which MPI rank it belongs to:


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SWFFT Redistribution from \protect\(4 \times 4 \times 4\protect\) Box Array into Pencils}\label{\detokenize{SWFFT:id9}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_4x4x4}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_8x8x1}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] (a) Block structured grids: \(N_x=4,N_y=4,N_z=4\)
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] (b) Z\sphinxhyphen{}pencils: \(N_x=8,N_y=8,N_z=1\)
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SWFFT Redistribution from \protect\(2 \times 2 \times 2\protect\) Box Array into Pencils}\label{\detokenize{SWFFT:id10}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_2x2x2}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_4x2x1}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] (a) Block structured grids: \(N_x=2,N_y=2,N_z=2\)
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] (b) Z\sphinxhyphen{}pencils: \(N_x=4,N_y=2,N_z=1\)
\end{DUlineblock}
\\
\hline
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_1x4x2}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{grid_4x1x2}.png}
\\
\hline
\begin{DUlineblock}{0em}
\item[] (c) X\sphinxhyphen{}pencils: \(N_x=1,N_y=4,N_z=2\)
\end{DUlineblock}
&
\begin{DUlineblock}{0em}
\item[] (d) Y\sphinxhyphen{}pencils: \(N_x=4,N_y=1,N_z=2\)
\end{DUlineblock}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Using the same number of AMReX grids as processes has been verified to work in the \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-poisson}{SWFFT Poisson} and \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-simple}{SWFFT Simple} tutorials. This can be illustrated by the following equation for the total number of grids, \(N_{b}\), in a regularly structured domain:
\begin{equation*}
\begin{split}N_{b} = m_{bi} m_{bj} = n_{bi} n_{bj} n_{bk},\end{split}
\end{equation*}
\sphinxAtStartPar
where \(n_{bi}, n_{bj},\) and  \(n_{bk}\) are the number of grids, or boxes, in the \(x, y,\) and \(z\) dimensions of the block\sphinxhyphen{}structured grid. Analogously, for pencil distributions, \(m_{bi}\) and \(m_{bj}\) are the number of grids along the remaining dimensions if pencils are taken in the \(k\) direction. There are many possible ways of redistributing the data, for example \(m_{bi} = n_{bi}n_{bk}\) \& \(m_{bj} = n_{bj}\) is one possible simple configuration. However, it is evident from the figures above that the SWFFT redistribution algorithm has a more sophisticated method for finding the prime factors of the grid.


\subsection{Tutorials}
\label{\detokenize{SWFFT:tutorials}}
\sphinxAtStartPar
AMReX contains two SWFFT tutorials, \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-poisson}{SWFFT Poisson} and \sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-simple}{SWFFT Simple}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-poisson}{SWFFT Poisson} solves a Poisson equation with periodic boundary conditions.  In it, both a forward FFT
and reverse FFT are called to solve the equation, however, no reordering of the DFT data in k\sphinxhyphen{}space is performed.

\item {} 
\sphinxAtStartPar
\sphinxhref{https://amrex-codes.github.io/amrex/tutorials\_html/SWFFT\_Tutorial.html\#swfft-simple}{SWFFT Simple} is useful if the objective is to simply take a forward FFT of data,
and the DFT’s ordering in k\sphinxhyphen{}space matters to the user. This tutorial initializes a 3D or 2D \sphinxcode{\sphinxupquote{\DUrole{name}{MultiFab}}},
takes a forward FFT, and then redistributes the data in k\sphinxhyphen{}space back to the “correct,” 0 to \(2\pi\), ordering.
The results are written to a plot file.

\end{itemize}


\chapter{Regression Testing}
\label{\detokenize{Regression_Testing_Chapter:regression-testing}}\label{\detokenize{Regression_Testing_Chapter:chap-regression-testing}}\label{\detokenize{Regression_Testing_Chapter::doc}}

\section{Continuous Compilation Testing}
\label{\detokenize{Testing:continuous-compilation-testing}}\label{\detokenize{Testing::doc}}
\sphinxAtStartPar
As a first line of testing, on every commit to the repository, we verify that we can compile
AMReX as a library for a common set of configuration options. This operation is performed
through Travis\sphinxhyphen{}CI. This layer of testing is deliberately limited, so that it can be run
quickly on every commit. For more extensive testing, we rely on the nightly regression results.


\section{Nightly Regression Testing}
\label{\detokenize{Testing:nightly-regression-testing}}
\sphinxAtStartPar
Each night, we automically run a suite of tests, both on AMReX itself, and on a most of the major
application codes that use it as a framework. We use an in\sphinxhyphen{}house test runner script to manage this
operation, originally developed by Michael Zingale for the Castro code, and later expanded to other
application codes as well. The results for each night are collected and stored on a web page; see
\sphinxurl{https://ccse.lbl.gov/pub/RegressionTesting/} for the latest set of results.


\section{Running the test suite locally}
\label{\detokenize{Testing:running-the-test-suite-locally}}
\sphinxAtStartPar
The test suite is mostly used internally by AMReX developers. However,
f you are making a pull request to AMReX, it can be useful to run the test suite
on your local machine, to reduce the liklihood that your changes break some existing functionality.
To run the test suite on locally, you must first obtain a copy of the test runner source, available
on Github here: \sphinxurl{https://github.com/AMReX-Codes/regression\_testing}. The test runner requires Python
version 2.7 or greater.

\sphinxAtStartPar
Next, you need a configuration file that defines which tests to run, which amrex repository to test,
which branch to use, etc. A sample configuration file for AMReX is distributed with the amrex source
code at \sphinxcode{\sphinxupquote{\DUrole{name}{amrex}\DUrole{operator}{/}\DUrole{name}{Tools}\DUrole{operator}{/}\DUrole{name}{RegressionTesting}\DUrole{operator}{/}\DUrole{name}{AMReX}\DUrole{operator}{\sphinxhyphen{}}\DUrole{name}{tests}\DUrole{punctuation}{.}\DUrole{name}{ini}}}. You will need to modify a few of the entries
to, for example, point the test runner to the clone of amrex on your local machine. Entries you will
likely want to change include:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{testTopDir} \PYG{o}{=} /path/to/test/output \PYG{c+c1}{\PYGZsh{} the tests results and benchmarks will stored here}
\PYG{n+nv}{webTopDir}  \PYG{o}{=} /path/to/web/output  \PYG{c+c1}{\PYGZsh{} a web page with the test results will be written here}
\end{sphinxVerbatim}

\sphinxAtStartPar
to control where the generated output will be written, and

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}AMReX\PYG{o}{]}
\PYG{n+nv}{dir} \PYG{o}{=} /path/to/amrex  \PYG{c+c1}{\PYGZsh{} the path to the amrex repository you want to test}
\PYG{n+nv}{branch} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}development\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
to control which repository and branch to test.

\sphinxAtStartPar
The test runner is a Python script and can be invoked like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZlt{}options\PYGZgt{} AMReX\PYGZhy{}Tests.ini
\end{sphinxVerbatim}

\sphinxAtStartPar
Before you can use it, you must first generate a set of “benchmarks” \sphinxhyphen{} i.e. known “good” answers to the
tests that will be run. If you are testing a pull request, you can generate these by running the script
with the a recent version of the \sphinxcode{\sphinxupquote{\DUrole{name}{development}}} branch of AMReX. You can generate the benchmarks like so:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZhy{}\PYGZhy{}make\PYGZus{}benchmarks \PYG{l+s+s1}{\PYGZsq{}generating initial benchmarks\PYGZsq{}} AMReX\PYGZhy{}Tests.ini
\end{sphinxVerbatim}

\sphinxAtStartPar
Once that is finished, you can switch over to the branch you want to test in \sphinxcode{\sphinxupquote{\DUrole{name}{AMReX}\DUrole{operator}{\sphinxhyphen{}}\DUrole{name}{Tests}\DUrole{punctuation}{.}\DUrole{name}{ini}}}, and then
re\sphinxhyphen{}run the script without the \sphinxcode{\sphinxupquote{\DUrole{operator}{\textendash{}}\DUrole{name}{make\_benchmarks}}} option:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZhy{}\PYGZhy{}make\PYGZus{}benchmarks \PYG{l+s+s1}{\PYGZsq{}generating initial benchmarks\PYGZsq{}} AMReX\PYGZhy{}Tests.ini
\end{sphinxVerbatim}

\sphinxAtStartPar
The script will generate a set of html pages in the directory specified in your \sphinxcode{\sphinxupquote{\DUrole{name}{AMReX}\DUrole{operator}{\sphinxhyphen{}}\DUrole{name}{Tests}\DUrole{punctuation}{.}\DUrole{name}{ini}}}
file that you can examine using the browser of your choice.

\sphinxAtStartPar
For a complete set of script options, run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZhy{}\PYGZhy{}help
\end{sphinxVerbatim}

\sphinxAtStartPar
A particularly useful option lets you run just a subset of the complete test suite. To run only one test, you can do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZhy{}\PYGZhy{}single\PYGZus{}test \PYGZlt{}TestName\PYGZgt{} AMReX\PYGZhy{}Tests.ini
\end{sphinxVerbatim}

\sphinxAtStartPar
To run an enumerated list of tests, do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python regtest.py \PYGZhy{}\PYGZhy{}tests \PYG{l+s+s1}{\PYGZsq{}\PYGZlt{}TestName1\PYGZgt{} \PYGZlt{}TestName2\PYGZgt{} \PYGZlt{}TestName3\PYGZgt{}\PYGZsq{}} AMReX\PYGZhy{}Tests.ini
\end{sphinxVerbatim}


\section{Adding a new test}
\label{\detokenize{Testing:adding-a-new-test}}
\sphinxAtStartPar
New tests can be added to the suite by modifying the \sphinxcode{\sphinxupquote{\DUrole{name}{AMReX}\DUrole{operator}{\sphinxhyphen{}}\DUrole{name}{Tests}\DUrole{punctuation}{.}\DUrole{name}{ini}}} file. The easiest thing to
do is start from an existing test and modify it. For example, this entry:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}MLMG\PYGZus{}FI\PYGZus{}PoisCom\PYG{o}{]}
\PYG{n+nv}{buildDir} \PYG{o}{=} Tutorials/LinearSolvers/ABecLaplacian\PYGZus{}F
\PYG{n+nv}{inputFile} \PYG{o}{=} inputs\PYGZhy{}rt\PYGZhy{}poisson\PYGZhy{}com
\PYG{n+nv}{dim} \PYG{o}{=} \PYG{l+m}{3}
\PYG{n+nv}{restartTest} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{useMPI} \PYG{o}{=} \PYG{l+m}{1}
\PYG{n+nv}{numprocs} \PYG{o}{=} \PYG{l+m}{2}
\PYG{n+nv}{useOMP} \PYG{o}{=} \PYG{l+m}{1}
\PYG{n+nv}{numthreads} \PYG{o}{=} \PYG{l+m}{3}
\PYG{n+nv}{compileTest} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{doVis} \PYG{o}{=} \PYG{l+m}{0}
\PYG{n+nv}{outputFile} \PYG{o}{=} plot
\PYG{n+nv}{testSrcTree} \PYG{o}{=} C\PYGZus{}Src
\end{sphinxVerbatim}

\sphinxAtStartPar
defines a test called \sphinxcode{\sphinxupquote{\DUrole{name}{MLMG\_FI\_PoisCom}}} by specifying the appropriate build directory, inputs file,
and a set of configuration options. The above options are the most commonly changed; for a full list
of options, see the example configuration file at \sphinxurl{https://github.com/AMReX-Codes/regression\_testing/blob/main/example-tests.ini}.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\sphinxAtStartPar
The copyright notice of AMReX is included in the AMReX home directory
as README.txt.
Your use of this software is under the 3\sphinxhyphen{}clause BSD license \textendash{} the license agreement is included in the
AMReX home directory as license.txt.

\sphinxAtStartPar
For a pdf version of this documentation, click \sphinxcode{\sphinxupquote{here}}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}